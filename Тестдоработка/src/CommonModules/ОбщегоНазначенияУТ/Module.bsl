
#Область ПрограммныйИнтерфейс

#Область МетодыРаботыАвтозаполненияРеквизитовДокумента

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//  Неотрицательный - Булево, если Истина, то числа только положительные, если Ложь, то любые.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти, Неотрицательный = Ложь) Экспорт
	
	Если Неотрицательный Тогда
		Знак = ДопустимыйЗнак.Неотрицательный;
	Иначе
		Знак = ДопустимыйЗнак.Любой;
	КонецЕсли;
	
	Возврат Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, Знак));

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));

КонецФункции // ПолучитьОписаниеТиповДаты()

// Дополняет одну таблицу значений строками другой таблицы значений
//
// Параметры:
//	Приемник			- произвольная коллекция, в которую добавляются строки
//	Источник 			- произвольная коллекция, из которой берутся добавляемые строки
//	СоответствиеПолей	- Соответствие - используется чтобы заполнить поля с разными названиями, 
//										ключ содержит имя поля приемника, значение содержит имя поля источника.
//	ЗначенияПоУмолчанию - Структура - значения, которые будут помещены во все добавленные строки,
//										ключ содержит имя поля приемника.
//
Процедура ДобавитьСтрокиВТаблицу(Приемник, Источник, СоответствиеПолей = Неопределено, ЗначенияПоУмолчанию = Неопределено) Экспорт

	Для каждого СтрокаИсточника Из Источник Цикл
		НоваяСтрока = Приемник.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИсточника);
		Если СоответствиеПолей <> Неопределено Тогда
			Для каждого КлючИЗначение Из СоответствиеПолей Цикл
				НоваяСтрока[КлючИЗначение.Ключ] = СтрокаИсточника[КлючИЗначение.Значение];
			КонецЦикла; 
		КонецЕсли; 
		Если ЗначенияПоУмолчанию <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ЗначенияПоУмолчанию);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Заполняет колонку таблицы значений последовательными номерами
//
// Параметры:
//	Таблица - таблица значений, строки которой нужно пронумеровать
//	ИмяКолонкиНомераСтроки - колонка таблицы значений, в которой будут указаны номера строк.
//
Процедура ПронумероватьТаблицуЗначений(Таблица, ИмяКолонкиНомераСтроки) Экспорт

	Если Таблица.Колонки.Найти(ИмяКолонкиНомераСтроки) = Неопределено Тогда
		Таблица.Колонки.Добавить(ИмяКолонкиНомераСтроки, ПолучитьОписаниеТиповЧисла(15, 0));
	КонецЕсли;

	КоличествоСтрок = Таблица.Количество() - 1;
	Для НомерСтроки = 0 По КоличествоСтрок Цикл
		Таблица[НомерСтроки][ИмяКолонкиНомераСтроки] = НомерСтроки;
	КонецЦикла;

КонецПроцедуры

// Выгружает таблицу значений из ДанныеФормыКоллекция и ТабличнаяЧасть
//
// Параметры:
// 		ТаблицаИсточник - ДанныеФормыКоллекция, ТабличнаяЧасть - Таблица источник выгрузки
// 		Строки - Массив, Структура - Массив строк для выгрузки или структура отбора
// 		Колонки - Строка - Перечисленные через запятую имена колонок для выгрузки
// 		КолонкиПоЗначению - Структура - Структура колонок для добавление в результирующую таблицу:
// 										Ключ - Имя новой колонки
// 										Значение - Значение для подстановки по все строки новой колонки
// 		НовыеИменаКолонок - Структура - Структура с данными о переименовании колонок в результирующей таблице:
// 										Ключ - Текущее имя колонки
// 										Значение - Новое имя колонки.
//
// Возвращаемое значение:
// 		ТаблицаЗначений - Таблица результат выгрузки из таблицы источника с добавленными и переименованными колонками.
//
Функция ВыгрузитьТаблицуЗначений(ТаблицаИсточник, Строки = Неопределено, Колонки = "НомерСтроки",
			Знач КолонкиПоЗначению = Неопределено, Знач НовыеИменаКолонок = Неопределено) Экспорт
	
	// Определение значений по умолчанию
	Если КолонкиПоЗначению = Неопределено Тогда
		КолонкиПоЗначению = Новый Структура;
	КонецЕсли;
	Если НовыеИменаКолонок = Неопределено Тогда
		НовыеИменаКолонок = Новый Структура;
	КонецЕсли;
	
	// Определить список выгружаемых колонок
	СтруктураДругихИменКолонок = Новый Структура;
	Для Каждого НовоеИмя Из НовыеИменаКолонок Цикл
		СтруктураДругихИменКолонок.Вставить(НовоеИмя.Значение, НовоеИмя.Ключ);
	КонецЦикла;
	ИменаКолонок = "";
	ИмяКолонки = "";
	СтруктураКолонок = Новый Структура(Колонки);
	Для Каждого Колонка Из СтруктураКолонок Цикл
		Если Не СтруктураДругихИменКолонок.Свойство(Колонка.Ключ, ИмяКолонки) Тогда
			ИмяКолонки = Колонка.Ключ;
		КонецЕсли;
		Если Не КолонкиПоЗначению.Свойство(ИмяКолонки) Тогда
			ИменаКолонок = ИменаКолонок + ", " + ИмяКолонки;
		КонецЕсли;
	КонецЦикла;
	
	// Выгрузить из таблицы источника
	Если ТипЗнч(ТаблицаИсточник) = Тип("ТаблицаЗначений") Тогда
		ТаблицаРезультата = ТаблицаИсточник.Скопировать(Строки, Сред(ИменаКолонок, 3));
	Иначе
		ТаблицаРезультата = ТаблицаИсточник.Выгрузить(Строки, Сред(ИменаКолонок, 3));
	КонецЕсли;
	
	// Добавить новые колонки в таблицу результата
	Если КолонкиПоЗначению <> Неопределено Тогда
		Для Каждого Колонка Из КолонкиПоЗначению Цикл
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(ТипЗнч(Колонка.Значение));
			ТаблицаРезультата.Колонки.Добавить(Колонка.Ключ, Новый ОписаниеТипов(МассивТипов));
			ТаблицаРезультата.ЗаполнитьЗначения(Колонка.Значение, Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;
	
	// Переименовать колонки в таблице результата
	Если НовыеИменаКолонок <> Неопределено Тогда
		Для Каждого Колонка Из НовыеИменаКолонок Цикл
			ТаблицаРезультата.Колонки[Колонка.Ключ].Имя = Колонка.Значение;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаРезультата;
	
КонецФункции // ВыгрузитьТаблицуЗначений()

// Заполняет идентификатор строк в таблице значений
//
// Параметры:
//  Таблица				 - ТаблицаЗначений	 - таблица значений, строки которой нужно пронумеровать
//  ИмяКолонки			 - Строка			 - колонка таблицы значений, в которой будут заполнены идентификаторы.
//  ТипИдентификатора	 - Строка			 - тип идентификатора ("Число", "УникальныйИдентификатор")
//
Процедура ДобавитьИдентификаторСтрокВТаблицу(Таблица, ИмяКолонки = "Идентификатор", ТипИдентификатора = "Число") Экспорт

	Если ТипИдентификатора = "Число" Тогда

		Если Таблица.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Таблица.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 0, ДопустимыйЗнак.Неотрицательный)));
		КонецЕсли;
		
		Для НомерСтроки = 0 По Таблица.Количество() - 1 Цикл
			Таблица[НомерСтроки][ИмяКолонки] = НомерСтроки + 1;
		КонецЦикла;
		
	ИначеЕсли ТипИдентификатора = "УникальныйИдентификатор" Тогда
		
		Если Таблица.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Таблица.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("УникальныйИдентификатор"));
		КонецЕсли;
		
		Для НомерСтроки = 0 По Таблица.Количество() - 1 Цикл
			Таблица[НомерСтроки][ИмяКолонки] = Новый УникальныйИдентификатор;
		КонецЦикла;
		
	КонецЕсли;

КонецПроцедуры

// Процедура делает запись в журнал регистрации и сообщает пользователю, если это сообщение об ошибке 
// Параметры:
//   ПараметрыЖурнала - Структура - параметры записи в журнал регистрации
//			Свойства:
//       		ГруппаСобытий - Строка - префикс для имени события журнала регистрации
//       		Метаданные - ОбъектМетаданных - метаданные для записи в журнал регистрации
//       		Данные - Произвольный - данные для записи в журнал регистрации
//   ИмяСобытия - Строка  - имя события (в журнал событие записывается в формате ГруппаСобытий.ИмяСобытия)
//   Уровень - УровеньЖурналаРегистрации  - Соответствует уровням журнала регистрации
//   Комментарий - Строка - комментарий о событии
//   ИнформацияОбОшибке - ИнформацияОбОшибке, Строка - Информация об ошибке, которую так же необходимо задокументировать
//                                                     в комментарии журнала регистрации.
//
Процедура ЗаписатьВЖурналСообщитьПользователю(ПараметрыЖурнала, УровеньЖурнала, ИмяСобытия, Знач Комментарий = "", ИнформацияОбОшибке = Неопределено) Экспорт
	
	Если ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
		Если Комментарий = "" Тогда
			ТестСообщенияПользователю = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Иначе
			ТестСообщенияПользователю = Комментарий + Символы.ПС + КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = Комментарий + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецЕсли;
	Иначе
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("Строка") 
			И Не ПустаяСтрока(ИнформацияОбОшибке) Тогда
			Комментарий = Комментарий + Символы.ПС + ИнформацияОбОшибке;
		КонецЕсли;
		ТестСообщенияПользователю = Комментарий;
	КонецЕсли;
	
	// Журнал регистрации 
	УстановитьПривилегированныйРежим(Истина);
	ЗаписьЖурналаРегистрации(
	    СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='%1'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			ПараметрыЖурнала.ГруппаСобытий + ?(ИмяСобытия = "", "", "." + ИмяСобытия)),
		УровеньЖурнала, 
		ПараметрыЖурнала.Метаданные, 
		ПараметрыЖурнала.Данные, 
		Комментарий);
	УстановитьПривилегированныйРежим(Ложь);
	
	Если УровеньЖурнала = УровеньЖурналаРегистрации.Ошибка 
		Или УровеньЖурнала = УровеньЖурналаРегистрации.Предупреждение Тогда
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СокрЛП(ТестСообщенияПользователю),ПараметрыЖурнала.Данные);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает ключ данных для подстановки в сообщение пользователю
// Ключ данных нужен при групповой обработке объектов - если он установлен, то при нажатии пользователем на сообщение
// будет открываться форма объекта.
//
//	Параметры:
//		Объект - Произвольный - объект, для которого нужно получить ключ данных.
//	
//	Возвращаемое значение
//		Ссылка - ссылка на объект информационной базы.
//
Функция КлючДанныхДляСообщенияПользователю(Объект) Экспорт
	
	КлючДанных = Неопределено;
	XMLТипЗнч = XMLТипЗнч(Объект); 
	
	Если XMLТипЗнч <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч.ИмяТипа;
		Если СтрНайти(ТипЗначенияСтрокой, "Object.") > 0 Тогда
			КлючДанных = Объект.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	Возврат КлючДанных;
	
КонецФункции

// Вызывается из подписки ЗаполнитьРеквизитыОбъекта
// Проверяет заполненность реквизитов формы, связанных с функциональными опциями
// ИспользоватьНесколькоОрганизаций, ИспользоватьНесколькоСкладов, ИспользоватьНесколькоВалют.
//
//	Параметры:
//		Объект - Произвольный - объект
//		ДанныеЗаполнения - Структура
//		СтандартнаяОбработка - Структура
//	
//	Возвращаемое значение
//		Ссылка - ссылка на объект информационной базы.
//
Процедура ОбработкаЗаполнения(Объект, ДанныеЗаполнения, СтандартнаяОбработка) Экспорт
	
	// Пропускаем обработку, чтобы гарантировать получение формы при передаче параметра "АвтоТест".
	Если ДанныеЗаполнения = "АвтоТест" Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизаций")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Организация")
		И Не ЗначениеЗаполнено(Объект.Организация) Тогда
		Объект.Организация = ЗначениеНастроекПовтИсп.ПолучитьОрганизациюПоУмолчанию(Объект.Организация);
		Если Не ЗначениеЗаполнено(Объект.Организация) Тогда
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
			|	Организации.Ссылка
			|ИЗ
			|	Справочник.Организации КАК Организации");
			
			Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Организация"". В информационной базе введено несколько организаций,
				|Включите опцию ""НСИ и администрирование""-""Предприятие""-""Несколько организаций""!'");
			Иначе
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Организация"". Возможно, в информационной базе не введено ни одной организации!
				|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Сведения об организации"".'");
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоСкладов")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Склад")
		И Не ЗначениеЗаполнено(Объект.Склад) Тогда
		Объект.Склад = ЗначениеНастроекПовтИсп.ПолучитьСкладПоУмолчанию(Объект.Склад);
		Если Не ЗначениеЗаполнено(Объект.Склад) Тогда
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
			|	Склады.Ссылка
			|ИЗ
			|	Справочник.Склады КАК Склады");
			
			Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Склад"". В информационной базе введено несколько складов,
				|Включите опцию ""НСИ и администрирование""-""Склад и доставка""-""Несколько складов""!'");
			Иначе
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Склад"". Возможно, в информационной базе не введено ни одного склада
				|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка складского учета"".'");
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоВалют")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Валюта")
		И Не ЗначениеЗаполнено(Объект.Валюта) Тогда
		Объект.Валюта = ДоходыИРасходыСервер.ПолучитьВалютуУправленческогоУчета(Объект.Валюта);
		Если Не ЗначениеЗаполнено(Объект.Валюта) Тогда
			ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Валюта"". Установите валюту управленческого учета!'");
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоВалют")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "ВалютаВзаиморасчетов")
		И Не ЗначениеЗаполнено(Объект.ВалютаВзаиморасчетов) Тогда
		Объект.ВалютаВзаиморасчетов = ДоходыИРасходыСервер.ПолучитьВалютуУправленческогоУчета(Объект.ВалютаВзаиморасчетов);
		Если Не ЗначениеЗаполнено(Объект.ВалютаВзаиморасчетов) Тогда
			ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""ВалютаВзаиморасчетов"". Установите валюту управленческого учета!'");
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоКасс")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Касса")
		И Не ЗначениеЗаполнено(Объект.Касса) Тогда
		
		Если Объект.ДополнительныеСвойства.Свойство("НеобходимостьЗаполненияКассыПриФОИспользоватьНесколькоКассЛожь") 
			И НЕ Объект.ДополнительныеСвойства.НеобходимостьЗаполненияКассыПриФОИспользоватьНесколькоКассЛожь Тогда
			// Не требуется заполнение кассы при не включенной опции "ИспользоватьНесколькоКасс".
		Иначе
			
			СтруктураПараметров = ДенежныеСредстваСервер.ПараметрыЗаполненияКассыОрганизацииПоУмолчанию();
			СтруктураПараметров.Касса 			= Объект.Касса;
			Объект.Касса = ЗначениеНастроекПовтИсп.ПолучитьКассуОрганизацииПоУмолчанию(СтруктураПараметров);
			Если Не ЗначениеЗаполнено(Объект.Касса) Тогда
				
				Запрос = Новый Запрос(
				"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
				|	Кассы.Ссылка
				|ИЗ
				|	Справочник.Кассы КАК Кассы
				|ГДЕ
				|	НЕ Кассы.ПометкаУдаления");
				
				Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
					ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Касса"". В информационной базе введено несколько касс,
					|Включите опцию ""НСИ и администрирование""-""Казначейство""-""Несколько касс""!'");
				Иначе
					ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Касса"". Возможно, в информационной базе не введено ни одной кассы!
					|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка кассы"".'");
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоРасчетныхСчетов")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "БанковскийСчет")
		И Не ЗначениеЗаполнено(Объект.БанковскийСчет) Тогда
		
		Если Объект.ДополнительныеСвойства.Свойство("НеобходимостьЗаполненияСчетаПриФОИспользоватьНесколькоСчетовЛожь") 
			И НЕ Объект.ДополнительныеСвойства.НеобходимостьЗаполненияСчетаПриФОИспользоватьНесколькоСчетовЛожь Тогда
			// Не требуется заполнение расчетного счета при не включенной опции "ИспользоватьНесколькоРасчетныхСчетов".
		Иначе
			
			СтруктураПараметров = ДенежныеСредстваСервер.ПараметрыЗаполненияБанковскогоСчетаОрганизацииПоУмолчанию();
			СтруктураПараметров.БанковскийСчет = Объект.БанковскийСчет;  
			Объект.БанковскийСчет = ЗначениеНастроекПовтИсп.ПолучитьБанковскийСчетОрганизацииПоУмолчанию(СтруктураПараметров);
			
			Если Не ЗначениеЗаполнено(Объект.БанковскийСчет) Тогда
				
				Запрос = Новый Запрос(
				"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
				|	БанковскиеСчетаОрганизаций.Ссылка
				|ИЗ
				|	Справочник.БанковскиеСчетаОрганизаций КАК БанковскиеСчетаОрганизаций");
				
				Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
					ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Банковский счет"". В информационной базе введено несколько банковских счетов организаций,
					|Включите опцию ""НСИ и администрирование""-""Казначейство""-""Несколько банковских счетов""!'");
				Иначе
					ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Банковский счет"". Возможно, в информационной базе не введено ни одного банковского счета организации!
					|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка банковского счета"".'");
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет уникальный идентификатор платежа
Функция ПолучитьУникальныйИдентификаторПлатежа(Объект) Экспорт
	
	Префикс = ПолучитьПрефиксДляУИП(Объект.Ссылка);
	Дата = Формат(Объект.Дата, "ДФ=yyMM");
	Номер = СтрЗаменить(Объект.Номер, "-", "");
	Код = Строка(Префикс) + Строка(Дата) + Строка(Номер);
	УИН = ПолучитьУникальныйИдентификаторПлатежаСКонтрольнымРазрядом(Код);
	
	Возврат УИН;
	
КонецФункции

// Функция возвращает изменения документа, относительно записанного в базе
// 
// Параметры:
// 	Объект - ДокументОбъект - Документ, изменение которого необходимо проанализировать
// 	РеквизитыИсключения - Структура - Структура имен реквизитов, изменение которых проверять не требуется
// 	ТабличныеЧастиИсключения - Структура - Структура имен табличных частей, изменение которых проверять не требуется.
//
// Возвращаемое значение:
// 	Структура - Структура - Содержит изменения объекта:
// 								- по ключу "Реквизиты" - таблица измененных реквизитов
// 								- по ключу "ТабличныеЧасти" - структура низменных табличных частей.
Функция ИзмененияДокумента(Объект, РеквизитыИсключения = Неопределено, ТабличныеЧастиИсключения = Неопределено) Экспорт
	
	Результат = Новый Структура;
	
	Если РеквизитыИсключения = Неопределено Тогда
		РеквизитыИсключения = Новый Структура;
	КонецЕсли;
	
	Если ТабличныеЧастиИсключения = Неопределено Тогда
		ТабличныеЧастиИсключения = Новый Структура;
	КонецЕсли;
	
	МетаданныеДокумента = Объект.Метаданные();
	
	ПолноеИмя = МетаданныеДокумента.ПолноеИмя();
	
	СтрокаНеограниченнойДлинны = Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(0));
	
	РеквизитыДокумента = Новый Структура;
	РеквизитыДокумента.Вставить("Дата");
	Для каждого Реквизит Из МетаданныеДокумента.Реквизиты Цикл
		Если СтрНайти(Реквизит.Имя, "Удалить") = 1 Тогда
			Продолжить;
		КонецЕсли;
		Если Реквизит.Тип = СтрокаНеограниченнойДлинны Тогда
			Продолжить;
		КонецЕсли;
		Если РеквизитыИсключения.Свойство(Реквизит.Имя) Тогда
			Продолжить;
		КонецЕсли;
		РеквизитыДокумента.Вставить(Реквизит.Имя);
	КонецЦикла;
	
	ТабличныеЧастиДокумента = Новый Структура;
	Для каждого ТабличнаяЧасть Из МетаданныеДокумента.ТабличныеЧасти Цикл
		Если СтрНайти(ТабличнаяЧасть.Имя, "Удалить") = 1 Тогда
			Продолжить;
		КонецЕсли;
		Если ТабличныеЧастиИсключения.Свойство(ТабличнаяЧасть.Имя) Тогда
			Продолжить;
		КонецЕсли;
		РеквизитыТабличнойЧасти = Новый Структура;
		Для каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
			Если Реквизит.Тип = СтрокаНеограниченнойДлинны Тогда
				Продолжить;
			КонецЕсли; 
			РеквизитыТабличнойЧасти.Вставить(Реквизит.Имя);
		КонецЦикла;
		ТабличныеЧастиДокумента.Вставить(ТабличнаяЧасть.Имя, РеквизитыТабличнойЧасти);
	КонецЦикла;
	
	ТекстЗапроса= "ВЫБРАТЬ
		|	Таблица.Проведен КАК Проведен";
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
	Для каждого Реквизит Из РеквизитыДокумента Цикл
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ); 
	КонецЦикла;
	
	ШаблонПоместить = "
	|ИЗ
	|	%1 КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка
	|";
	ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонПоместить, ПолноеИмя);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка); 
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий(); 
	
	ТаблицаИзмененныхРеквизитов = Новый ТаблицаЗначений;
	ТаблицаИзмененныхРеквизитов.Колонки.Добавить("Имя");
	ТаблицаИзмененныхРеквизитов.Колонки.Добавить("НовоеЗначение");
	ТаблицаИзмененныхРеквизитов.Колонки.Добавить("СтароеЗначение");
	Для каждого Реквизит Из РеквизитыДокумента Цикл
		Если Выборка[Реквизит.Ключ] <> Объект[Реквизит.Ключ] Тогда
			НоваяСтрока = ТаблицаИзмененныхРеквизитов.Добавить();
			НоваяСтрока.Имя = Реквизит.Ключ;
			НоваяСтрока.НовоеЗначение = Объект[Реквизит.Ключ];
			НоваяСтрока.СтароеЗначение = Выборка[Реквизит.Ключ];
		КонецЕсли;
	КонецЦикла;
	
	Если ТаблицаИзмененныхРеквизитов.Количество() > 0 Тогда
		Результат.Вставить("Реквизиты", ТаблицаИзмененныхРеквизитов);
	КонецЕсли;
	
	Для каждого ТабличнаяЧасть Из ТабличныеЧастиДокумента Цикл
		
		ТекстЗапроса = "ВЫБРАТЬ
		|	Таблица.НомерСтроки КАК НомерСтроки";
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		
		ШаблонПоместить = "
		|ПОМЕСТИТЬ НоваяТаблица%1
		|ИЗ
		|	&%1 КАК Таблица
		|;
		|
		|////////////////////////////
		|";
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонПоместить, ТабличнаяЧасть.Ключ);
		
		ТекстОбъединенияНовая =
		"ВЫБРАТЬ
		|	Таблица.НомерСтроки КАК НомерСтроки";
		
		ТекстОбъединенияСтарая =
		"ВЫБРАТЬ
		|	-Таблица.НомерСтроки КАК НомерСтроки";
		
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстОбъединенияНовая  = ТекстОбъединенияНовая + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
			ТекстОбъединенияСтарая = ТекстОбъединенияСтарая + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		
		ШаблонИзНовая = "
		|ИЗ
		|	НоваяТаблица%1 КАК Таблица";
		ТекстОбъединенияНовая = ТекстОбъединенияНовая + СтрШаблон(ШаблонИзНовая, ТабличнаяЧасть.Ключ);
		
		ШаблонИзСтарая = "
		|ИЗ
		|	%1.%2 КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка";
		ТекстОбъединенияСтарая = ТекстОбъединенияСтарая + СтрШаблон(ШаблонИзСтарая, ПолноеИмя, ТабличнаяЧасть.Ключ);
		
		ТекстЗапроса = ТекстЗапроса + 
		"ВЫБРАТЬ
		|	СУММА(ВложенныйЗапрос.НомерСтроки) КАК НомерСтроки";
		ШаблонРеквизит = ",
		|	ВложенныйЗапрос.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса  = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "
		|ИЗ 
		|(" 
		+ Символы.ПС + ТекстОбъединенияНовая 
		+ Символы.ПС + " ОБЪЕДИНИТЬ ВСЕ "
		+ Символы.ПС + ТекстОбъединенияСтарая + ") КАК ВложенныйЗапрос
		|
		|СГРУППИРОВАТЬ ПО";
		
		ШаблонСгруппировать = "
		|	ВложенныйЗапрос.%1,";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса  = ТекстЗапроса + СтрШаблон(ШаблонСгруппировать, Реквизит.Ключ);
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "ИСТИНА
		|ИМЕЮЩИЕ 
		|	СУММА(ВложенныйЗапрос.НомерСтроки) <> 0";
		
		Запрос = Новый Запрос;
		Запрос.Текст = ТекстЗапроса;
		Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
		Запрос.УстановитьПараметр(ТабличнаяЧасть.Ключ, Объект[ТабличнаяЧасть.Ключ]);
		
		РезультатЗапроса = Запрос.Выполнить();
		Если НЕ РезультатЗапроса.Пустой() Тогда
			Если НЕ Результат.Свойство("ТабличныеЧасти") Тогда
				Результат.Вставить("ТабличныеЧасти", Новый Структура);
			КонецЕсли;
			Результат.ТабличныеЧасти.Вставить(ТабличнаяЧасть.Ключ, РезультатЗапроса.Выгрузить());
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляПолученияПредставленияДанных

// Возвращает строковое представление документа для отображения в сообщениях.
//
// Параметры:
//	Ссылка - ссылка на документ
//	Номер - номер документа
//	Дата - дата документа
//
Функция ПолучитьПредставлениеДокумента(Ссылка, Номер, Дата) Экспорт
	
	Возврат
		Ссылка.Метаданные().Синоним
		+ ?(ЗначениеЗаполнено(Номер), " " + Номер, "")
		+ ?(ЗначениеЗаполнено(Дата), " " + НСтр("ru='от'") + " " + Формат(Дата,"ДЛФ=D"), "");
	
КонецФункции

#КонецОбласти

#Область ПрочиеПроцедурыИФункции

// Возвращает метаданные объекта по полному имени объекта метаданных
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  ПолноеИмя    - Строка, полное имя объекта метаданных,
//                 например, "Справочник.Организации".
//
// Возвращаемое значение:
//  КоллекцияОбъектовМетаданных
// 
Функция МетаданныеОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	КлассОМ = ЧастиИмени[0];
	ИмяОМ   = ЧастиИмени[1];
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Возврат Метаданные.ПланыОбмена[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Возврат Метаданные.Справочники[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Возврат Метаданные.Документы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Возврат Метаданные.ЖурналыДокументов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Возврат Метаданные.Перечисления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Возврат Метаданные.Отчеты[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Возврат Метаданные.Обработки[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Возврат Метаданные.ПланыВидовХарактеристик[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Возврат Метаданные.ПланыСчетов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Возврат Метаданные.ПланЫВидовРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Возврат Метаданные.РегистрыСведений[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Возврат Метаданные.РегистрыНакопления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Возврат Метаданные.РегистрыБухгалтерии[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Возврат Метаданные.РегистрыРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Возврат Метаданные.БизнесПроцессы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Возврат Метаданные.Задачи[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Возврат Метаданные.Константы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Возврат Метаданные.Последовательности[ИмяОМ];
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неизвестный тип объекта метаданных (%1)'"), КлассОМ);
	КонецЕсли;
	
КонецФункции

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// 		Объект                      - ДокументОбъект, СправочникОбъект - Проверяемый объект.
// 		МассивПроверяемыхРеквизитов - Массив - массив проверяемых реквизитов.
//
// Возвращаемое значение:
// 		Булево - Истина, если значение хотя бы одного реквизита не заполнено, иначе Ложь.
//
Функция ПроверитьЗаполнениеРеквизитовОбъекта(Объект, МассивПроверяемыхРеквизитов) Экспорт
	
	Перем ПроверяемыеРеквизитыТЧ;
	Отказ = Ложь;
	
	// Получение метаданных объекта
	МетаданныеОбъекта = Объект.Ссылка.Метаданные();
	
	// Создание структуры стандартных реквизитов
	СтандартныеРеквизиты = Новый Структура;
	Для Каждого Реквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		СтандартныеРеквизиты.Вставить(Реквизит.Имя, ?(ЗначениеЗаполнено(Реквизит.Синоним), Реквизит.Синоним, Реквизит.Имя));
	КонецЦикла;
	
	// Создание структуры для хранения имен табличных частей и проверяемых реквизитов в них.
	// 		Ключ -  Имя табличной части
	// 		Значение - Массив - Массив строк, реквизитов этой табличной части для проверки.
	ТабличныеЧасти = Новый Структура;
	
	// Создание шаблонов сообщений об ошибках не заполненных реквизитов и реквизитов табличных частей.
	ШаблонОшибкиРеквизита = НСтр("ru='Поле ""%ИмяРеквизита%"" не заполнено'");
	ШаблонОшибкиТЧ = НСтр("ru='Не введено ни одной строки в список ""%ИмяРеквизита%""'");
	ШаблонОшибкиРеквизитаТЧ = НСтр("ru='Не заполнена колонка ""%ИмяРеквизита%"" в строке %НомерСтроки% списка ""%ИмяТабличнойЧасти%""'");
	
	// Проверка реквизитов объекта и заполнение структуры по реквизитам табличных частей.
	Для Каждого Реквизит Из МассивПроверяемыхРеквизитов Цикл
		
		ПозицияТочки = СтрНайти(Реквизит,".");
		
		Если ПозицияТочки > 0 Тогда // В случае если указан реквизит табличной части
			
			ДлинаСтроки       = СтрДлина(Реквизит);
			ИмяТабличнойЧасти = Лев(Реквизит, ПозицияТочки-1);
			ИмяРеквизита      = Прав(Реквизит, ДлинаСтроки - ПозицияТочки);
			
			// Сохранение проверяемого реквизита табличной части в структуру
			Если НЕ ТабличныеЧасти.Свойство(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ) Тогда
				ПроверяемыеРеквизитыТЧ = Новый Массив;
				ТабличныеЧасти.Вставить(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ);
			КонецЕсли;
			ПроверяемыеРеквизитыТЧ.Добавить(ИмяРеквизита);
			
		Иначе // В случае если указан реквизит объекта
			
			Если Не ЗначениеЗаполнено(Объект[Реквизит]) Тогда
				
				Если МетаданныеОбъекта.Реквизиты.Найти(Реквизит) <> Неопределено Тогда // Если указано имя реквизита
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						МетаданныеОбъекта.Реквизиты[Реквизит].Синоним);
				ИначеЕсли СтандартныеРеквизиты.Свойство(Реквизит) Тогда // Если указано имя стандартного реквизита
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						СтандартныеРеквизиты[Реквизит]);
				Иначе // Если указано имя табличной части
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиТЧ, "%ИмяРеквизита%",
						МетаданныеОбъекта.ТабличныеЧасти[Реквизит].Синоним);
				КонецЕсли;
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					ТекстОшибки,
					Объект,
					Реквизит,
					,
					Отказ);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверка реквизитов в табличных частях
	Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
		
		ИмяТабличнойЧасти = ТабличнаяЧасть.Ключ;
		ТабличнаяЧастьОбъекта = Объект[ТабличнаяЧасть.Ключ];
		МассивРеквизитов = ТабличнаяЧасть.Значение;
		
		// Цикл по всем строкам табличной части.
		Для НомерСтроки=0 По ТабличнаяЧастьОбъекта.Количество()-1 Цикл
			
			// Цикл по всем проверяемым реквизитам для текущей табличной части.
			Для НомерРеквизита=0 По МассивРеквизитов.Количество()-1 Цикл
				
				ИмяРеквизита = МассивРеквизитов[НомерРеквизита];
				
				Если Не ЗначениеЗаполнено(ТабличнаяЧастьОбъекта[НомерСтроки][ИмяРеквизита]) Тогда
					
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизитаТЧ, "%ИмяРеквизита%", МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты[ИмяРеквизита].Синоним);
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%НомерСтроки%", Формат(НомерСтроки+1, "ЧГ=0"));
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ИмяТабличнойЧасти%", МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Синоним);
					
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
						ТекстОшибки,
						Объект,
						ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТабличнойЧасти, НомерСтроки+1, ИмяРеквизита),
						,
						Отказ);
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	МассивПроверяемыхРеквизитов.Очистить();
	
	Возврат Отказ;
	
КонецФункции // ПроверитьЗаполнениеРеквизитовОбъекта()

// Осуществляет проверку соответствия организации документа и хозяйственной операции.
//
Процедура ПроверитьПравильностьУказанияХозяйственнойОперации(ДокументОбъект, Отказ) Экспорт
	
	Если ДокументОбъект.Организация = Справочники.Организации.УправленческаяОрганизация
	   И (ДокументОбъект.ХозяйственнаяОперация = Перечисления.ХозяйственныеОперации.РеализацияКлиентуРеглУчет
	 ИЛИ ДокументОбъект.ХозяйственнаяОперация = Перечисления.ХозяйственныеОперации.ЗакупкаУПоставщикаРеглУчет) Тогда
	 
		Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В документе нельзя указывать операцию %1 и управленческую организацию'"),
			ДокументОбъект.ХозяйственнаяОперация);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
			Текст,
			ДокументОбъект,
			"ХозяйственнаяОперация",
			,
			Отказ);
	 
	КонецЕсли;
	
КонецПроцедуры // ПроверитьПравильностьУказанияХозяйственнойОперации()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// Документ           - ДокументСсылка - Документ, на основании которого осуществляется ввод
// Статус             - Статус документ, на основании которого осуществляется ввод
// ЕстьОшибкиПроведен - Булево - Если Истина - документ, на основании которого осуществляется ввод, не проведен
// ЕстьОшибкиСтатус   - Булево - Если Истина - документ, на основании которого осуществляется ввод, имеет некорректный статус
// СоглашениеДоступноВнешнемуПользователю Булево - Если Истина - документ на основании которого осуществляется ввод
// имеет соглашение доступное внешнему пользователю.
//
Процедура ПроверитьВозможностьВводаНаОсновании(Документ,
	                                           Статус = Неопределено,
	                                           ЕстьОшибкиПроведен = Ложь,
	                                           ЕстьОшибкиСтатус = Ложь,
	                                           МассивДопустимыхСтатусов = Неопределено,
	                                           СоглашениеДоступноВнешнемуПользователю = Неопределено) Экспорт
	
	Если ЕстьОшибкиПроведен Тогда
		
		ТекстОшибки = НСтр("ru='Документ %Документ% не проведен. Ввод на основании непроведенного документа запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ЕстьОшибкиСтатус Тогда
		
		Если Не ЗначениеЗаполнено(МассивДопустимыхСтатусов) Тогда
			ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании запрещен.'");
		ИначеЕсли ТипЗнч(МассивДопустимыхСтатусов) = Тип("Массив") Тогда
			
			Если МассивДопустимыхСтатусов.Количество() = 1 Тогда
				ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании разрешен только в статусе ""%СтрокаДопустимыхСтатусов%"".'");
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "%СтрокаДопустимыхСтатусов%", МассивДопустимыхСтатусов[0]);
			Иначе
				ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании разрешен только в статусах ""%СтрокаДопустимыхСтатусов%"".'");
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "%СтрокаДопустимыхСтатусов%", СтрСоединить(МассивДопустимыхСтатусов, """, """));
			КонецЕсли;
			
		КонецЕсли;
		
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Статус%",   Статус);
	
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ОбщегоНазначенияУТКлиентСервер.АвторизованВнешнийПользователь() И НЕ СоглашениеДоступноВнешнемуПользователю = Истина Тогда
		
		ТекстОшибки = НСтр("ru='Соглашение документа %Документ% недоступно для работы при самообслуживании. Ввод на основании запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
		
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОсновании()

// Осуществляет проверку возможности ввода документа на основании распоряжения по хозяйственной операции.
//
// Параметры:
//	ДокументОснование	- ДокументСсылка				- документ, на основании которого осуществляется ввод.
//	ИмяДокумента		- Строка					- имя документа, для которого определяются допустимые операции.
//	ХозяйственнаяОперация	- ПеречислениеСсылка.ХозяйственныеОперации	- хозяйственная операция документа, 
//											на основании которого осуществляется ввод.
//	ПредставлениеДокумента	- Строка, Неопределено				- представление документа в информационной базе.
//
Процедура ПроверитьВозможностьВводаНаОснованииПоОперации(ДокументОснование,
							ИмяДокумента,
							ХозяйственнаяОперация,
							ПредставлениеДокумента = Неопределено) Экспорт
	
	ОперацииДокумента = ДопустимыеХозяйственныеОперацииДокумента(ИмяДокумента);
	
	Если ОперацииДокумента.Найти(ХозяйственнаяОперация) = Неопределено Тогда
		СинонимДокумента = ?(ЗначениеЗаполнено(ПредставлениеДокумента),
					ПредставлениеДокумента,
					Метаданные.Документы[ИмяДокумента].Синоним);
		
		ТекстОшибки = НСтр("ru='Невозможно оформить документ ""%1"" на основании распоряжения %2 с операцией ""%3"".'");
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстОшибки,
											СинонимДокумента,
											ДокументОснование,
											ХозяйственнаяОперация);
		
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	
КонецПроцедуры

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// Документ                            - ДокументСсылка - Документ, на основании которого осуществляется ввод
// ЕстьОшибкиПроведен                  - Булево - Если Истина - документ, на основании которого осуществляется ввод, не проведен
// ЕстьОшибкиВернутьМногооборотнуюТару - Булево - Если Истина - по документу, на основании которого осуществляется ввод,
//                                                тара не возвратная.
//
Процедура ПроверитьВозможностьВводаНаОснованииВыкупаТары(Документ, ЕстьОшибкиПроведен, ЕстьОшибкиВернутьМногооборотнуюТару) Экспорт
	
	Если ЕстьОшибкиПроведен Тогда
		
		ТекстОшибки = НСтр("ru='Документ %Документ% не проведен. Ввод на основании непроведенного документа запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ЕстьОшибкиВернутьМногооборотнуюТару Тогда
		
		ТекстОшибки = НСтр("ru='В документе %Документ% не стоит признак возврата многооборотной тары. Ввод на основании запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// ЕстьОшибкиТиповое  - Булево - Если Истина - соглашение, на основании которого осуществляется ввод - типовое
// ЭтоАгентскиеУслуги  - Булево - Если Истина - соглашение, на основании которого осуществляется ввод - соглашение по
//                                оказанию агентских услуг.
//
Процедура ПроверитьВозможностьВводаНаОснованииСоглашения(ЕстьОшибкиТиповое = Ложь, ЭтоАгентскиеУслуги = Ложь) Экспорт
	
	Если ЕстьОшибкиТиповое Тогда
		
		ТекстОшибки = НСтр("ru='Ввод на основании типового соглашения с клиентом запрещен.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
	Если ЭтоАгентскиеУслуги Тогда
		
		ТекстОшибки = НСтр("ru='Ввод на основании типового соглашения по оказанию агентских услуг запрещен.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСоглашения()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// Партнер - СправочникСсылка.Партнеры - Партнер из сделки по продаже.
//
Процедура ПроверитьВозможностьВводаНаОснованииСделкиПоПродаже(Партнер) Экспорт
	
	Если Не ЗначениеЗаполнено(Партнер) Тогда
		
		ТекстОшибки = НСтр("ru='В сделке не указан клиент, ввод на основании запрещен.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСделкиПоПродаже()

// Устанавливает или сбрасывает флаг Согласован у справочника.
// Вызывается из процедуры ПередЗаписью документа.
//
// Параметры:
// ДокументОбъект     - СправочникОбъект - Справочник, в котором необходимо изменить флаг Согласован
// СтатусНеСогласован - Статус документа, в котором флаг Согласован должен быть сброшен.
//
Процедура ИзменитьПризнакСогласованностиСправочника(СправочникОбъект, Знач СтатусНеСогласован = Неопределено) Экспорт
	
	// Справочник не имеет статуса
	Если СтатусНеСогласован = Неопределено Тогда
		
		Если Не СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Истина;
		КонецЕсли;
		
	// Справочник имеет статус, в котором проведенный справочник не согласован
	Иначе
		
		Если СправочникОбъект.Статус = СтатусНеСогласован И СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Ложь;
		ИначеЕсли СправочникОбъект.Статус <> СтатусНеСогласован И Не СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ИзменитьПризнакСогласованностиСправочника()

// Устанавливает или сбрасывает флаг Согласован у документа.
// Вызывается из процедуры ПередЗаписью документа.
//
// Параметры:
// ДокументОбъект     - ДокументОбъект - Документ, в котором необходимо изменить флаг Согласован
// РежимЗаписи        - Режим записи документа
// СтатусНеСогласован - Статус документа, в котором флаг Согласован должен быть сброшен.
//
Процедура ИзменитьПризнакСогласованностиДокумента(ДокументОбъект, Знач РежимЗаписи, Знач СтатусНеСогласован = Неопределено) Экспорт
	
	Если РежимЗаписи = РежимЗаписиДокумента.Запись
	 ИЛИ РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения Тогда
		
		Если ДокументОбъект.Согласован Тогда
			ДокументОбъект.Согласован = Ложь;
		КонецЕсли;
		
	ИначеЕсли РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда
		
		// Документ не имеет статуса
		Если СтатусНеСогласован = Неопределено Тогда
		
			Если Не ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Истина;
			КонецЕсли;
			
		// Документ имеет статус из массива, в которых проведенный документ не согласован
		ИначеЕсли ТипЗнч(СтатусНеСогласован) = Тип("Массив") Тогда
			
			Если ДокументОбъект.Согласован Тогда
				
				Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					
					Если ДокументОбъект.Статус = ТекСтатус Тогда
						
						ДокументОбъект.Согласован = Ложь;
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
			Иначе
				
				ДокументСогласован = Истина;
				
				Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					
					Если ДокументОбъект.Статус = ТекСтатус Тогда
						ДокументСогласован = Ложь;
					КонецЕсли;
					
				КонецЦикла;
				
				Если ДокументСогласован Тогда
					ДокументОбъект.Согласован = Истина;
				КонецЕсли;
				
			КонецЕсли;
			
		// Документ имеет статус, в котором проведенный документ не согласован
		Иначе
			
			Если ДокументОбъект.Статус = СтатусНеСогласован И ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Ложь;
			ИначеЕсли ДокументОбъект.Статус <> СтатусНеСогласован И Не ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Истина;
			КонецЕсли;
			
		КонецЕсли;

	КонецЕсли;
	
КонецПроцедуры // ИзменитьПризнакСогласованностиДокумента()

// Настраивает подключаемое оборудование в форме,
// устанавливает флаг ИспользоватьПодключаемоеОборудование в форме
// Параметры:
//   Форма - Форма, в которой необходимо настроить подключаемое оборудование.
//
Процедура НастроитьПодключаемоеОборудование(Форма, ПрефиксыЭлементовФормы = "Товары") Экспорт
	
	ТипыПодключенногоОборудования = ПодключаемоеОборудованиеУТПовтИсп.ТипыПодключенногоОборудования();
	
	Форма.ИспользоватьПодключаемоеОборудование = ИспользоватьПодключаемоеОборудование(ТипыПодключенногоОборудования);
	
	ЕстьТСД  =
		ТипыПодключенногоОборудования <> Неопределено
		И ТипыПодключенногоОборудования.Найти(Перечисления.ТипыПодключаемогоОборудования.ТерминалСбораДанных) <> Неопределено;
	ЕстьВесы =
		ТипыПодключенногоОборудования <> Неопределено
		И ТипыПодключенногоОборудования.Найти(Перечисления.ТипыПодключаемогоОборудования.ЭлектронныеВесы) <> Неопределено;
		
	Если ЗначениеЗаполнено(ПрефиксыЭлементовФормы) Тогда
		МассивПрефиксыЭлементовФормы = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПрефиксыЭлементовФормы, ",");
	Иначе
		МассивПрефиксыЭлементовФормы = Новый Массив;
		МассивПрефиксыЭлементовФормы.Добавить(ПрефиксыЭлементовФормы);
	КонецЕсли;
	
	Для Каждого Префикс Из МассивПрефиксыЭлементовФормы Цикл
		
		ОбщегоНазначенияУТКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы,
			Префикс + "ЗагрузитьДанныеИзТСД",
			"Видимость",
			Форма.ИспользоватьПодключаемоеОборудование И ЕстьТСД);
		
		ОбщегоНазначенияУТКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы,
			Префикс + "ВыгрузитьДанныеВТСД",
			"Видимость",
			Форма.ИспользоватьПодключаемоеОборудование И ЕстьТСД);
		
		ОбщегоНазначенияУТКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы,
			Префикс + "ПолучитьВес",
			"Видимость",
			Форма.ИспользоватьПодключаемоеОборудование И ЕстьВесы);
		
	КонецЦикла;
	
КонецПроцедуры

// Проверяет, что включена ф.о "Использовать подключаемое оборудование",
// настроено ли оборудование и авторизовался пользователь,
// а не внешний пользователь.
Функция ИспользоватьПодключаемоеОборудование(ТипыПодключенногоОборудования = Неопределено) Экспорт
	
	ИспользоватьПодключаемоеОборудование = ПолучитьФункциональнуюОпцию("ИспользоватьПодключаемоеОборудование");
	ПользовательАвторизовался 			 = ТипЗнч(Пользователи.АвторизованныйПользователь()) = Тип("СправочникСсылка.Пользователи");
	
	Если ТипыПодключенногоОборудования = Неопределено Тогда
		ТипыПодключенногоОборудования = ПодключаемоеОборудованиеУТПовтИсп.ТипыПодключенногоОборудования();
	КонецЕсли;
	
	Возврат
		ИспользоватьПодключаемоеОборудование
		И ПользовательАвторизовался
		И ТипыПодключенногоОборудования <> Неопределено
		И ТипыПодключенногоОборудования.Количество() > 0;
												 
КонецФункции

// Возвращает список пользователей, имеющих роли, указанные в качестве параметра
//
// Параметры:
// 		МассивРолей - Массив - массив с именами ролей
// 		ПредставлениеТекущегоПользователя - Строка - представление текущего пользователя.
// 
//	Возвращаемое значение:
//		СписокЗначений с элементами СправочникСсылка.Пользователи.
//
Функция ПользователиСДоступнымиРолями(МассивРолей, ПредставлениеТекущегоПользователя = Неопределено) Экспорт
	
	СписокПользователей = Новый СписокЗначений;
	Если ПредставлениеТекущегоПользователя = Неопределено Тогда
		ПредставлениеТекущегоПользователя = НСтр("ru='<Мои документы>'");
	КонецЕсли;
	
	// Запрос получения списка всех пользователей. Выполняется в привилегированном режиме.
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПрофилиГруппДоступаРоли.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ ПрофилиГруппДоступа
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа.Роли КАК ПрофилиГруппДоступаРоли
	|ГДЕ
	|	ПрофилиГруппДоступаРоли.Роль.Имя В(&МассивРолей)
	|
	|СГРУППИРОВАТЬ ПО
	|	ПрофилиГруппДоступаРоли.Ссылка
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Ссылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ЕСТЬNULL(ГруппыПользователейСостав.Пользователь, ГруппыДоступаПользователи.Пользователь) КАК Пользователь
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ГруппыПользователей.Состав КАК ГруппыПользователейСостав
	|		ПО ГруппыДоступаПользователи.Пользователь = ГруппыПользователейСостав.Ссылка
	|ГДЕ
	|	ГруппыДоступаПользователи.Ссылка.Профиль В
	|			(ВЫБРАТЬ
	|				ПрофилиГруппДоступа.Ссылка
	|			ИЗ
	|				ПрофилиГруппДоступа КАК ПрофилиГруппДоступа)
	|
	|СГРУППИРОВАТЬ ПО
	|	ЕСТЬNULL(ГруппыПользователейСостав.Пользователь, ГруппыДоступаПользователи.Пользователь)";
	
	Запрос.УстановитьПараметр("МассивРолей", МассивРолей);
	
	МассивВсехПользователей = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Пользователь");
	
	УстановитьПривилегированныйРежим(Ложь);
	
	// Запрос получения списка "разрешенных" пользователей
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Пользователи.Ссылка КАК Пользователь
	|ИЗ
	|	Справочник.Пользователи КАК Пользователи
	|ГДЕ
	|	Пользователи.Ссылка В(&МассивПользователей)
	|	И Пользователи.ПометкаУдаления = ЛОЖЬ
	|	И Пользователи.Недействителен = ЛОЖЬ
	|
	|УПОРЯДОЧИТЬ ПО
	|	Пользователи.Наименование";
	Запрос.УстановитьПараметр("МассивПользователей", МассивВсехПользователей);
	
	ТекущийПользователь = Пользователи.ТекущийПользователь();
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ТекущийПользователь = Выборка.Пользователь Тогда
			СписокПользователей.Вставить(0, Выборка.Пользователь, ПредставлениеТекущегоПользователя);
		Иначе
			СписокПользователей.Добавить(Выборка.Пользователь);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СписокПользователей;
	
КонецФункции

// Возвращает список пользователей, имеющих право на изменение объекта метаданных
//
// Параметры:
// 		ОбъектМетаданных - Метаданные - объект метаданных, на которые проверяются права доступа
// 		ПредставлениеТекущегоПользователя - Строка - представление текущего пользователя.
// 
//	Возвращаемое значение:
//		СписокЗначений с элементами СправочникСсылка.Пользователи.
//
Функция ПолучитьСписокПользователейСПравомДобавления(ОбъектМетаданных, ПредставлениеТекущегоПользователя = Неопределено) Экспорт
	
	ИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	МассивРолей = ПраваПользователяПовтИсп.ИменаРолейСПравомДобавления(ИмяОбъектаМетаданных);
	
	Если НЕ ЗначениеЗаполнено(МассивРолей) Тогда
		Возврат Новый СписокЗначений;
	КонецЕсли;
	
	Возврат ПользователиСДоступнымиРолями(МассивРолей, ПредставлениеТекущегоПользователя);;
	
КонецФункции

// Возвращает массив с уникальными значениями из колонки таблицы
//
// Параметры:
//  Таблица		 - ТаблицаЗначений, ТабличнаяЧасть, ДанныеФормыСтруктура 
//  ИмяКолонки	 - Строка 
// 
// Возвращаемое значение:
// 	Массив 
//
Функция УникальныеЗначенияИзКолонкиТаблицы(Таблица, ИмяКолонки) Экспорт
	
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		ОбрабатываемаяТаблица = Таблица.Скопировать(,ИмяКолонки);
	Иначе
		ОбрабатываемаяТаблица = Таблица.Выгрузить(,ИмяКолонки);
	КонецЕсли;
		
	ОбрабатываемаяТаблица.Свернуть(ИмяКолонки);
	Возврат ОбрабатываемаяТаблица.ВыгрузитьКолонку(0);
	
КонецФункции // СвернутьТаблицуЗначенийПоРеквизиту()

// Удаляет указанные строки из таблицы значений.
// 
// Параметры:
//	Таблица - ТаблицаЗначений - обрабатываемая таблица
//	Строки  - Массив(элементы - СтрокаТаблицыЗначений) - массив удаляемых строк.
//
Процедура УдалитьСтрокиТаблицыЗначений(Таблица, Строки) Экспорт
	
	Для Каждого СтрокаТаблицы Из Строки Цикл
		Таблица.Удалить(СтрокаТаблицы);
	КонецЦикла;
	
КонецПроцедуры

// Удаляет строки из таблицы значений с учетом переданного отбора.
// 
// Параметры:
//	Таблица 			  - ТаблицаЗначений - обрабатываемая таблица
//	СтруктураПоиска 	  - Структура - структура поиска строк, см. описание метода НайтиСтроки() таблицы значений
//	УдалятьПопавшиеВОтбор - Булево - если указать Ложь, то будут удалены все строки, не входящие в отбор.
//
Процедура НайтиИУдалитьСтрокиТаблицыЗначений(Таблица, СтруктураПоиска, УдалятьПопавшиеВОтбор = Истина) Экспорт
	
	Строки = Таблица.НайтиСтроки(СтруктураПоиска);
	
	Если НЕ УдалятьПопавшиеВОтбор Тогда
		
		Если Строки.Количество() = Таблица.Количество() Тогда
			Возврат; // нечего удалять
		ИначеЕсли Строки.Количество() = 0 Тогда
			Таблица.Очистить();
		Иначе
			
			УдаляемыеСтроки = Новый Массив;
			
			Для Каждого СтрокаТаблицы Из Таблица Цикл
				
				Если Строки.Найти(СтрокаТаблицы) = Неопределено Тогда
					УдаляемыеСтроки.Добавить(СтрокаТаблицы); // строка не входит в переданный отбор
				КонецЕсли;
				
			КонецЦикла;
			
			УдалитьСтрокиТаблицыЗначений(Таблица, УдаляемыеСтроки);
			
		КонецЕсли;
		
	Иначе
		
		Если Строки.Количество() = 0 Тогда
			Возврат; // нечего удалять
		ИначеЕсли Строки.Количество() = Таблица.Количество() Тогда
			Таблица.Очистить();
		Иначе
			УдалитьСтрокиТаблицыЗначений(Таблица, Строки);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция проверяет наличие согласующего по указанной роли в регистре сведений Исполнители задач.
//
// Параметры:
//	ПроверяемаяРоль - Ссылка на роль исполнителя - Элемент справочника РолиИсполнителей.
//
Функция ПроверитьСогласующегоБизнесПроцесс(ПроверяемаяРоль) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ИсполнителиЗадач.Исполнитель КАК ЕстьИсполнитель
		|ИЗ
		|	РегистрСведений.ИсполнителиЗадач КАК ИсполнителиЗадач
		|ГДЕ
		|	ИсполнителиЗадач.РольИсполнителя =&РольИсполнителя";

	Запрос.УстановитьПараметр("РольИсполнителя", ПроверяемаяРоль);
	Результат = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = Результат.Выбрать();

	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции // ПроверитьСогласующегоБизнесПроцесс()

// Функция раскладывает переданный массив ссылок в соответствие по типам этих ссылок.
//
//	Параметры:
//		МассивСсылок - Массив - массив ссылок на объекты информационной базы
//  Возвращаемое значение:
//		Соответствие:
//			Ключ - полное имя типа ссылки
//	        Значение - массив ссылок этого типа.
//
Функция СоответствиеМассивовПоТипамОбъектов(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Каждого Объект Из МассивСсылок Цикл
		
		ТипОбъекта = Объект.Метаданные().ПолноеИмя();
		ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		
		Если ТекущийТипОбъекта = Неопределено Тогда
			СоответствиеТипов.Вставить(ТипОбъекта, Новый Массив);
			ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		КонецЕсли;
		ТекущийТипОбъекта.Добавить(Объект);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции

// Возвращает разницу между двумя датами (в днях)
//
// Параметры
//  ДатаНачала 		- Дата - начальная дата периода
//  ДатаОкончания	- Дата - конечная дата периода.
//
// Возвращаемое значение:
//   Число	 - количество дней между двумя датами.
//
Функция РазностьДат(ДатаНачала, ДатаОкончания, Периодичность) Экспорт
	
	СекундВМинуте = 60;
	МинутВЧасе = 60;
	ЧасовВДне = 24;
	
	Если Периодичность = Перечисления.Периодичность.Год Тогда
		Возврат Год(ДатаОкончания) - Год(ДатаНачала);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Полугодие Тогда
		Возврат ?(Месяц(ДатаОкончания)>6, 2, 1) - ?(Месяц(ДатаНачала)>6, 2, 1) + 2*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		Возврат Цел(Месяц(НачалоКвартала(ДатаОкончания))/3) - Цел(Месяц(НачалоКвартала(ДатаНачала))/3) + 4*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		Возврат Месяц(ДатаОкончания) - Месяц(ДатаНачала) + 12*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		Возврат Цел((ДатаОкончания - ДатаНачала)/(10 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		Возврат Цел((НачалоНедели(ДатаОкончания) - НачалоНедели(ДатаНачала))/(7 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		Возврат (ДатаОкончания - ДатаНачала)/(СекундВМинуте*МинутВЧасе*ЧасовВДне);
		
	КонецЕсли;
	
КонецФункции

// Проверяет использование объекта
//
// Параметры:
//  Параметры		- Структура - содержит объект использование которого нужно проверить
//  АдресХранилища	- Строка - адрес хранилища в которое будут помещен результат проверки.
//
Процедура ПроверитьИспользованиеОбъекта(Параметры, АдресХранилища) Экспорт
	
	ЕстьСсылки = ОбщегоНазначенияВызовСервера.ЕстьСсылкиНаОбъект(Параметры.Объект);
	
	ПоместитьВоВременноеХранилище(ЕстьСсылки, АдресХранилища);
	
КонецПроцедуры

// Возвращает ключ коллекции, имеющий указанное значение.
//
Функция КлючКоллекцииПоЗначению(Коллекция, Значение) Экспорт
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		Если КлючИЗначение.Значение = Значение Тогда
			Возврат КлючИЗначение.Ключ;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает коллекцию, в которой ключи и значения поменяны местами.
//
Функция ПоменятьКлючИЗначениеКоллекции(Коллекция) Экспорт
	
	Если ТипЗнч(Коллекция) = Тип("Структура") ИЛИ ТипЗнч(Коллекция) = Тип("ФиксированнаяСтруктура") Тогда
		НоваяКоллекция = Новый Структура;
	ИначеЕсли ТипЗнч(Коллекция) = Тип("Соответствие") ИЛИ ТипЗнч(Коллекция) = Тип("ФиксированноеСоответствие") Тогда
		НоваяКоллекция = Новый Соответствие;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		НоваяКоллекция.Вставить(КлючИЗначение.Значение, КлючИЗначение.Ключ);
	КонецЦикла;
	
	Если ТипЗнч(Коллекция) = Тип("ФиксированнаяСтруктура") Тогда
		НоваяКоллекция = Новый ФиксированнаяСтруктура(НоваяКоллекция);
	ИначеЕсли ТипЗнч(Коллекция) = Тип("ФиксированноеСоответствие") Тогда
		НоваяКоллекция = Новый ФиксированноеСоответствие(НоваяКоллекция);
	КонецЕсли;
	
	Возврат НоваяКоллекция;
	
КонецФункции

// Возвращает количество документов прописью.
//
// Параметры:
//  КоличествоДокументов - Число - Количество документов.
//
// Возвращаемое значение:
//  Строка - Количество документов прописью.
//
Функция ЧислоДокументовПрописью(КоличествоДокументов) Экспорт
	
	КоличествоПрописью = ЧислоПрописью(
		КоличествоДокументов,
		НСтр("ru='SN = Истина; FN = Ложь; FS = Ложь;'"),
		НСтр("ru = 'документ,документа,документов,м,,,,,0'"));
	
	Поз = СтрНайти(КоличествоПрописью, НСтр("ru='документ'"));
	Если Поз <> 0 Тогда
		КоличествоПрописью = Сред(КоличествоПрописью, Поз);
	КонецЕсли;
	
	КоличествоПрописью = Строка(КоличествоДокументов) + " " + НРег(КоличествоПрописью);
	
	Возврат КоличествоПрописью;
	
КонецФункции

// Возвращает описание типов по переданному типу
// 
// Параметры:
//	Тип - Тип - тип значения
//
// Возвращаемое значение:
//	ОписаниеТипов - созданное на основании переданного типа описание типов.
//
Функция ОписаниеТиповПоТипу(Тип) Экспорт
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип);
	
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
	
	Возврат ОписаниеТипов;
КонецФункции

// Возвращает таблицу значений на основании массива структур
// 
// Параметры:
//	МассивСтруктур - МассивСтруктур - массив структур, которые будут преобразованы в таблиц значений.
//										Свойства структуры первого элемента массива определяют состав колонок результирующей таблицы.
//
// Возвращаемое значение:
//	ТаблицаЗначений - таблица значений, созданная из массива структур.
// 
Функция МассивВТаблицуЗначений(МассивСтруктур) Экспорт
	Таблица = Новый ТаблицаЗначений;
	// Создадим колонки по первой структуре массива
	Если ТипЗнч(МассивСтруктур) = Тип("Массив")
		И МассивСтруктур.Количество() <> 0 Тогда
		ПерваяСтруктура = МассивСтруктур[0];
		Для Каждого Свойство Из ПерваяСтруктура Цикл 
			Таблица.Колонки.Добавить(Свойство.Ключ, ОписаниеТиповПоТипу(ТипЗнч(Свойство.Значение)));
		КонецЦикла;
		
		Для Каждого Структура Из МассивСтруктур Цикл 
			НоваяСтрока = Таблица.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Структура);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Таблица;
КонецФункции

// Возвращает метаданные объекта по полному имени объекта метаданных
//
// Параметры:
//  ПолноеИмя - Строка - Полный путь к метаданным реквизита как в дереве метаданных.
//                       Пример: "Документы.ПоступлениеБезналичныхДенежныхСредств.ТабличныеЧасти.РасшифровкаПлатежа.Реквизиты.Заказ"
//                               "РегистрыНакопления.ДвиженияКонтрагентДоходыРасходы.Измерения.ОбъектРасчетов".
//
// Возвращаемое значение:
//  ОбъектМетаданных,КоллекцияОбъектовМетаданных.
//
Функция МетаданныеПоИмени(МетаданныеСтрокой) Экспорт
	
	Возврат СвойствоМетаданных(Метаданные, СтрРазделить(МетаданныеСтрокой, "."));
	
КонецФункции

// Возвращает Истина, если включен режим отладки.
Функция РежимОтладки() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	РежимОтладки = ОбщегоНазначенияКлиентСервер.РежимОтладки()
		ИЛИ Константы.РежимОтладки.Получить();
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат РежимОтладки;
	
КонецФункции

// Формирует список сообщений об ошибках установки пометки удаления документа.
//
// Параметры:
//  СсылкиНаУдаление - Массив Из ДокументСсылка - Список созданных документов.
// 
// Возвращаемое значение:
//   Структура - см. ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю
//
Функция УстановитьПометкуУдаленияДокументов(Ссылки) Экспорт
	
	Перем СписокОшибок;
	ТекстНеЗаблокирован = НСтр("ru = '%1 - не удалось пометить на удаление документ, возможно документ редактируется другим пользователем.'");
	
	Для Каждого Ссылка Из Ссылки Цикл
		ДокументОбъект = Ссылка.ПолучитьОбъект();
		Если ДокументОбъект = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ДокументОбъект.ПометкаУдаления Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			ДокументОбъект.Заблокировать();
		Исключение
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстНеЗаблокирован, СокрЛП(Ссылка)); 
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
			Продолжить;
			
		КонецПопытки;
		
		ДокументОбъект.УстановитьПометкуУдаления(Истина);
	КонецЦикла;
	Возврат СписокОшибок;
	
КонецФункции

// Перед попыткой непосредственного удаления документа устанавливает
// пометку на удаление, что позволяет отработать предусмотренным
// механизмам в документе.
// Формирует список сообщений об успешном удалении документов, либо
// об ошибках не позволяющих удалить документы.
//
// Параметры:
//  СсылкиНаУдаление - Массив - Список созданных документов.
// 
// Возвращаемое значение:
//   Структура - Содержит список сообщений. Состав ключей определяется в функции ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю.
//
Функция УдалитьДокументы(СсылкиНаУдаление) Экспорт
	
	Перем СписокОшибок;
	
	Если СсылкиНаУдаление.Количество() = 0 Тогда
		Возврат СписокОшибок;
	КонецЕсли;
	
	ТекстИмеютсяСсылки  = НСтр("ru = 'Имеются ссылки на %1 - %2.'");
	ТекстПомечен        = НСтр("ru = '%1 - помечен на удаление.'");
	ТекстУдален         = НСтр("ru = '%1 - удален.'");
	ТекстНеЗаблокирован = НСтр("ru = '%1 - не удалось пометить на удаление документ, возможно документ редактируется другим пользователем.'");
	
	МассивИменОбъектовМетаданных = Новый Массив();
	Для Каждого ДокументКУдалению Из СсылкиНаУдаление Цикл
		ИмяОбъектаМетаданных = ДокументКУдалению.Метаданные().ПолноеИмя();
		Если МассивИменОбъектовМетаданных.Найти(ИмяОбъектаМетаданных) = Неопределено Тогда
			МассивИменОбъектовМетаданных.Добавить(ИмяОбъектаМетаданных);
		КонецЕсли;
	КонецЦикла;
	ИменаОбъектовМетаданных = СтрСоединить(МассивИменОбъектовМетаданных, ",");
	
	Регистры = ОбщегоНазначенияУТПовтИсп.РегистрыСведенийПоМетаданнымИзмерений(ИменаОбъектовМетаданных, Истина);
	
	НазначенияЗаказов = НазначенияЗаказов(СсылкиНаУдаление);
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(СсылкиНаУдаление, НазначенияЗаказов);
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТабСсылок = НайтиПоСсылкам(СсылкиНаУдаление);
	
	ВсегоСтрок = ТабСсылок.Количество();
	Для Счетчик = 1 По ВсегоСтрок Цикл
		Ссылка = ТабСсылок[ВсегоСтрок - Счетчик];
		
		Если Ссылка[0] = Ссылка[1] Или ЭтоЗаписьВедомогоРегистраСведений(Ссылка[1], Регистры) Тогда
			
			ТабСсылок.Удалить(Ссылка);
			
		КонецЕсли;
		
	КонецЦикла;
	
	ПомечатьНаУдаление = Новый Массив();
	
	ВсегоСтрок = ТабСсылок.Количество();
	Для Счетчик = 1 По ВсегоСтрок Цикл
		Ссылка = ТабСсылок[ВсегоСтрок - Счетчик];
		
		Индекс = СсылкиНаУдаление.Найти(Ссылка[1]);
		Если Индекс = Неопределено Тогда
			
			Если ПомечатьНаУдаление.Найти(Ссылка[0]) = Неопределено Тогда
				
				ПомечатьНаУдаление.Добавить(Ссылка[0]);
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИмеютсяСсылки, СокрЛП(Ссылка[0]), СокрЛП(Ссылка[1])); 
				ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
				
			КонецЕсли;
			
			ТабСсылок.Удалить(Ссылка);
			
		КонецЕсли;
		
	КонецЦикла;
	
	ОбработкаЗавершена = Ложь;
	Пока Не ОбработкаЗавершена Цикл
		
		ОбработкаЗавершена = Истина;
		
		ВсегоСтрок = ТабСсылок.Количество();
		Для Счетчик = 1 По ВсегоСтрок Цикл
			Ссылка = ТабСсылок[ВсегоСтрок - Счетчик];
			
			Если ПомечатьНаУдаление.Найти(Ссылка[0]) <> Неопределено Тогда
				
				Если ПомечатьНаУдаление.Найти(Ссылка[1]) = Неопределено Тогда
					
					ПомечатьНаУдаление.Добавить(Ссылка[1]);
					
				КонецЕсли;
				
				ТабСсылок.Удалить(Ссылка);
				ОбработкаЗавершена = Ложь;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Для Каждого Ссылка Из СсылкиНаУдаление Цикл
		
		ДокументОбъект = Ссылка.ПолучитьОбъект();
		Если ДокументОбъект = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			ДокументОбъект.Заблокировать();
		Исключение
			
			Если ПомечатьНаУдаление.Найти(Ссылка) = Неопределено Тогда
				ПомечатьНаУдаление.Добавить(Ссылка);
			КонецЕсли;
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстНеЗаблокирован, СокрЛП(Ссылка)); 
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
			Продолжить;
			
		КонецПопытки;
		
		ДокументОбъект.УстановитьПометкуУдаления(Истина);
		Если ПомечатьНаУдаление.Найти(Ссылка) <> Неопределено Тогда
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстПомечен, СокрЛП(Ссылка));
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого Ссылка Из ПомечатьНаУдаление Цикл
		
		Индекс = СсылкиНаУдаление.Найти(Ссылка);
		Если Индекс <> Неопределено Тогда
			СсылкиНаУдаление.Удалить(Индекс);
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого Ссылка Из СсылкиНаУдаление Цикл
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстУдален, СокрЛП(Ссылка)); 
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
		
	КонецЦикла;
	
	УдалитьОбъекты(СсылкиНаУдаление, Ложь);
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат СписокОшибок;
	
КонецФункции

// Возвращает структуру с ключами, соответствующими колонкам таблицы значений.
// Значения в структуре заполняются значениями полей из переданной строки таблицы.
//
// Параметры:
//	ТекущаяСтрока - СтрокаТаблицыЗначений
//
// Возвращаемое значение:
//	Структура
//
Функция ПреобразоватьСтрокуТаблицыВСтруктуру(ТекущаяСтрока) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого Колонка Из ТекущаяСтрока.Владелец().Колонки Цикл
		Результат.Вставить(Колонка.Имя, ТекущаяСтрока[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Устанавливает параметры запроса из переданной структуры.
//
// Параметры:
//	Запрос - Запрос - запрос, параметры которого надо установить
//	ПараметрыЗапроса - Структура - структура с устанавливаемыми параметрами запроса.
//
Процедура УстановитьПараметрыЗапроса(Запрос, ПараметрыЗапроса) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ПараметрыЗапроса Цикл
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Получает макет в метаданных и возвращает его
//
// Параметры:
//  Макет	 - строка - полное имя макета. Например, Документ.РеализацияТоваровУслуг.ДанныеШаблонаСообщений 
// 
// Возвращаемое значение:
//  ТабличныйДокумент, ТекстовыйДокумент,СхемаКомпоновкиДанных или другой объект, который может быть макетом 
//
Функция МакетПоИмени(ИмяМакетаИлиАдрес) Экспорт
	
	ПоложениеТочки = СтрНайти(ИмяМакетаИлиАдрес, ".",,,2);
	
	Если ПоложениеТочки = 0 Тогда
		ПоложениеТочки = СтрНайти(ИмяМакетаИлиАдрес, ".",,,1);
		
		ИмяМакета    = Прав(ИмяМакетаИлиАдрес, СтрДлина(ИмяМакетаИлиАдрес) - ПоложениеТочки); 
		Результат = ПолучитьОбщийМакет(ИмяМакета);
	Иначе
		ИмяМенеджера = Лев(ИмяМакетаИлиАдрес, ПоложениеТочки);
		ИмяМакета    = Прав(ИмяМакетаИлиАдрес, СтрДлина(ИмяМакетаИлиАдрес) - ПоложениеТочки); 
		
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ИмяМенеджера);
		
		Результат = МенеджерОбъекта.ПолучитьМакет(ИмяМакета);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Свернуть табличную часть объекта
// По умолчанию все числовые колонки попадают в колонки суммирования. Те числовые колонки,
// которые должны попасть в колонки группировки, нужно перечислить в параметре КолонкиГруппировок.
// Нечисловые колонки перечислять в КолонкиГруппировки не нужно.
// 
// Параметры:
//  Объект			   - ДокументОбъект, СправочникОбъект, ОбработкаОбъект, ПланВидовХарактеристикОбъект, ПланОбменаОбъект 
//							- любой объект, содержащий табличную часть 
//  ИмяТЧ			   - Строка - имя табличной части, которую нужно свернуть
//  КолонкиГруппировок - Массив, Строка - массив строк с именами числовых колонок или строка с именами через запятую,
//  						которые нужно включить в колонки группировки, а не суммирования
//
Процедура СвернутьТабличнуюЧасть(Объект, ИмяТЧ, Знач КолонкиГруппировок = Неопределено) Экспорт
	
	Если КолонкиГруппировок = Неопределено Тогда
		КолонкиГруппировок = Новый Массив;
	ИначеЕсли ТипЗнч(КолонкиГруппировок) = Тип("Строка") Тогда
		КолонкиГруппировок = СтрРазделить(КолонкиГруппировок, ",", Ложь);
	КонецЕсли;
	
	КолонкиСуммирования = Новый Массив;
	
	МетаданныеДокумента = Объект.Метаданные();
	
	Для Каждого Колонка из МетаданныеДокумента.ТабличныеЧасти[ИмяТЧ].Реквизиты Цикл
		Если ТипЗнч(Колонка.Тип.ПривестиЗначение()) = Тип("Число") Тогда
			Если КолонкиГруппировок.Найти(Колонка.Имя)  = Неопределено Тогда
				КолонкиСуммирования.Добавить(Колонка.Имя);
			КонецЕсли;
		Иначе
			КолонкиГруппировок.Добавить(Колонка.Имя);	
		КонецЕсли;
	КонецЦикла;
	
	Объект[ИмяТЧ].Свернуть(СтрСоединить(КолонкиГруппировок, ","), СтрСоединить(КолонкиСуммирования,","));
	
КонецПроцедуры

// Сворачивает таблицу значение с возможностью сохранением порядка строк
// В случаи, когда параметр КолонкиСуммирования не указан все числовые колонки попадают в колонки суммирования.
// Те числовые колонки, которые должны попасть в колонки группировки, нужно перечислить в параметре КолонкиГруппировок.
// Нечисловые колонки перечислять в КолонкиГруппировки не нужно.
// При сохранении порядка строк колонки, которые не участвуют в сворачивании, не удаляются и остаются заполненными
// значением первой найденной строки в разрезе колонок группировки
// 
// Параметры:
//  Таблица			    - ТаблицаЗначений              - Таблица сворачивания
//  КолонкиГруппировок  - Строка, Массив, Неопределено - Колонки группировки таблицы
//  КолонкиСуммирования - Строка, Массив, Неопределено - Колонки сворачивания таблицы
//  СохранитьПорядок    - Булево                       - Признак сохранения порядка строк
//
Процедура СвернутьТаблицуЗначений(Таблица, Знач КолонкиГруппировок = Неопределено, Знач КолонкиСуммирования = Неопределено, СохранитьПорядок = Ложь) Экспорт
	
	Если КолонкиСуммирования = Неопределено Тогда
		
		Если КолонкиГруппировок = Неопределено Тогда
			КолонкиГруппировок = Новый Массив;
		ИначеЕсли ТипЗнч(КолонкиГруппировок) = Тип("Строка") Тогда
			КолонкиГруппировок = СтрРазделить(КолонкиГруппировок, ",", Ложь);
		КонецЕсли;
		
		КолонкиСуммирования = Новый Массив;
		
		Для Каждого Колонка из Таблица.Колонки Цикл
			Если ТипЗнч(Колонка.ТипЗначения.ПривестиЗначение()) = Тип("Число") Тогда
				Если КолонкиГруппировок.Найти(Колонка.Имя) = Неопределено Тогда
					КолонкиСуммирования.Добавить(Колонка.Имя);
				КонецЕсли;
			Иначе
				КолонкиГруппировок.Добавить(Колонка.Имя);	
			КонецЕсли;
		КонецЦикла;	
		
		КолонкиГруппировок  = СтрСоединить(КолонкиГруппировок , ",");
		КолонкиСуммирования = СтрСоединить(КолонкиСуммирования, ",");
		
	ИначеЕсли КолонкиГруппировок = Неопределено Тогда	
		
		Если ТипЗнч(КолонкиСуммирования) = Тип("Строка") Тогда
			КолонкиСуммирования = СтрРазделить(КолонкиСуммирования, ",", Ложь);
		КонецЕсли;
		
		КолонкиГруппировок = Новый Массив;
		
		Для Каждого Колонка из Таблица.Колонки Цикл
			Если КолонкиСуммирования.Найти(Колонка.Имя) = Неопределено Тогда
				КолонкиГруппировок.Добавить(Колонка.Имя);
			КонецЕсли;	
		КонецЦикла;
		
		КолонкиГруппировок  = СтрСоединить(КолонкиГруппировок , ",");
		КолонкиСуммирования = СтрСоединить(КолонкиСуммирования, ",");
		
	Иначе	
		
		Если ТипЗнч(КолонкиГруппировок) = Тип("Массив") Тогда
			КолонкиГруппировок = СтрСоединить(КолонкиГруппировок, ",");	
		КонецЕсли;	
		
		Если ТипЗнч(КолонкиСуммирования) = Тип("Массив") Тогда
			КолонкиСуммирования = СтрСоединить(КолонкиСуммирования, ",");	
		КонецЕсли;	
		
	КонецЕсли;
	
	
	Если СохранитьПорядок Тогда
		
		МассивКолонокСуммирования = СтрРазделить(КолонкиСуммирования, ",");
		
		Таблица.Индексы.Добавить(КолонкиГруппировок);
		
		ИндексСтроки    = 0;
		КоличествоСтрок = Таблица.Количество();
		СтруктураОтбора = Новый Структура(КолонкиГруппировок);
		
		Пока КоличествоСтрок > 0 Цикл
			
			СтрокаГруппировки = Таблица[ИндексСтроки];
			ЗаполнитьЗначенияСвойств(СтруктураОтбора, СтрокаГруппировки);
			
			МассивСтрок = Таблица.НайтиСтроки(СтруктураОтбора);
			ИндексНайденнойСтроки = МассивСтрок.ВГраница();
			Пока ИндексНайденнойСтроки > 0 Цикл
				
				НайденнаяСтрока = МассивСтрок[ИндексНайденнойСтроки];
				
				Для каждого КолонкаСуммирования Из МассивКолонокСуммирования Цикл
					СтрокаГруппировки[КолонкаСуммирования] = СтрокаГруппировки[КолонкаСуммирования] 
															 + НайденнаяСтрока[КолонкаСуммирования];  
				КонецЦикла;
				
				Таблица.Удалить(НайденнаяСтрока);
				
				КоличествоСтрок       = КоличествоСтрок - 1;
				ИндексНайденнойСтроки = ИндексНайденнойСтроки - 1;
				
			КонецЦикла;	
			
			КоличествоСтрок = КоличествоСтрок - 1;
			ИндексСтроки    = ИндексСтроки + 1;
			
		КонецЦикла;
	
	Иначе
		
		Таблица.Свернуть(КолонкиГруппировок, КолонкиСуммирования);
		
	КонецЕсли;	
	
КонецПроцедуры

// Проверяет соответствие функции переданному отбору
//
// Параметры:
//  Ссылка	 - ЛюбаяСсылка 
//  Отбор	 - Структура - Ключ - имя реквизита, Значение - значение реквизита, или массив значений реквизита
// 
// Возвращаемое значение:
//  Булево 
//
Функция СсылкаСоответствуетОтбору(Ссылка, Отбор) Экспорт
	
	ИменаРеквизитов = Новый Массив;
	
	Для Каждого КлючЗначение Из Отбор Цикл
		
		ИменаРеквизитов.Добавить(КлючЗначение.Ключ);
		
	КонецЦикла;

	ЗначенияРеквизитов = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, СтрСоединить(ИменаРеквизитов, ","));
	
	Для Каждого КлючЗначение Из Отбор Цикл
		
		ЗначениеРеквизита = ЗначенияРеквизитов[КлючЗначение.Ключ];
		
		Если ТипЗнч(КлючЗначение.Значение) = Тип("Массив")
			Или ТипЗнч(КлючЗначение.Значение) = Тип("ФиксированныйМассив") Тогда
			
			Если КлючЗначение.Значение.Найти(ЗначениеРеквизита) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
		ИначеЕсли КлючЗначение.Значение <> ЗначениеРеквизита Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Выполняет проверку на соответствие операций создаваемого документа операции распоряжения.
//
// Параметры:
//	РаспоряжениеСсылка    - ЛюбаяСсылка - ссылка распоряжения, на основании которого осуществляется создание документа.
//	ИмяДокумента          - Строка      - имя документа, для которого определяются допустимые операции.
//	ХозяйственнаяОперация - ПеречислениеСсылка.ХозяйственныеОперации - хозяйственная операция, для которой выполняется проверка
//
// Возвращаемое значение:
//	Булево - Истина, возможно создание документа на основании распоряжения.
//
Функция ПроверитьОперациюРаспоряжения(РаспоряжениеСсылка, ИмяДокумента, ХозяйственнаяОперация = Неопределено) Экспорт
	
	ДопустимыеОперации = ДопустимыеХозяйственныеОперацииДокумента(ИмяДокумента);
	
	Если ЗначениеЗаполнено(ХозяйственнаяОперация) Тогда
		ОперацияДокумента = ХозяйственнаяОперация;
	Иначе
		ОперацияДокумента  = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(РаспоряжениеСсылка, "ХозяйственнаяОперация");
	КонецЕсли;
	
	Если ДопустимыеОперации.Найти(ОперацияДокумента) = Неопределено Тогда
		ШаблонСтроки = НСтр("ru='Невозможно оформить документ ""%1"" на основании распоряжения %2 с операцией ""%3"".'");
		
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСтроки,
											Метаданные.Документы[ИмяДокумента].Синоним,
											РаспоряжениеСсылка,
											ОперацияДокумента);
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,РаспоряжениеСсылка);
		
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

// Возвращает массив с хозяйственными операциями, допустимые для документа по функциональным опциям.
//
// Параметры:
//	ИмяДокумента - Строка - имя документа, для которого определяются допустимые операции
//
// Возвращаемое значение:
//	Массив - с элементами Перечисление.ХозяйственнаяОперация
//
Функция ДопустимыеХозяйственныеОперацииДокумента(ИмяДокумента) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ЗначениеПустойСсылки", Документы[ИмяДокумента].ПустаяСсылка());
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ЕСТЬNULL(НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции, """") КАК ИмяФункциональнойОпции,
	|	НастройкиХозяйственныхОперацийДокументы.Ссылка.ХозяйственнаяОперация                     КАК ХозяйственнаяОперация
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.Документы КАК НастройкиХозяйственныхОперацийДокументы
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК ИдентификаторыОбъектовМетаданных
	|		ПО (НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных = ИдентификаторыОбъектовМетаданных.Ссылка)
	|			И (ИдентификаторыОбъектовМетаданных.ЗначениеПустойСсылки = &ЗначениеПустойСсылки)
	|
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.НастройкиХозяйственныхОпераций.ФункциональныеОпции КАК НастройкиХозяйственныхОперацийФункциональныеОпции
	|		ПО (НастройкиХозяйственныхОперацийДокументы.Ссылка = НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ИмяФункциональнойОпции";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	ДопустимыеОперации = Новый СписокЗначений;
	
	Пока Выборка.СледующийПоЗначениюПоля("ИмяФункциональнойОпции") Цикл
		
		Если Не ЗначениеЗаполнено(Выборка.ИмяФункциональнойОпции)
			Или ПолучитьФункциональнуюОпцию(Выборка.ИмяФункциональнойОпции) Тогда
			
			Пока Выборка.Следующий() Цикл
				Если ДопустимыеОперации.НайтиПоЗначению(Выборка.ХозяйственнаяОперация) = Неопределено Тогда
					ДопустимыеОперации.Добавить(Выборка.ХозяйственнаяОперация);
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ДопустимыеОперации.СортироватьПоЗначению();
	
	Возврат ДопустимыеОперации.ВыгрузитьЗначения();
	
КонецФункции

// Устарела. Следует использовать РаботаСКурсамиВалют.ОписаниеТипаДенежногоПоля()
// Возвращает описание типа денежного поля.
//
// Параметры:
//  ЗнакПоля - ДопустимыйЗнак - допустимый знак денежного поля (по умолчанию Любой)
//
// Возвращаемое значение:
//  ОписаниеТипов - описание типа денежного поля
//
Функция ОписаниеТипаДенежногоПоля(ЗнакПоля = Неопределено) Экспорт
	
	Возврат РаботаСКурсамиВалют.ОписаниеТипаДенежногоПоля(ЗнакПоля);
	
КонецФункции

// Возвращает разрядность описания типа денежного поля.
//
// Возвращаемое значение:
//	Структура - с полями Разрядность и РазрядностьДробнойЧасти, аналогично полям объекта КвалификаторыЧисла.
//
Функция РазрядностьДенежногоПоля() Экспорт
	
	Результат = Новый Структура("Разрядность, РазрядностьДробнойЧасти");
	ЗаполнитьЗначенияСвойств(Результат, ОписаниеТипаДенежногоПоля().КвалификаторыЧисла);
	
	Возврат Результат;
	
КонецФункции
	
// Возвращает общий модуль локализации объекта по полному имени объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных. Пример: "Справочник.Организации".
//
// Возвращаемое значение:
//  ОбщийМодуль - общий модуль локализации объекта.
//
Функция ПолучитьМодульЛокализации(ПолноеИмя) Экспорт
	ИмяМодуляЛокализации = "";
	ЧастиИмени = СтрРазделить(ПолноеИмя, ".");
	Если ЧастиИмени.Количество() > 1 Тогда
		ИмяМодуляЛокализации = ЧастиИмени[1] + "Локализация";
	Иначе
		ИмяМодуляЛокализации = ПолноеИмя + "Локализация";
	КонецЕсли;
	ОбщийМодульЛокализации = Неопределено;
	
	Если Метаданные.ОбщиеМодули.Найти(ИмяМодуляЛокализации) <> Неопределено Тогда
		ОбщийМодульЛокализации = Вычислить(ИмяМодуляЛокализации); // ВычислитьВБезопасномРежиме не требуется, т.к. проверка надежная.
	КонецЕсли;
	
	Если ТипЗнч(ОбщийМодульЛокализации) = Тип("ОбщийМодуль") Тогда
		Возврат ОбщийМодульЛокализации
	Иначе
		Возврат Неопределено
	КонецЕсли
	
КонецФункции

// Формирует список временных таблиц.
//
// Параметры:
//  МенеджерВременныхТаблиц	 - МенеджерВременныхТаблиц	 - менеджер временных таблиц, таблицы которого нужно получить.
// 
// Возвращаемое значение:
//  Массив из Строка - имена временных таблиц, находящиеся в менеджере.
//
Функция СписокВременныхТаблиц(МенеджерВременныхТаблиц) Экспорт

	СписокВременныхТаблиц = Новый Массив;
	
	Для каждого Таблица Из МенеджерВременныхТаблиц.Таблицы Цикл
		СписокВременныхТаблиц.Добавить(Таблица.ПолноеИмя);
	КонецЦикла; 
	
	Возврат СписокВременныхТаблиц;

КонецФункции

// Уничтожает временные таблицы менеджера временных таблиц.
//
// Параметры:
//  МенеджерВременныхТаблиц	 - МенеджерВременныхТаблиц	 - менеджер временных таблиц, таблицы которого нужно уничтожить.
//  СписокТаблиц			 - Строка, Массив			 - имена временных таблиц для уничтожения, разделенные запятыми. Если параметр не установлен - все таблицы.
//  ИсключаяТаблицы			 - Строка, Массив			 - имена временных таблиц, которые нужно оставить, разделенные запятыми.
//
Процедура УничтожитьВременныеТаблицы(МенеджерВременныхТаблиц, СписокТаблиц = Неопределено, ИсключаяТаблицы = Неопределено) Экспорт
	
	Если ИсключаяТаблицы <> Неопределено Тогда
		МассивИсключаемыхТаблиц = ?(ТипЗнч(ИсключаяТаблицы) = Тип("Массив"), ИсключаяТаблицы, СтрРазделить(ИсключаяТаблицы, ","));
	Иначе
		МассивИсключаемыхТаблиц = Новый Массив();
	КонецЕсли;
	
	Если СписокТаблиц <> Неопределено Тогда
		МассивТаблиц = ?(ТипЗнч(СписокТаблиц) = Тип("Массив"), СписокТаблиц, СтрРазделить(СписокТаблиц, ","));
	Иначе
		МассивТаблиц = Новый Массив();
		Для Каждого Таблица Из МенеджерВременныхТаблиц.Таблицы Цикл
			Если МассивИсключаемыхТаблиц.Найти(Таблица.ПолноеИмя) = Неопределено Тогда
				МассивТаблиц.Добавить(Таблица.ПолноеИмя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если МассивТаблиц.Количество() > 0 Тогда
		ТекстЗапроса = "";
		Для Каждого ИмяТаблицы Из МассивТаблиц Цикл
			ТекстЗапроса = ТекстЗапроса + "УНИЧТОЖИТЬ " + ИмяТаблицы + "; ";
		КонецЦикла;
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
		Запрос.Выполнить();
	КонецЕсли;
	
КонецПроцедуры

#Область СинхнонизацияКлючей

// Составляет список ключевых реквизитов справочника ключей.
// Если справочнику сопоставлен регистр сведений, используемый для поиска ключа,
// то ключевые реквизиты соответствуют изменениям этого регистра сведений.
//
// Параметры:
//  МетаданныеРегистра	 - ОбъектМетаданных: РегистрСведений 
// 
// Возвращаемое значение:
//  Соответствие 
//
Функция КлючевыеРеквизитыСправочникаКлючейПоРегиструСведений(МетаданныеРегистра) Экспорт
	
	Результат = Новый Соответствие;
	
	Для Каждого Измерение из МетаданныеРегистра.Измерения Цикл
		
		Результат.Вставить(Измерение.Имя);	
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Подготавливает свойство ДополнительныеСвойства объекта для использования процедуры
// ОбщегоНазначенияУТ.СинхронизироватьКлючи. Должна быть вызвана в событии ПередЗаписью объекта.
//
// Параметры:
//  Объект		 - ДокументОбъект, СправочникОбъект - объект, который должен быть синхронизирован с ключами 
//  Параметры	 - Соответствие - 
//				Ключ - полное имя объекта ключа, с которым нужно синхронизировать объект. 
//						Например, Справочник.КлючиРеестраДокументов
//						В модуле менеджера ключа обязательно должна быть объявлена экспортная функция КлючевыеРеквизиты,
//                      возвращающая соответствие с именами реквизитов, по которым определяется уникальность ключа.
//
//				Значение - описание синхронизируемых реквизитов 
//						Варианты типов значения:
//							- Строка - список реквизитов через запятую. Имена реквизитов объекта должны совпадать
//										с именами реквизитов ключа
//							- Структура 
//										- Ключ - Строка - имя реквизита объекта
//										- Значение - Строка - имя реквизита ключа. Необязательно,
//																 если не заполнено, то используется Ключ
//										
Процедура ПодготовитьДанныеДляСинхронизацииКлючей(Объект, Параметры) Экспорт
	
	// Синхронизацию ключей необходимо осуществлять в т.ч. в режиме загрузке (при обменах не РИБ),
	// т.к. при подготовке параметров ключей анализируется состояние ключевых реквизитов объекта
	// до и после изменения, а при повторной записи без режима загрузки реквизиты уже будут идентичны.
	Если Объект.ОбменДанными.Загрузка Тогда
		Отправитель = Объект.ОбменДанными.Отправитель;
		Если НЕ ЗначениеЗаполнено(Отправитель) ИЛИ ЗначениеЗаполнено(Отправитель)
			И ОбменДаннымиПовтИсп.ЭтоУзелРаспределеннойИнформационнойБазы(Отправитель) Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Объект.ДополнительныеСвойства.Вставить("ЭтоНовый", Объект.ЭтоНовый());
	
	МетаданныеОбъекта = Объект.Метаданные();
	
	ПолучаемыеРеквизиты          = Новый Структура;
	ПараметрыСинхронизацииКлючей = Новый Соответствие;
	ПустыеЗначенияРеквизитов     = Новый Структура;
	
	Для Каждого КлючЗначение из Параметры Цикл
		
		НормализованноеОписаниеРеквизитов = Новый Структура;
		
		Если ТипЗнч(КлючЗначение.Значение) = Тип("Строка") Тогда
			ТекущиеРеквизиты = СтрРазделить(КлючЗначение.Значение, ",");
			
			Для Каждого СтрМас Из ТекущиеРеквизиты Цикл
				ИмяРеквизита = СокрЛП(СтрМас);
				ПроверитьИспользованиеРеквизитаПолучитьПустоеЗначение(Объект, МетаданныеОбъекта, ИмяРеквизита, ПустыеЗначенияРеквизитов);
				
				Если ПустыеЗначенияРеквизитов[ИмяРеквизита] <> "Неиспользуется" Тогда 
					ПолучаемыеРеквизиты.Вставить(ИмяРеквизита,ИмяРеквизита);
					НормализованноеОписаниеРеквизитов.Вставить(ИмяРеквизита, ИмяРеквизита);
				КонецЕсли;
				
			КонецЦикла;
			
		ИначеЕсли ТипЗнч(КлючЗначение.Значение) = Тип("Структура") Тогда
			Для Каждого ТекущиеРеквизиты Из КлючЗначение.Значение Цикл
				
				ИмяРеквизита = ТекущиеРеквизиты.Ключ;
				ПроверитьИспользованиеРеквизитаПолучитьПустоеЗначение(Объект, МетаданныеОбъекта, ИмяРеквизита, ПустыеЗначенияРеквизитов);
				
				Если ПустыеЗначенияРеквизитов[ИмяРеквизита] <> "Неиспользуется" Тогда 
					
					ПолучаемыеРеквизиты.Вставить(ИмяРеквизита, ИмяРеквизита);
					
					Если ЗначениеЗаполнено(ТекущиеРеквизиты.Значение) Тогда
						НормализованноеОписаниеРеквизитов.Вставить(ИмяРеквизита, ТекущиеРеквизиты.Значение);
					Иначе
						НормализованноеОписаниеРеквизитов.Вставить(ИмяРеквизита, ИмяРеквизита);
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЦикла;
		Иначе
			ТекстИсключения = НСтр("ru = 'Не поддерживаемый тип описания реквизитов, синхронизируемых с ключем %ИмяКлюча%'");
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяКлюча%", КлючЗначение.Ключ);
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;	
		
		ПараметрыСинхронизацииКлючей.Вставить(КлючЗначение.Ключ, НормализованноеОписаниеРеквизитов); 
		
	КонецЦикла;
	
	Объект.ДополнительныеСвойства.Вставить("ПараметрыСинхронизацииКлючей", ПараметрыСинхронизацииКлючей);
	
	Если Объект.ДополнительныеСвойства.ЭтоНовый Тогда
		
		Для Каждого КлючЗначение Из ПолучаемыеРеквизиты Цикл
			Объект.ДополнительныеСвойства.Вставить(КлючЗначение.Ключ + "ДоЗаписи", ПустыеЗначенияРеквизитов[КлючЗначение.Ключ]);
		КонецЦикла;
		
	Иначе
		
		ЗначенияРеквизитовДоЗаписи = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Объект.Ссылка, ПолучаемыеРеквизиты);
		
		Для Каждого КлючЗначение Из ЗначенияРеквизитовДоЗаписи Цикл
			Объект.ДополнительныеСвойства.Вставить(КлючЗначение.Ключ + "ДоЗаписи", КлючЗначение.Значение);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Синхронизирует значения реквизитов объекта с ключами.
// Должна быть вызвана в событии ПриЗаписи объекта. При этом в событии ПередЗаписью этого объекта
// обязятельно должна быть вызвана процедура ОбщегоНазначенияУТ.ПодготовитьДанныеДляСинхронизацииКлючей.
//
// Если в ключе один ключевой реквизит, то проверяется существование ключа и если его нет, то он создается.
//
// Параметры:
//  Объект	 -  ДокументОбъект, СправочникОбъект - объект, который должен быть синхронизирован с ключами 
//
Процедура СинхронизироватьКлючи(Объект) Экспорт
	
	Если Объект.ОбменДанными.Загрузка Тогда
		Отправитель = Объект.ОбменДанными.Отправитель;
		Если НЕ ЗначениеЗаполнено(Отправитель) ИЛИ ЗначениеЗаполнено(Отправитель)
			И ОбменДаннымиПовтИсп.ЭтоУзелРаспределеннойИнформационнойБазы(Отправитель) Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ПараметрыСинхронизацииКлючей = Объект.ДополнительныеСвойства.ПараметрыСинхронизацииКлючей;
	КлючиДляОбновления = Новый Соответствие; // Ключ - имя объекта, Значение - структура с изменившимися реквизитами
	
	Для Каждого ПараметрСинхронизации из ПараметрыСинхронизацииКлючей Цикл
		
		ОписаниеКлюча = Новый Структура;
		ОписаниеКлюча.Вставить("ПолноеИмя", "");
		ОписаниеКлюча.Вставить("ИзменившиесяРеквизиты", Новый Структура);
		ОписаниеКлюча.Вставить("КлючевыеРеквизиты", Новый Структура);
		ОписаниеКлюча.Вставить("КлючевойРеквизитДляСоздания", Неопределено); // если нужно создавать ключ, тут имя ключевого реквизита
		ОписаниеКлюча.Вставить("МенеджерОбъекта", Неопределено); // если нужно создавать ключ, тут имя ключевого реквизита
		
		ОписаниеКлюча.ПолноеИмя = ПараметрСинхронизации.Ключ;
		
		ОписаниеКлюча.МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ОписаниеКлюча.ПолноеИмя);
		
		МетаданныеСправочникаКлючей = Метаданные.НайтиПоПолномуИмени(ОписаниеКлюча.ПолноеИмя);
		
		КлючевыеРеквизиты = ОписаниеКлюча.МенеджерОбъекта.КлючевыеРеквизиты();
		
		Для Каждого ИмяРеквизита из КлючевыеРеквизиты Цикл
			МетаданныеРеквизита = МетаданныеСправочникаКлючей.Реквизиты.Найти(ИмяРеквизита.Ключ);
			
			Если МетаданныеРеквизита = Неопределено Тогда
				
				Для Каждого СтандартныйРеквизит Из МетаданныеСправочникаКлючей.СтандартныеРеквизиты Цикл
					Если СтандартныйРеквизит.Имя = ИмяРеквизита.Ключ Тогда
						МетаданныеРеквизита = СтандартныйРеквизит;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если МетаданныеРеквизита = Неопределено Тогда
					ТекстИсключения = НСтр("ru = 'Для ключа %ИмяКлюча% ключевой реквизит %ИмяРеквизит% не найден. Ошибка в описании ключевых реквизитов'");
					ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяКлюча%", ОписаниеКлюча.ПолноеИмя);
					ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяРеквизит%", ИмяРеквизита.Ключ);
					ВызватьИсключение ТекстИсключения;
				КонецЕсли;	
				
			КонецЕсли;	
			
			ОписаниеКлюча.КлючевыеРеквизиты.Вставить(ИмяРеквизита.Ключ, МетаданныеРеквизита);
			
		КонецЦикла;
		
		Если ОписаниеКлюча.КлючевыеРеквизиты.Количество() = 0 Тогда
			ТекстИсключения = НСтр("ru = 'Для ключа %ИмяКлюча% не заданы ключевые реквизиты'");
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяКлюча%", ОписаниеКлюча.ПолноеИмя);
			ВызватьИсключение ТекстИсключения;
		ИначеЕсли ОписаниеКлюча.КлючевыеРеквизиты.Количество() = 1 Тогда
			// Если ключевой реквизит один, значит ключ нужно генерировать при создании элемента справочника
			Для Каждого ИмяРеквизита Из ОписаниеКлюча.КлючевыеРеквизиты Цикл
				// По индексу в соотвествии первый элемент не получить, поэтому такой цикл
				ОписаниеКлюча.КлючевойРеквизитДляСоздания = ИмяРеквизита.Ключ;
			КонецЦикла;
		КонецЕсли;
		
		Если Объект.ДополнительныеСвойства.ЭтоНовый Тогда
			
			Если ОписаниеКлюча.КлючевойРеквизитДляСоздания <> Неопределено Тогда
				
				Для Каждого ОписаниеРеквизита Из ПараметрСинхронизации.Значение Цикл
					ОписаниеКлюча.ИзменившиесяРеквизиты.Вставить(ОписаниеРеквизита.Ключ, ОписаниеРеквизита.Значение);	
				КонецЦикла;
				
				КлючиДляОбновления.Вставить(ОписаниеКлюча.ПолноеИмя, ОписаниеКлюча);
				
			КонецЕсли;
						
		Иначе
			
			ЕстьИзменившиесяРеквизиты = Ложь;
			
			Для Каждого ОписаниеРеквизита Из ПараметрСинхронизации.Значение Цикл
								
				РеквизитИзменился = Объект[ОписаниеРеквизита.Ключ] <> Объект.ДополнительныеСвойства[ОписаниеРеквизита.Ключ + "ДоЗаписи"];
				
				Если РеквизитИзменился Тогда
					ЕстьИзменившиесяРеквизиты = Истина;
					ОписаниеКлюча.ИзменившиесяРеквизиты.Вставить(ОписаниеРеквизита.Ключ, ОписаниеРеквизита.Значение);
				ИначеЕсли ОписаниеКлюча.КлючевойРеквизитДляСоздания <> Неопределено Тогда
					// Если нужно создавать ключ при его отсутсвии, значит нужно иметь все реквизиты, а не только изменившиеся
					// При этом если ничего вообще не менялось в справочнике, но зря читать таблицу ключей не будем - в
					// в этом случае просто не добавится потом описание ключа в КлючиДляОбновления
					ОписаниеКлюча.ИзменившиесяРеквизиты.Вставить(ОписаниеРеквизита.Ключ, ОписаниеРеквизита.Значение);
				КонецЕсли;
				
			КонецЦикла;
			
			Если ЕстьИзменившиесяРеквизиты Тогда 
				КлючиДляОбновления.Вставить(ОписаниеКлюча.ПолноеИмя, ОписаниеКлюча);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если КлючиДляОбновления.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ШаблонТекстаЗапроса =
	"ВЫБРАТЬ
	|	Ключи.Ссылка КАК Ссылка,
	|	&УсловиеИзмененияРеквизитов КАК РеквизитыИзменены
	|ИЗ
	|	ПолноеИмяТаблицы КАК Ключи
	|ГДЕ
	|	(&УсловиеПоискаКлюча)
	|	И (&УсловиеИзмененияРеквизитов
	|		ИЛИ (&УсловиеИзмененияПометкиУдаления)
	|		ИЛИ &СоздаватьЕслиОтсутствует)";
	
	ТипЗначенияСправочника = ТипЗнч(Объект.Ссылка);
	
	Блокировка = Новый БлокировкаДанных;
	Запрос = Новый Запрос;
	
	ТекстыЗапросаККлючам = Новый Массив;
	НомерЗапросаИмяОбъектаКлючей = Новый Соответствие;
	Счетчик = 0;
	
	Для каждого КлючДляОбновления Из КлючиДляОбновления Цикл
		
		ОписаниеКлюча = КлючДляОбновления.Значение;
		
		УсловиеПоискаКлюча = Новый Массив;
		УсловиеИзмененияРеквизитов = Новый Массив;
		УсловиеИзмененияПометкиУдаления = Новый Массив;
		
		Для Каждого ИмяРеквизита Из ОписаниеКлюча.КлючевыеРеквизиты Цикл
			
			Если ИмяРеквизита.Значение.Тип.СодержитТип(ТипЗначенияСправочника) Тогда
				УсловиеПоискаКлюча.Добавить("Ключи." + ИмяРеквизита.Значение.Имя + " = &Ссылка ");
				// Все ключевые реквизиты должны быть добавлены в поля блокировки
				ЭлементБлокировки = Блокировка.Добавить(ОписаниеКлюча.ПолноеИмя); 
				ЭлементБлокировки.УстановитьЗначение(ИмяРеквизита.Значение.Имя, Объект.Ссылка);
			КонецЕсли;
			
		КонецЦикла;
			
		Если УсловиеПоискаКлюча.Количество() = 0 Тогда
			ТекстИсключения = НСтр("ru = 'Справочник %ИмяСправочника% не отражается в ключе %ИмяКлюча% (передано значение %Значение%)'");
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяСправочника%", Метаданные.НайтиПоТипу(ТипЗначенияСправочника).ПолноеИмя());
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяКлюча%", ОписаниеКлюча.ПолноеИмя);
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%Значение%", Строка(Объект.Ссылка));
			
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
		Для Каждого ОписаниеРеквизита Из ОписаниеКлюча.ИзменившиесяРеквизиты Цикл
			
			Если ОписаниеРеквизита.Ключ = "ПометкаУдаления"
				И ОписаниеКлюча.КлючевойРеквизитДляСоздания = Неопределено Тогда
				// Ключ должен быть помечен на удаление, если хотя бы одно значение из ключевого реквизита
				// помечено на удаление.
				// Поведение такое:
				//	- помечаем элемент справочника на удаление
				//	      - помечаем все ключи, еще не помеченные на удаление
				//  - снимаем пометку удаления с элемента справочника
				//        - если ключ был помечен на удаление, то снимаем если все значения ключевых реквизитов не помечены на удаление
				// При этом если соотвествие ключ-справочник один к одному, то проверку пометки удаления делаем
				// одинаково со всеми остальными реквизитами
				
				Если Объект.ПометкаУдаления Тогда
					УсловиеИзмененияПометкиУдаления.Добавить("НЕ Ключи.ПометкаУдаления ");
				Иначе
					УсловиеИзмененияПометкиУдаления.Добавить("Ключи.ПометкаУдаления ");
					
					Для Каждого ИмяРеквизита Из ОписаниеКлюча.КлючевыеРеквизиты Цикл
						
						ЕстьСсылкаСПометкойУдаления = Ложь;
						ТипыЗначенияРеквизита = ИмяРеквизита.Значение.Тип.Типы();
						
						Для Каждого ТипЗначенияРеквизита из ТипыЗначенияРеквизита Цикл
							Если ОбщегоНазначения.ЭтоСсылка(ТипЗначенияРеквизита)
								И Не ОбщегоНазначения.ЭтоПеречисление(Метаданные.НайтиПоТипу(ТипЗначенияРеквизита)) Тогда
								
								ЕстьСсылкаСПометкойУдаления = Истина;
								Прервать;
								
							КонецЕсли;
						КонецЦикла;		
						
						Если ЕстьСсылкаСПометкойУдаления Тогда
							УсловиеИзмененияПометкиУдаления.Добавить("НЕ ЕСТЬNULL(Ключи." + ИмяРеквизита.Ключ + ".ПометкаУдаления, ЛОЖЬ) ");
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;
				
			Иначе
				УсловиеИзмененияРеквизитов.Добавить(" Ключи." + ОписаниеРеквизита.Значение + " <> &" + ОписаниеРеквизита.Ключ + " ");
				Запрос.УстановитьПараметр(ОписаниеРеквизита.Ключ, Объект[ОписаниеРеквизита.Ключ]);
			КонецЕсли;
			
		КонецЦикла;
		
		ТекстЗапроса = СтрЗаменить(ШаблонТекстаЗапроса, "ПолноеИмяТаблицы", ОписаниеКлюча.ПолноеИмя); 
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеПоискаКлюча", СтрСоединить(УсловиеПоискаКлюча, " ИЛИ ")); 
		
		Если УсловиеИзмененияПометкиУдаления.Количество() = 0
			И УсловиеИзмененияРеквизитов.Количество() = 0 Тогда
			ТекстИсключения = НСтр("ru = 'Ошибка в алгоритме синхронизации с ключем %ИмяКлюча% значения %Значение% из справочника %ИмяСправочника%'");
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяСправочника%", Метаданные.НайтиПоТипу(ТипЗначенияСправочника).ПолноеИмя());
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяКлюча%", ОписаниеКлюча.ПолноеИмя);
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%Значение%", Строка(Объект.Ссылка));
			
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
		Если УсловиеИзмененияПометкиУдаления.Количество() > 0 Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеИзмененияПометкиУдаления", СтрСоединить(УсловиеИзмененияПометкиУдаления, " И "));
		Иначе
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеИзмененияПометкиУдаления", "ЛОЖЬ");
		КонецЕсли;
		
		Если УсловиеИзмененияРеквизитов.Количество() > 0 Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеИзмененияРеквизитов", СтрСоединить(УсловиеИзмененияРеквизитов, " ИЛИ "));
		Иначе
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеИзмененияРеквизитов", "ЛОЖЬ");
		КонецЕсли;	
			
		Если ОписаниеКлюча.КлючевойРеквизитДляСоздания <> Неопределено Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&СоздаватьЕслиОтсутствует", "ИСТИНА");
		Иначе
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&СоздаватьЕслиОтсутствует", "ЛОЖЬ");
		КонецЕсли;
		
		ТекстыЗапросаККлючам.Добавить(ТекстЗапроса);
		НомерЗапросаИмяОбъектаКлючей.Вставить(Счетчик, ОписаниеКлюча.ПолноеИмя); 
		
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
	Запрос.Текст = СтрСоединить(ТекстыЗапросаККлючам, РазделительЗапросовВПакете());
	
	УстановитьПривилегированныйРежим(Истина);
	Блокировка.Заблокировать();
	РезультатыЗапроса = Запрос.ВыполнитьПакет();
	
	Для Индекс = 0 по РезультатыЗапроса.ВГраница() Цикл
		
		ОписаниеКлюча = КлючиДляОбновления[НомерЗапросаИмяОбъектаКлючей.Получить(Индекс)];
		РезультатЗапроса = РезультатыЗапроса[Индекс];
		
		Если РезультатЗапроса.Пустой() Тогда
			
			Если ОписаниеКлюча.КлючевойРеквизитДляСоздания <> Неопределено Тогда
				
				Если СтрНайти(ВРег(ОписаниеКлюча.ПолноеИмя), "ДОКУМЕНТ.") <> 0 Тогда
					ОбъектКлюча = ОписаниеКлюча.МенеджерОбъекта.СоздатьДокумент();
					ОбъектКлюча.Дата = ТекущаяДатаСеанса();
				Иначе
					ОбъектКлюча = ОписаниеКлюча.МенеджерОбъекта.СоздатьЭлемент();
				КонецЕсли;
				
				ОбъектКлюча[ОписаниеКлюча.КлючевойРеквизитДляСоздания] = Объект.Ссылка;
				
				Для Каждого Реквизит из ОписаниеКлюча.ИзменившиесяРеквизиты Цикл
					ОбъектКлюча[Реквизит.Значение] = Объект[Реквизит.Ключ];
				КонецЦикла;
				
				ОбъектКлюча.ДополнительныеСвойства.Вставить("СинхронизацияКлючаСоЗначением");
				ОбъектКлюча.Записать();
				
			Иначе
				Продолжить;
			КонецЕсли;
			
		Иначе
			
			ВыборкаИзЗапроса = РезультатЗапроса.Выбрать();
			Пока ВыборкаИзЗапроса.Следующий() Цикл
				ОбъектКлюча = ВыборкаИзЗапроса.Ссылка.ПолучитьОбъект();
				Для Каждого Реквизит из ОписаниеКлюча.ИзменившиесяРеквизиты Цикл
					ОбъектКлюча[Реквизит.Значение] = Объект[Реквизит.Ключ];
				КонецЦикла;
				
				ОбъектКлюча.ДополнительныеСвойства.Вставить("СинхронизацияКлючаСоЗначением");
				ОбъектКлюча.Записать();
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	УстановитьПривилегированныйРежим(Ложь);
	
КонецПроцедуры

#КонецОбласти

#Область МетодыРаботыСЗапросом

// Формирует пакет запросов и возвращает результат каждого запроса
//
// Параметры:
//	Запрос			- Запрос - запрос, параметры которого предварительно установлены.
//	ТекстыЗапроса	- СписокЗначений - в списке перечислены тексты запросов и их имена.
//	ОбходРезультата - ОбходРезультатаЗапроса - вариант обхода результата запроса.
//	ДобавитьРазделитель - Булево - добавлять разделитель между запросами из ТекстыЗапроса
//	УничтожитьСозданныеВременныеТаблицы - Булево - добавить уничтожение временных таблиц, создаваемых в ТекстыЗапроса
//										Для уничтожения таблице должно быть присвоено имя в ТекстыЗапроса.
//
// Возвращаемое значение:
//   Структура   - структура в которую помещены полученные таблицы.
//
Функция ВыгрузитьРезультатыЗапроса(Запрос,
								 	ТекстыЗапроса,
									ОбходРезультата = Неопределено,
									ДобавитьРазделитель = Ложь,
									УничтожитьСозданныеВременныеТаблицы = Ложь) Экспорт

	Таблицы = Новый Структура;
	
	// Инициализация варианта обхода результата запроса.
	Если ОбходРезультата = Неопределено Тогда
		ОбходРезультата = ОбходРезультатаЗапроса.Прямой;
	КонецЕсли;
	
	МассивТекстовЗапросов 	 = Новый Массив;
	МассивУничтожаемыхТаблиц = Новый Массив;
	
	// Формирование текст запроса.
	Для Каждого ТекстЗапроса Из ТекстыЗапроса Цикл
		
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			МассивТекстовЗапросов.Добавить("// " + ТекстЗапроса.Представление);
		КонецЕсли; 
		
		МассивТекстовЗапросов.Добавить(ТекстЗапроса.Значение + ?(ДобавитьРазделитель, РазделительЗапросовВПакете(), ""));
		
		Если УничтожитьСозданныеВременныеТаблицы
		 И ЗначениеЗаполнено(ТекстЗапроса.Представление)
		 И СтрНайти(ВРег(ТекстЗапроса.Значение), "ПОМЕСТИТЬ") <> 0 Тогда
			МассивУничтожаемыхТаблиц.Добавить(ТекстЗапроса.Представление);
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого ИмяУдаляемойТаблицы Из МассивУничтожаемыхТаблиц Цикл
		МассивТекстовЗапросов.Добавить("УНИЧТОЖИТЬ " + ИмяУдаляемойТаблицы + РазделительЗапросовВПакете());
	КонецЦикла;
	
	Если МассивТекстовЗапросов.Количество() > 0 Тогда
		
		// Выполнение запроса.
		Запрос.Текст = СтрСоединить(МассивТекстовЗапросов, Символы.ПС);
		Результаты = Запрос.ВыполнитьПакет();

		// Помещение результатов запроса в таблицы.
		Для Каждого ТекстЗапроса Из ТекстыЗапроса Цикл
			ИмяТаблицы = ТекстЗапроса.Представление;
			Если НЕ ПустаяСтрока(ИмяТаблицы) Тогда // имя таблицы
				Результат = Результаты[ТекстыЗапроса.Индекс(ТекстЗапроса)];
				Если Результат <> Неопределено Тогда
					ТаблицаЗапроса = Результат.Выгрузить(ОбходРезультата);
					Если Таблицы.Свойство(ТекстЗапроса.Представление) Тогда
						ОбъединитьТаблицыРезультатовЗапроса(ТаблицаЗапроса, Таблицы[ИмяТаблицы]);
					Иначе
						Таблицы.Вставить(ИмяТаблицы, ТаблицаЗапроса);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;

		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Таблицы;
	
КонецФункции

// Возвращает структуру границ оборотов по регистру
//
// Параметры:
//  ИмяРегистра - Строка - Имя регистра накопления.
//  Отборы      - Строка - Отборы виртуальной таблицы оборотов, для которой необходимо получить границы.
//  Параметры   - Структура - Параметры запроса для отборов виртуальной таблицы.
//
// Возвращаемое значение:
//  Структура - Структура границ со свойствами:
//  	* МинимальнаяДата - Дата - Начальная граница оборотов.
//  	* МаксимальнаяДата - Дата - Конечная граница оборотов.
//
Функция ГраницыОборотовРегистра(ИмяРегистра, Отборы, Параметры) Экспорт
	
	// Без отбора по умолчанию по полю Активность, т.к. по нему нет индекса,
	// из-за чего запрос может выполняться недопустимо долго.
	Запрос = Новый Запрос(СтрШаблон(
		"ВЫБРАТЬ
		|	МИНИМУМ(Таблица.Период)  КАК МинимальнаяДата,
		|	МАКСИМУМ(Таблица.Период) КАК МаксимальнаяДата
		|ИЗ
		|	РегистрНакопления.%1 КАК Таблица
		|ГДЕ
		|	%2", ИмяРегистра, ?(ПустаяСтрока(Отборы), "ИСТИНА", Отборы)));
	
	Для каждого Параметр Из Параметры Цикл
		Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
	КонецЦикла;
	
	УстановитьПривилегированныйРежим(Истина);
	Выборка = Запрос.Выполнить().Выбрать();
	УстановитьПривилегированныйРежим(Ложь);
	
	СтруктураГраниц = Новый Структура;
	Если Выборка.Следующий() И ЗначениеЗаполнено(Выборка.МинимальнаяДата) Тогда
		СтруктураГраниц.Вставить("МинимальнаяДата", Выборка.МинимальнаяДата);
		СтруктураГраниц.Вставить("МаксимальнаяДата", Выборка.МаксимальнаяДата);
	Иначе
		СтруктураГраниц.Вставить("МинимальнаяДата", '00010101');
		СтруктураГраниц.Вставить("МаксимальнаяДата", '39991231');
	КонецЕсли;
	
	Возврат СтруктураГраниц;
	
КонецФункции

// Возвращает строку для вставки между запросами, объединяемыми в пакет
// 
// Возвращаемое значение:
//  Строка 
//
Функция РазделительЗапросовВПакете() Экспорт
	
	Возврат "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";
	
КонецФункции

// Возвращает строку для вставки между текстами объединяемых запросов
// Параметры:
//	ТолькоУникальные - Булево - признак того, что необходимо выбирать только уникальные записи при объединении
//		значение по умолчанию - ЛОЖЬ.
// 
// Возвращаемое значение:
//  Строка 
//
Функция РазделительЗапросовВОбъединении(ТолькоУникальные = Ложь) Экспорт
	
	Если ТолькоУникальные Тогда
		Возврат "
		|
		|ОБЪЕДИНИТЬ
		|
		|";
	Иначе
		Возврат "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
	КонецЕсли;
	
КонецФункции

//Добавляет настройку отбора для запросов в коллекцию 
//
// Параметры:
//  Отбор               - Соответствие - коллекция настроек отборов
//  ЛевоеЗначение       - Строка       - левое значение отбора в запросах
//  ПравоеЗначение      - Строка       - правое значение отбора в запросах
//  ВидСравненияЗапроса - Строка       - вид сравнения запроса, по умолчанию: "В"
//
Процедура ДобавитьЭлементОтбораВКоллекцию(Отбор, ЛевоеЗначение, ПравоеЗначение, ВидСравненияЗапроса = "") Экспорт
	
	ВидСравненияПравоеЗначение = Новый Структура;
	
	ВидСравненияПравоеЗначение.Вставить("ВидСравнения"  , 
		?(ЗначениеЗаполнено(ВидСравненияЗапроса), ВидСравненияЗапроса, "В"));
		
	ВидСравненияПравоеЗначение.Вставить("ПравоеЗначение", ПравоеЗначение);
		
	Отбор.Вставить(ЛевоеЗначение, ВидСравненияПравоеЗначение);            
	
КонецПроцедуры

#КонецОбласти

#Область ПоискВТаблице

// Выполняет нумерацию строк таблицы значений. Для нумерации используется колонка ПорядковыйНомер.
// Если колонка с таким именем отсутствует в переданной таблице, то она будет добавлена.
//
// Параметры:
//  Таблица	- ТаблицаЗначений - таблица, строки которой будут пронумерованы.
//
Процедура ДобавитьВТаблицуПорядковыйНомерСтрок(Таблица) Экспорт
	
	ПронумероватьТаблицуЗначений(Таблица, "ПорядковыйНомер");
	
КонецПроцедуры

// Заполняет значение колонки ПорядковыйНомер в новой строке таблицы значений,
// строки которой пронумерованы (см. процедуру ДобавитьВТаблицуПорядковыйНомерСтрок).
//
// Параметры:
//  Таблица		 - ТаблицаЗначений - таблица с пронумерованными строками.
//  НоваяСтрока	 - СтрокаТаблицыЗначений - строка в которой необходимо заполнить порядковый номер.
//
Процедура ЗаполнитьПорядковыйНомерВНовойСтроке(Таблица, НоваяСтрока) Экспорт
	
	НоваяСтрока.ПорядковыйНомер = Таблица.Количество() + 1;
	
КонецПроцедуры

// Осуществляет поиск строк в таблице значений с сохранением их порядка.
//
// Параметры:
//  Таблица				 - ТаблицаЗначений - таблица в которой необходимо выполнить поиск.
//  УсловиеПоиска		 - Структура - условие поиска строк.
//  СтрокиПронумерованы	 - Булево - Истина, если строки таблицы были предварительно пронумерованы
//		(см. процедуру ДобавитьВТаблицуПорядковыйНомерСтрок).
// 
// Возвращаемое значение:
//  Массив - найденные строки.
//
Функция НайтиСтрокиССохранениемПорядка(Таблица, УсловиеПоиска, СтрокиПронумерованы = Ложь) Экспорт
	
	НайденныеСтроки = Таблица.НайтиСтроки(УсловиеПоиска);
	
	Если НайденныеСтроки.Количество() > 1 Тогда
		
		Если СтрокиПронумерованы Тогда
			
			Результат = УпорядочитьПронумерованныеСтроки(Таблица, НайденныеСтроки);
			
		Иначе
			
			Результат = УпорядочитьНеПронумерованныеСтроки(Таблица, НайденныеСтроки);
			
		КонецЕсли;
		
	Иначе
		
		Результат = НайденныеСтроки;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает значения реквизитов переданной ссылки, если ссылка пустая - возвращается значение по умолчанию 
// для каждого типа реквизита.
//
// Параметры:
//	Ссылка - ДокументСсылка - ссылка на объект информационной базы.
//	Реквизиты	 - Строка -
//	             - Массив Из Строка - имена реквизитов через запятую или массив имен реквизитов.
//
// Возвращаемое значение:
//	Структура - структура, свойствами которой являются реквизиты ссылки объекта информационной базы,
//							а значениями - значения реквизитов ссылки.
//
Функция ЗначенияРеквизитовОбъектаПоУмолчанию(Ссылка, Реквизиты) Экспорт
	
	Если ЗначениеЗаполнено(Ссылка) Тогда
		Результат = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты);
	Иначе
		Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда 
			Результат = Новый Структура(Реквизиты);
		ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Тогда
			Результат = Новый Структура(СтрСоединить(Реквизиты, ","));
		Иначе
			ТекстИсключения = НСтр("ru = 'Неверный тип параметра ""Реквизиты""'");
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
		МетаданныеОбъекта = Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)); // ОбъектМетаданныхДокумент - 
		
		Если МетаданныеОбъекта = Неопределено Тогда
			ТекстИсключения = НСтр("ru = 'Переданное значение не является ссылкой'");
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
		Для Каждого КлючЗначение Из Результат Цикл
			
			МетаданныеРеквизита = МетаданныеОбъекта.Реквизиты.Найти(КлючЗначение.Ключ);
			
			Если МетаданныеРеквизита = Неопределено Тогда
				
				Для Каждого СтандартныйРеквизит Из  МетаданныеОбъекта.СтандартныеРеквизиты Цикл
					Если СтандартныйРеквизит.Имя = КлючЗначение.Ключ Тогда
						МетаданныеРеквизита = СтандартныйРеквизит;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если МетаданныеРеквизита = Неопределено Тогда 
					
					ТекстИсключения = НСтр("ru = 'Реквизит %ИмяРеквизита% не найден'");
					ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяРеквизита%", КлючЗначение.Ключ);
					ВызватьИсключение ТекстИсключения;
				КонецЕсли;
				
			КонецЕсли;
			
			Результат[КлючЗначение.Ключ] = МетаданныеРеквизита.Тип.ПривестиЗначение();	
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Обходит реквизиты и стандартные реквизиты объекта метаданных и создает структуру с такими же полями.
//
// Параметры:
//	ОбъектМетаданных - ОбъектМетаданных - объект метаданных, используемый в качестве источника копирования свойств.
//
// Возвращаемое значение:
//	Структура - структура, свойствами которой являются реквизиты источника копирования.
//
Функция СтруктураСоСвойствамиОбъектаМетаданных(ОбъектМетаданных) Экспорт
	
	СтруктураСоСвойствамиОбъектаМетаданных = Новый Структура;
	
	Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
		СтруктураСоСвойствамиОбъектаМетаданных.Вставить(Реквизит.Имя, Реквизит.Тип.ПривестиЗначение());
	КонецЦикла;
	
	Для Каждого Реквизит Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
		СтруктураСоСвойствамиОбъектаМетаданных.Вставить(Реквизит.Имя, Реквизит.Тип.ПривестиЗначение());
	КонецЦикла;
	
	Возврат СтруктураСоСвойствамиОбъектаМетаданных;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область НастройкиФорм

// Устанавливает параметры контекстных функциональных опций формы.
//
Процедура НастроитьФормуПоПараметрам(Форма, ПараметрыНастройки) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	НастройкиФорм.Ссылка
	|ИЗ
	|	Справочник.ПараметрыКонтекстныхФункциональныхОпций КАК НастройкиФорм
	|ГДЕ
	|	ИСТИНА";
	
	Для каждого ПараметрНастройки Из ПараметрыНастройки Цикл
	
		ТекстЗапроса = ТекстЗапроса + " 
		|	И НастройкиФорм." + ПараметрНастройки.Ключ + " = &" + ПараметрНастройки.Ключ;
		Запрос.УстановитьПараметр(ПараметрНастройки.Ключ, ПараметрНастройки.Значение);
	
	КонецЦикла;
	
	Запрос.Текст = ТекстЗапроса;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		
		Настройка = Выборка.Ссылка;
		
	Иначе
		
		СправочникОбъект = Справочники.ПараметрыКонтекстныхФункциональныхОпций.СоздатьЭлемент();
		
		ЗаполнитьЗначенияСвойств(СправочникОбъект, ПараметрыНастройки);
		
		СправочникОбъект.Записать();
		
		Настройка = СправочникОбъект.Ссылка;
		
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Форма.УстановитьПараметрыФункциональныхОпцийФормы(Новый Структура("НастройкаФормы", Настройка));
	
КонецПроцедуры

// Служебная процедура.
//
Процедура ИнициализироватьРеквизитыФормыДляПолнотекстовогоПоиска(Форма, ИмяФОИспользованияППД) Экспорт
	
	Форма.ИнформационнаяБазаФайловая      = ОбщегоНазначения.ИнформационнаяБазаФайловая();
	Форма.ИспользоватьПолнотекстовыйПоиск = ОбщегоНазначенияУТВызовСервера.ИспользуетсяПолнотекстовыйПоиск(ИмяФОИспользованияППД);
	
	Если Форма.ИспользоватьПолнотекстовыйПоиск Тогда
			
		Форма.ИндексПолнотекстовогоПоискаАктуален = ПолнотекстовыйПоискСервер.ИндексПоискаАктуален();
		
	КонецЕсли;
	
КонецПроцедуры

// Служебная процедура.
//
Процедура ПересчитатьТаблицуТоваровВВалютуРегл(МенеджерВременныхТаблиц) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	*
	|ИЗ
	|	ТаблицаТоваровПредварительная
	|
	|ИТОГИ
	|	СУММА(ТаблицаТоваровПредварительная.СуммаБезНДС),
	|	СУММА(ТаблицаТоваровПредварительная.СуммаНДС),
	|	МАКСИМУМ(ТаблицаТоваровПредварительная.Валюта),
	|	МАКСИМУМ(ТаблицаТоваровПредварительная.Дата)
	|ПО
	|	ТаблицаТоваровПредварительная.Ссылка
	|";
	РезультатЗапроса = Запрос.Выполнить();
	
	ПересчитанныеСуммыДокументов = Новый ТаблицаЗначений;
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		ПересчитанныеСуммыДокументов.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	
	ВалютаРегл = Константы.ВалютаРегламентированногоУчета.Получить();
	КэшКурсовВалют = РаботаСКурсамиВалютУТ.ИнициализироватьКэшКурсовВалют();
	
	ВыборкаПоДокументу = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаПоДокументу.Следующий() Цикл
		
		КурсВалютыДокумента = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ВыборкаПоДокументу.Валюта, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
		КурсВалютыРегл      = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ВалютаРегл, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
		
		СуммаДокумента     = ВыборкаПоДокументу.СуммаБезНДС + ВыборкаПоДокументу.СуммаНДС;
		СуммаДокументаРегл = СуммаДокумента * КурсВалютыДокумента / КурсВалютыРегл;
		
		УчтеноБазыРаспределения = 0;
		УжеРаспределено = 0;
		
		Выборка = ВыборкаПоДокументу.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			СуммаСНДС = Выборка.СуммаБезНДС + Выборка.СуммаНДС;
			
			СуммаСНДСРегл = ?(СуммаДокумента <> 0, Окр(СуммаДокументаРегл * (УчтеноБазыРаспределения + СуммаСНДС) / СуммаДокумента, 2) - УжеРаспределено, 0);
			
			УчтеноБазыРаспределения = УчтеноБазыРаспределения + СуммаСНДС;
			УжеРаспределено         = УжеРаспределено + СуммаСНДСРегл;
			
			НоваяЗапись = ПересчитанныеСуммыДокументов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяЗапись, Выборка, , "СуммаНДС, СуммаБезНДС");
			
			НоваяЗапись.СуммаНДС    = ЦенообразованиеКлиентСервер.РассчитатьСуммуНДС(СуммаСНДСРегл, Выборка.СтавкаНДС);
			НоваяЗапись.СуммаБезНДС = СуммаСНДСРегл - НоваяЗапись.СуммаНДС;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Запрос.Текст = "
	|УНИЧТОЖИТЬ ТаблицаТоваровПредварительная;
	|ВЫБРАТЬ";
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		Запрос.Текст = Запрос.Текст + "
		|Таблица." + Колонка.Имя + ",";
	КонецЦикла;
	Запрос.Текст = Лев(Запрос.Текст, СтрДлина(Запрос.Текст)-1);
	Запрос.Текст = Запрос.Текст + "
	|ПОМЕСТИТЬ ТаблицаТоваровПредварительная
	|ИЗ &Таблица КАК Таблица";
	Запрос.УстановитьПараметр("Таблица", ПересчитанныеСуммыДокументов);
	Запрос.Выполнить();
	
КонецПроцедуры

// Служебная процедура.
//
Процедура ПересчитатьТаблицуТоваровВВалюты(МенеджерВременныхТаблиц, ВалютыДляПересчета, ИмяТаблицыТоваров = "ТаблицаТоваровПредварительная") Экспорт
	
	ПоказателиДляПересчета = "СуммаБезНДС, СуммаНДС";

	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	*
	|ИЗ
	|	%1 КАК ТаблицаТоваров 
	|
	|ИТОГИ
	|	СУММА(ТаблицаТоваров.СуммаБезНДС),
	|	СУММА(ТаблицаТоваров.СуммаНДС),
	|	МАКСИМУМ(ТаблицаТоваров.Валюта),
	|	МАКСИМУМ(ТаблицаТоваров.Дата)
	|ПО
	|	ТаблицаТоваров.Ссылка
	|";
	ТекстЗапроса = СтрШаблон(ТекстЗапроса, ИмяТаблицыТоваров);
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст = ТекстЗапроса;
	РезультатЗапроса = Запрос.Выполнить();
	
	ПересчитанныеСуммыДокументов = Новый ТаблицаЗначений;
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		ПересчитанныеСуммыДокументов.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	
	МассивПоказателей = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПоказателиДляПересчета, ",", , Истина);
	Для каждого ПоказательДляПересчета Из МассивПоказателей Цикл
		ИсходнаяКолонка = ПересчитанныеСуммыДокументов.Колонки.Найти(ПоказательДляПересчета);
		Если ИсходнаяКолонка = Неопределено ИЛИ Не ИсходнаяКолонка.ТипЗначения.СодержитТип(Тип("Число")) Тогда
			Продолжить;
		КонецЕсли;
		Для каждого ВалютаВКоторуюПересчитываем Из ВалютыДляПересчета Цикл
			ПересчитанныеСуммыДокументов.Колонки.Добавить(ИсходнаяКолонка.Имя + ВалютаВКоторуюПересчитываем.Ключ, ИсходнаяКолонка.ТипЗначения);
		КонецЦикла;
	КонецЦикла;
	
	КэшКурсовВалют = РаботаСКурсамиВалютУТ.ИнициализироватьКэшКурсовВалют();
	СтруктураВалют = Новый Структура;
	Для каждого ВалютаДляПересчета Из ВалютыДляПересчета Цикл
		Если ТипЗнч(ВалютаДляПересчета.Значение) = Тип("СправочникСсылка.Валюты") Тогда
			ДанныеПоВалюте = Новый Структура("Валюта, ОбщаяСумма, Распределено", ВалютаДляПересчета.Значение, 0, 0);
			СтруктураВалют.Вставить(ВалютаДляПересчета.Ключ, ДанныеПоВалюте);
		КонецЕсли;
	КонецЦикла;
	
	ВыборкаПоДокументу = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаПоДокументу.Следующий() Цикл
		
		КурсВалютыДокумента = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ВыборкаПоДокументу.Валюта, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
		ОбщаяСумма          = ВыборкаПоДокументу.СуммаБезНДС + ВыборкаПоДокументу.СуммаНДС;
		ОбщаяСуммаБезНДС	= ВыборкаПоДокументу.СуммаБезНДС;
		ОбщаяСуммаНДС		= ВыборкаПоДокументу.СуммаНДС;
		Распределено        = 0;
		
		Для каждого ТекущаяВалютаДляПересчета Из СтруктураВалют Цикл
			Валюта = ТекущаяВалютаДляПересчета.Значение.Валюта;
			Если Валюта <> ВыборкаПоДокументу.Валюта Тогда
				КурсВалюты = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(Валюта, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
				ТекущаяВалютаДляПересчета.Значение.ОбщаяСумма = ОбщаяСумма * КурсВалютыДокумента / КурсВалюты;
				ТекущаяВалютаДляПересчета.Значение.Распределено = 0;
			КонецЕсли;
		КонецЦикла;
		
		Выборка = ВыборкаПоДокументу.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			Сумма = Выборка.СуммаБезНДС + Выборка.СуммаНДС;
			
			НоваяЗапись = ПересчитанныеСуммыДокументов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяЗапись, Выборка);
			
			Если ОбщаяСуммаБезНДС = 0 И ОбщаяСуммаНДС = 0 Тогда
				
				Для каждого ТекущаяВалютаДляПересчета Из СтруктураВалют Цикл
					НоваяЗапись["СуммаНДС"+ТекущаяВалютаДляПересчета.Ключ] = 0;
					НоваяЗапись["СуммаБезНДС"+ТекущаяВалютаДляПересчета.Ключ] = 0;
				КонецЦикла;
				
				Продолжить;
				
			КонецЕсли;
			
			Для каждого ТекущаяВалютаДляПересчета Из СтруктураВалют Цикл
				
				ДанныеВалюты = ТекущаяВалютаДляПересчета.Значение;
				
				Если ДанныеВалюты.Валюта = Выборка.Валюта Тогда
					ВалютнаяСумма = Сумма;
					ВалютнаяСуммаНДС = Выборка.СуммаНДС;
				ИначеЕсли ОбщаяСумма <> 0 Тогда 
					ВалютнаяСумма = Окр(ДанныеВалюты.ОбщаяСумма * (Распределено + Сумма) / ОбщаяСумма, 2) - ДанныеВалюты.Распределено;
					ДанныеВалюты.Распределено = ДанныеВалюты.Распределено + ВалютнаяСумма;
					ВалютнаяСуммаНДС = ЦенообразованиеКлиентСервер.РассчитатьСуммуНДС(ВалютнаяСумма, Выборка.СтавкаНДС);
				Иначе
					КурсВалюты = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ДанныеВалюты.Валюта, Выборка.Дата, КэшКурсовВалют);
					ВалютнаяСумма = Сумма * КурсВалютыДокумента / КурсВалюты;
					ВалютнаяСуммаНДС = Выборка.СуммаНДС * КурсВалютыДокумента / КурсВалюты;
				КонецЕсли;
				
				НоваяЗапись["СуммаНДС"+ТекущаяВалютаДляПересчета.Ключ] = ВалютнаяСуммаНДС;
				НоваяЗапись["СуммаБезНДС"+ТекущаяВалютаДляПересчета.Ключ] = ВалютнаяСумма - ВалютнаяСуммаНДС;
				
			КонецЦикла;
			
			Распределено = Распределено + Сумма;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Поместим результат во временную таблицу
	МассивПолейВыборки = Новый Массив;
	Для Каждого Колонка Из ПересчитанныеСуммыДокументов.Колонки Цикл
		МассивПолейВыборки.Добавить(Колонка.Имя);
	КонецЦикла;
	ТекстПолейВыборки = СтрСоединить(МассивПолейВыборки, ",");
	
	ТекстЗапроса = "
	|УНИЧТОЖИТЬ %1
	|;
	|ВЫБРАТЬ
	|	%2
	|ПОМЕСТИТЬ %1
	|ИЗ 
	|	&Таблица КАК Таблица";
	ТекстЗапроса = СтрШаблон(ТекстЗапроса, ИмяТаблицыТоваров, ТекстПолейВыборки);
	
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Таблица", ПересчитанныеСуммыДокументов);
	
	Запрос.Выполнить();
	
КонецПроцедуры

// Удаляет повторяющиеся элементы массива.
//
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМассиве 		   = Новый Соответствие; 
		БылоНеопределено 	   = Ложь;
		КоличествоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КоличествоЭлементовВМассиве Цикл 
			
			ЭлементМассива = Массив[КоличествоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента    = ТипЗнч(ЭлементМассива); 
			
			Если ЭлементМассива = Неопределено Тогда
				
				Если БылоНеопределено ИЛИ НеИспользоватьНеопределено Тогда
					Массив.Удалить(КоличествоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				
				Продолжить;
				
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМассиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КоличествоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМассиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
			
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

// Функция возвращает представление клавиши
// Параметры:
//	ЗначениеКлавиша						- Клавиша
//
// Возвращаемое значение
//	Строка - Представление клавиши.
//
Функция ПредставлениеКлавиши(ЗначениеКлавиша) Экспорт
	
	Если Строка(Клавиша._1) = Строка(ЗначениеКлавиша) Тогда
		Возврат "1";
	ИначеЕсли Строка(Клавиша._2) = Строка(ЗначениеКлавиша) Тогда
		Возврат "2";
	ИначеЕсли Строка(Клавиша._3) = Строка(ЗначениеКлавиша) Тогда
		Возврат "3";
	ИначеЕсли Строка(Клавиша._4) = Строка(ЗначениеКлавиша) Тогда
		Возврат "4";
	ИначеЕсли Строка(Клавиша._5) = Строка(ЗначениеКлавиша) Тогда
		Возврат "5";
	ИначеЕсли Строка(Клавиша._6) = Строка(ЗначениеКлавиша) Тогда
		Возврат "6";
	ИначеЕсли Строка(Клавиша._7) = Строка(ЗначениеКлавиша) Тогда
		Возврат "7";
	ИначеЕсли Строка(Клавиша._8) = Строка(ЗначениеКлавиша) Тогда
		Возврат "8";
	ИначеЕсли Строка(Клавиша._9) = Строка(ЗначениеКлавиша) Тогда
		Возврат "9";
	ИначеЕсли Строка(Клавиша.Num0) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 0";
	ИначеЕсли Строка(Клавиша.Num1) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 1";
	ИначеЕсли Строка(Клавиша.Num2) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 2";
	ИначеЕсли Строка(Клавиша.Num3) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 3";
	ИначеЕсли Строка(Клавиша.Num4) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 4";
	ИначеЕсли Строка(Клавиша.Num5) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 5";
	ИначеЕсли Строка(Клавиша.Num6) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 6";
	ИначеЕсли Строка(Клавиша.Num7) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 7";
	ИначеЕсли Строка(Клавиша.Num8) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 8";
	ИначеЕсли Строка(Клавиша.Num9) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 9";
	ИначеЕсли Строка(Клавиша.NumAdd) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num +";
	ИначеЕсли Строка(Клавиша.NumDecimal) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num .";
	ИначеЕсли Строка(Клавиша.NumDivide) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num /";
	ИначеЕсли Строка(Клавиша.NumMultiply) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num *";
	ИначеЕсли Строка(Клавиша.NumSubtract) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num -";
	Иначе
		Возврат Строка(ЗначениеКлавиша);
	КонецЕсли;
	
КонецФункции

// Функция возвращает представление клавиши
// Параметры:
//	СочетаниеКлавиш						- Сочетание клавиш для которого нужно сформировать представление
//	БезСкобок							- Флаг, указывающий, что представление должно быть сформировано без скобок.
//
// Возвращаемое значение
//	Строка - Представление сочетания клавиш.
//
Функция ПредставлениеСочетанияКлавиш(СочетаниеКлавиш, БезСкобок = Ложь) Экспорт
	
	Если СочетаниеКлавиш.Клавиша = Клавиша.Нет Тогда
		Возврат "";
	КонецЕсли;
	
	Наименование = ?(БезСкобок, "", "(");
	Если СочетаниеКлавиш.Ctrl Тогда
		Наименование = Наименование + "Ctrl+"
	КонецЕсли;
	Если СочетаниеКлавиш.Alt Тогда
		Наименование = Наименование + "Alt+"
	КонецЕсли;
	Если СочетаниеКлавиш.Shift Тогда
		Наименование = Наименование + "Shift+"
	КонецЕсли;
	Наименование = Наименование + ПредставлениеКлавиши(СочетаниеКлавиш.Клавиша) + ?(БезСкобок, "", ")");
	
	Возврат Наименование;
	
КонецФункции

// Устанавливает свойство ОтображениеСтраницФормы в Нет, если фактически отображается только одна закладка
// Параметры:
//  ЭлементСтраница  - ГруппаФормы - страница, для которой определяется необходимость отображения закладок.
//
Процедура УдалитьЗакладкиЕслиСтраницаОдна(ЭлементСтраница) Экспорт
	
	Если ЭлементСтраница.ПодчиненныеЭлементы.Количество() = 1 Тогда
		ЭлементСтраница.ОтображениеСтраниц = ОтображениеСтраницФормы.Нет;
	Иначе
		КоличествоВидимыхСтраниц = 0;
		Для Каждого ПодчиненнаяСтраница Из ЭлементСтраница.ПодчиненныеЭлементы Цикл
			
			Если КоличествоВидимыхСтраниц > 1 Тогда
				Прервать;
			КонецЕсли;
			
			Для Каждого ЭлементСтраницы Из ПодчиненнаяСтраница.ПодчиненныеЭлементы Цикл
				
				Если ЭлементСтраницы.Видимость Тогда
					КоличествоВидимыхСтраниц = КоличествоВидимыхСтраниц + 1;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
		Если КоличествоВидимыхСтраниц = 1 Тогда
			ЭлементСтраница.ОтображениеСтраниц = ОтображениеСтраницФормы.Нет;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Служебная процедура.
//
Процедура ПересчитатьТаблицуТоваровВВалютуУпр(МенеджерВременныхТаблиц) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	*
	|ИЗ
	|	ТаблицаТоваровВВалютеУпр
	|
	|ИТОГИ
	|	СУММА(ТаблицаТоваровВВалютеУпр.СуммаБезНДС),
	|	СУММА(ТаблицаТоваровВВалютеУпр.СуммаНДС),
	|	МАКСИМУМ(ТаблицаТоваровВВалютеУпр.Валюта),
	|	МАКСИМУМ(ТаблицаТоваровВВалютеУпр.Дата)
	|ПО
	|	ТаблицаТоваровВВалютеУпр.Ссылка
	|";
	РезультатЗапроса = Запрос.Выполнить();
	
	ПересчитанныеСуммыДокументов = Новый ТаблицаЗначений;
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		ПересчитанныеСуммыДокументов.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	        
	ВалютаУпр = Константы.ВалютаУправленческогоУчета.Получить();
	КэшКурсовВалют = РаботаСКурсамиВалютУТ.ИнициализироватьКэшКурсовВалют();
	
	ВыборкаПоДокументу = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаПоДокументу.Следующий() Цикл
		
		КурсВалютыДокумента = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ВыборкаПоДокументу.Валюта, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
		КурсВалютыУпр      = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ВалютаУпр, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
		
		СуммаДокумента     = ВыборкаПоДокументу.СуммаБезНДС + ВыборкаПоДокументу.СуммаНДС;
		СуммаДокументаРегл = СуммаДокумента * КурсВалютыДокумента / КурсВалютыУпр;
		
		УчтеноБазыРаспределения = 0;
		УжеРаспределено = 0;
		
		Выборка = ВыборкаПоДокументу.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			СуммаСНДС = Выборка.СуммаБезНДС + Выборка.СуммаНДС;
			
			СуммаСНДСРегл = ?(СуммаДокумента <> 0, Окр(СуммаДокументаРегл * (УчтеноБазыРаспределения + СуммаСНДС) / СуммаДокумента, 2) - УжеРаспределено, 0);
			
			УчтеноБазыРаспределения = УчтеноБазыРаспределения + СуммаСНДС;
			УжеРаспределено         = УжеРаспределено + СуммаСНДСРегл;
			
			НоваяЗапись = ПересчитанныеСуммыДокументов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяЗапись, Выборка, , "СуммаНДС, СуммаБезНДС");
			
			НоваяЗапись.СуммаНДС    = ЦенообразованиеКлиентСервер.РассчитатьСуммуНДС(СуммаСНДСРегл, Выборка.СтавкаНДС);
			НоваяЗапись.СуммаБезНДС = СуммаСНДСРегл - НоваяЗапись.СуммаНДС;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Запрос.Текст = "
	|УНИЧТОЖИТЬ ТаблицаТоваровВВалютеУпр;
	|ВЫБРАТЬ";
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		Запрос.Текст = Запрос.Текст + "
		|Таблица." + Колонка.Имя + ",";
	КонецЦикла;
	Запрос.Текст = Лев(Запрос.Текст, СтрДлина(Запрос.Текст)-1);
	Запрос.Текст = Запрос.Текст + "
	|ПОМЕСТИТЬ ТаблицаТоваровВВалютеУпр
	|ИЗ &Таблица КАК Таблица";
	Запрос.УстановитьПараметр("Таблица", ПересчитанныеСуммыДокументов);
	Запрос.Выполнить();
	
КонецПроцедуры

#КонецОбласти

#Область ЗаполненияТабличныхЧастейДокумента

// Функция возвращает параметры проверки заполнения количества
// 
// Возвращаемое значение:
//  Структура - структура параметров:
//  	*ИмяТЧ - Строка - значение по умолчанию "Товары"
//  	*СуффиксДопРеквизита - Строка - значение по умолчанию "" - если в ТЧ два реквизита "Количество", то второй назван с суффиксом.
//  		если суффикс передан, то проверяются оба реквизита
//  	*ПроверитьВозможностьОкругления - Булево - Истина если нужно проверить возможность округления
//  	*УсловиеОтбораСтрокДляОкругления - Строка - Условие выбора строк для проверки округления.
//  		в качестве имени таблицы нужно использовать имя переданное в ИмяТЧ
//  	*ПроверитьКомплектностьТоварныхМест - Булево - Флаг необходимости проверки комплектности товарных есть.
//  	*УсловиеОтбораСтрокПроверкиКомплектности - Строка - строка условия для запроса. Например, "Не ТаблицаТовары.ЭтоУпаковочныйЛист"
//  	*ПоляГруппировкиПроверкиКомплектности - Строка - Поля, по которым группируются товары для формирования целых товаров из товарных мест. 
//			Поля "Номенклатура", "Характеристика" и "Серия" будут добавлены по умолчанию. 
//			Поле "<Приставка>Назначение" нужно добавлять, если имя колонки отлично от строки "Назначение". Например, "НовоеНазначение".
//  	*ПроверяемаяТаблица - ТаблицаЗначений, Неопределено - если передана таблица значений, то проверяется она, иначе - Объект или ТЧ по ИмяТЧ			
//		*УсловиеОтбораСтрокПоДополнительнымПолям - Строка - сложная условие отбора строк, 
//															как пример <таблица>.<поле>.<поле> или <таблица>.<поле> В (ВЫБРТАЬ ....),
//															в качестве имени таблицы нужно использовать имя переданное в ИмяТЧ
//		*ДополнительныеПоля - Структура - поля, участвующие в сложном условие отборе строк, 
//										  в качестве имени таблицы нужно использовать имя переданное в ИмяТЧ
//									    - ключ: имя поля
//									      значение: представление поля в запросе   	
//
Функция ПараметрыПроверкиЗаполненияКоличества() Экспорт
	
	ПараметрыПроверки = Новый Структура;
	ПараметрыПроверки.Вставить("ИмяТЧ",                           		  "Товары");
	ПараметрыПроверки.Вставить("ПредставлениеТЧ",                         "");
	ПараметрыПроверки.Вставить("ПутьКДанным",                             "Объект");
	ПараметрыПроверки.Вставить("СуффиксДопРеквизита",             		  "");
	ПараметрыПроверки.Вставить("ПроверитьВозможностьОкругления",  		  Истина);
	ПараметрыПроверки.Вставить("УсловиеОтбораСтрокДляОкругления", 		  "");
	ПараметрыПроверки.Вставить("ПроверитьКомплектностьТоварныхМест", 	  Ложь);
	ПараметрыПроверки.Вставить("УсловиеОтбораСтрокПроверкиКомплектности", "");
	ПараметрыПроверки.Вставить("ПоляГруппировкиПроверкиКомплектности", 	  "");
	ПараметрыПроверки.Вставить("ПроверяемаяТаблица", 	                  Неопределено);
	ПараметрыПроверки.Вставить("УсловиеОтбораСтрокПоДополнительнымПолям", "");
	ПараметрыПроверки.Вставить("ДополнительныеПоля", 					  Новый Структура);
	
	Возврат ПараметрыПроверки;
	
КонецФункции

// Процедуры проверки заполнения реквизита Количество и КоличествоУпаковок в документах.
// Параметры:
//	Объект - проверяемый ДокументОбъект
//	ПроверяемыеРеквизиты - массив проверяемых реквизитов
//	Отказ - отказ продолжения операции.
Процедура ПроверитьЗаполнениеКоличества(Объект, ПроверяемыеРеквизиты, Отказ, ПараметрыПроверки = Неопределено) Экспорт
	
	Перем ЗаполнятьРеквизитОбязательно;
	Перем ЗаполнятьДопРеквизитОбязательно;
	
	Если ПараметрыПроверки = Неопределено Тогда
		ПараметрыПроверки = ПараметрыПроверкиЗаполненияКоличества();
	КонецЕсли;
	
	ИмяТЧ               = ПараметрыПроверки.ИмяТЧ;
	СуффиксДопРеквизита = ПараметрыПроверки.СуффиксДопРеквизита;
	
	КлючДанных = КлючДанныхДляСообщенияПользователю(Объект);
	
	Если ИмяТЧ = "Объект" Тогда
		
		ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти("Количество"));
		ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти("КоличествоУпаковок"));

		Если Объект.Количество = 0 И Объект.КоличествоУпаковок <> 0 Тогда

			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = 'Обнаружено нулевое количество при пересчете в единицу хранения'"),
					КлючДанных,
					"КоличествоУпаковок",
					,
					Отказ);

		ИначеЕсли Объект.Количество = 0 Или Объект.КоличествоУпаковок = 0 Тогда

			ТекстСообщения = НСтр("ru = 'Не заполнено поле ""%ПредставлениеПоляКоличество%""'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеПоляКоличество%", Объект.Метаданные().Реквизиты.Количество.Синоним);
			
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,
					КлючДанных,
					"КоличествоУпаковок",
					,
					Отказ);
				
		КонецЕсли;
	Иначе
		МетаданныеОбъекта = Объект.Метаданные();
		                                 
		РеквизитПроверки =  ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".КоличествоУпаковок");
		ЗаполнятьРеквизитОбязательно = РеквизитПроверки <> Неопределено;
		Если РеквизитПроверки <> Неопределено Тогда
			ПроверяемыеРеквизиты.Удалить(РеквизитПроверки);
			ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".Количество"));
		КонецЕсли;
		
		ПредставлениеТЧ = ?(ПараметрыПроверки.ПредставлениеТЧ = "",
			МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Синоним,
			ПараметрыПроверки.ПредставлениеТЧ);
		
		ПредставлениеРеквизитаКоличествоУпаковок = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты.КоличествоУпаковок.Синоним;
		Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
			РеквизитПроверки =  ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".КоличествоУпаковок"+СуффиксДопРеквизита);
			ЗаполнятьДопРеквизитОбязательно = РеквизитПроверки <> Неопределено;
			Если РеквизитПроверки <> Неопределено Тогда
				ПроверяемыеРеквизиты.Удалить(РеквизитПроверки);
				ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".Количество"+СуффиксДопРеквизита));
			КонецЕсли;
			ПредставлениеРеквизитаКоличествоУпаковокДоп  = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты["КоличествоУпаковок"+СуффиксДопРеквизита].Синоним;
		Иначе
			ЗаполнятьДопРеквизитОбязательно = Ложь;
			ПредставлениеРеквизитаКоличествоУпаковокДоп = "";
		КонецЕсли;
		
		ШаблонОшибкаКоличества = НСтр("ru = 'Не заполнена колонка ""%ПредставлениеКолонки%"" в строке %НомерСтроки% списка ""%ПредставлениеТЧ%""'");
		ШаблонОшибкаКоличества = СтрЗаменить(ШаблонОшибкаКоличества, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		ШаблонОшибкаПересчета = НСтр("ru = 'Обнаружено нулевое количество при пересчете в единицу хранения в строке %НомерСтроки% списка ""%ПредставлениеТЧ%""'");
		ШаблонОшибкаПересчета = СтрЗаменить(ШаблонОшибкаПересчета, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		
		Для Каждого СтрокаТаб Из Объект[ИмяТЧ] Цикл
			
			Если СтрокаТаб.Количество = 0 
				И СтрокаТаб.КоличествоУпаковок <> 0 Тогда
				
				ТекстСообщения = СтрЗаменить(ШаблонОшибкаПересчета, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки, "КоличествоУпаковок");
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,ПараметрыПроверки.ПутьКДанным,Отказ);
				
			ИначеЕсли ЗаполнятьРеквизитОбязательно
				И (СтрокаТаб.Количество = 0
				Или СтрокаТаб.КоличествоУпаковок = 0) Тогда
				
				ТекстСообщения = СтрЗаменить(ШаблонОшибкаКоличества, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеКолонки%", ПредставлениеРеквизитаКоличествоУпаковок);
				
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки, "КоличествоУпаковок");
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,ПараметрыПроверки.ПутьКДанным,Отказ);
						
			КонецЕсли;
			
			
			Если Не ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
				Продолжить;
			КонецЕсли;
			
			Если СтрокаТаб["Количество"+СуффиксДопРеквизита] = 0 
				И СтрокаТаб["КоличествоУпаковок"+СуффиксДопРеквизита] <> 0 Тогда
				
				ТекстСообщения = СтрЗаменить(ШаблонОшибкаПересчета, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
				
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки, "КоличествоУпаковок"+СуффиксДопРеквизита);
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,ПараметрыПроверки.ПутьКДанным,Отказ);
				
			ИначеЕсли ЗаполнятьДопРеквизитОбязательно
				И (СтрокаТаб["Количество"+СуффиксДопРеквизита] = 0
				Или СтрокаТаб["КоличествоУпаковок"+СуффиксДопРеквизита]  = 0) Тогда
				
				ТекстСообщения = СтрЗаменить(ШаблонОшибкаКоличества, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеКолонки%", ПредставлениеРеквизитаКоличествоУпаковокДоп);
				
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки,"КоличествоУпаковок"+СуффиксДопРеквизита);
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,ПараметрыПроверки.ПутьКДанным,Отказ);
						
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	ПроверитьОкруглениеКоличества(Объект, Отказ, ПараметрыПроверки);
	
	Если ПараметрыПроверки.ПроверитьКомплектностьТоварныхМест Тогда 
		НоменклатураСервер.ПроверитьКомплектностьТоварныхМест(Объект[ИмяТЧ], Отказ, ПараметрыПроверки);
	КонецЕсли;
	
КонецПроцедуры

// Процедура проверки округления реквизита Количество в документах.
// 
// Параметры:
//	Объект 			  - ДокументОбъект 			- проверяемый ДокументОбъект
//	Отказ  			  - Булево 					- отказ продолжения операции.
//	ПараметрыПроверки - Структура, Неопределено - см. ОбщегоНазначенияУТ.ПараметрыПроверкиЗаполненияКоличества()
//
Процедура ПроверитьОкруглениеКоличества(Объект, Отказ, ПараметрыПроверки = Неопределено) Экспорт

	Если ПараметрыПроверки = Неопределено Тогда
		ПараметрыПроверки = ПараметрыПроверкиЗаполненияКоличества();
	КонецЕсли;
	
	ИмяТЧ               = ПараметрыПроверки.ИмяТЧ;
	СуффиксДопРеквизита = ПараметрыПроверки.СуффиксДопРеквизита;
	
	КлючДанных = КлючДанныхДляСообщенияПользователю(Объект);

	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ТЧ.НомерСтроки КАК НомерСтроки,
	|	ТЧ.Номенклатура КАК Номенклатура,
	|	ТЧ.КоличествоУпаковок КАК КоличествоУпаковок,
	|	ТЧ.Количество КАК КоличествоВДокументе,
	|	ВЫРАЗИТЬ(ТЧ.Упаковка КАК Справочник.УпаковкиЕдиницыИзмерения) КАК Упаковка,
	|	&ИмяПоляКоличествоУпаковокСуффикс КАК КоличествоУпаковокСуффикс,
	|	&ИмяПоляКоличествоСуффикс КАК КоличествоВДокументеСуффикс,
	|	&ДополнительныеПоля
	|ПОМЕСТИТЬ ВТДляЗапроса
	|ИЗ
	|	&ТЧ КАК ТЧ
	|ГДЕ
	|	ТЧ.Упаковка <> ЗНАЧЕНИЕ(Справочник.УпаковкиЕдиницыИзмерения.ПустаяСсылка)
	|	И &УсловиеОтбораСтрокДляОкругления
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТДляЗапроса.НомерСтроки,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.Упаковка КАК Справочник.УпаковкиЕдиницыИзмерения).ТипИзмеряемойВеличины В (&МерныеТипы) КАК МожноОкруглять,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.Номенклатура КАК Справочник.Номенклатура).ЕдиницаИзмерения КАК БазоваяЕдиницаИзмерения,
	|	ВТДляЗапроса.Номенклатура,
	|	ВТДляЗапроса.Упаковка,
	|	&ТекстЗапросаКоэффициентУпаковки КАК КоэффициентУпаковки,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.КоличествоУпаковок * &ТекстЗапросаКоэффициентУпаковки КАК ЧИСЛО(15, 3)) КАК Количество,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.КоличествоУпаковок * &ТекстЗапросаКоэффициентУпаковки КАК ЧИСЛО(15, 0)) КАК КоличествоОкругленное,
	|	ВТДляЗапроса.КоличествоВДокументе КАК КоличествоВДокументе,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.КоличествоУпаковокСуффикс * &ТекстЗапросаКоэффициентУпаковки КАК ЧИСЛО(15, 3)) КАК КоличествоСуффикс,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.КоличествоУпаковокСуффикс * &ТекстЗапросаКоэффициентУпаковки КАК ЧИСЛО(15, 0)) КАК КоличествоСуффиксОкругленное,
	|	ВТДляЗапроса.КоличествоВДокументеСуффикс КАК КоличествоВДокументеСуффикс
	|ПОМЕСТИТЬ ВТ
	|ИЗ
	|	ВТДляЗапроса КАК ВТДляЗапроса  
	|ГДЕ
	|	ЕСТЬNULL(ВТДляЗапроса.Упаковка.ТипУпаковки, НЕОПРЕДЕЛЕНО) <> ЗНАЧЕНИЕ(Перечисление.ТипыУпаковокНоменклатуры.ТоварноеМесто)
	|	И ВЫРАЗИТЬ(ВТДляЗапроса.Номенклатура КАК Справочник.Номенклатура).ЕдиницаИзмерения.ТипИзмеряемойВеличины = &ШтучныйТип
	|	И &УсловиеОтбораСтрокПоДополнительнымПолям
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТЧ.НомерСтроки КАК НомерСтроки,
	|	ПРЕДСТАВЛЕНИЕ(ТЧ.БазоваяЕдиницаИзмерения) КАК БазоваяЕдиницаИзмерения,
	|	ПРЕДСТАВЛЕНИЕ(ТЧ.Упаковка) КАК Упаковка,
	|	ТЧ.КоличествоОкругленное КАК КоличествоОкругленное,
	|	ТЧ.КоличествоСуффиксОкругленное КАК КоличествоСуффиксОкругленное,
	|	ВЫРАЗИТЬ(ВЫБОР
	|			КОГДА &ПроверитьВозможностьОкругления
	|					И ТЧ.МожноОкруглять
	|				ТОГДА ВЫБОР
	|						КОГДА ТЧ.Количество - ТЧ.КоличествоОкругленное > 0
	|							ТОГДА ТЧ.Количество - ТЧ.КоличествоОкругленное
	|						ИНАЧЕ ТЧ.КоличествоОкругленное - ТЧ.Количество
	|					КОНЕЦ
	|			ИНАЧЕ ВЫБОР
	|					КОГДА ТЧ.КоличествоВДокументе - ТЧ.Количество > 0
	|						ТОГДА ТЧ.КоличествоВДокументе - ТЧ.Количество
	|					ИНАЧЕ ТЧ.Количество - ТЧ.КоличествоВДокументе
	|				КОНЕЦ
	|		КОНЕЦ / ТЧ.КоэффициентУпаковки КАК ЧИСЛО(15, 3)) КАК КоличествоОтклонение,
	|	ВЫРАЗИТЬ(ВЫБОР
	|			КОГДА &ПроверитьВозможностьОкругления
	|					И ТЧ.МожноОкруглять
	|				ТОГДА &ДопустимыйПроцентОтклонения * ТЧ.КоличествоОкругленное / ТЧ.КоэффициентУпаковки / 100
	|			ИНАЧЕ 0
	|		КОНЕЦ КАК ЧИСЛО(15, 3)) КАК КоличествоМаксимальнаяПогрешность,
	|	ВЫРАЗИТЬ(ВЫБОР
	|			КОГДА &ПроверитьВозможностьОкругления
	|				ТОГДА ВЫБОР
	|						КОГДА ТЧ.КоличествоСуффикс - ТЧ.КоличествоСуффиксОкругленное > 0
	|							ТОГДА ТЧ.КоличествоСуффикс - ТЧ.КоличествоСуффиксОкругленное
	|						ИНАЧЕ ТЧ.КоличествоСуффиксОкругленное - ТЧ.КоличествоСуффикс
	|					КОНЕЦ
	|			ИНАЧЕ ВЫБОР
	|					КОГДА ТЧ.КоличествоВДокументеСуффикс - ТЧ.КоличествоСуффикс > 0
	|						ТОГДА ТЧ.КоличествоВДокументеСуффикс - ТЧ.КоличествоСуффикс
	|					ИНАЧЕ ТЧ.КоличествоСуффикс - ТЧ.КоличествоВДокументеСуффикс
	|				КОНЕЦ
	|		КОНЕЦ / ТЧ.КоэффициентУпаковки КАК ЧИСЛО(15, 3)) КАК КоличествоСуффиксОтклонение,
	|	ВЫРАЗИТЬ(ВЫБОР
	|			КОГДА &ПроверитьВозможностьОкругления
	|					И ТЧ.МожноОкруглять
	|				ТОГДА &ДопустимыйПроцентОтклонения * ТЧ.КоличествоСуффиксОкругленное / ТЧ.КоэффициентУпаковки / 100
	|			ИНАЧЕ 0
	|		КОНЕЦ КАК ЧИСЛО(15, 3)) КАК КоличествоСуффиксМаксимальнаяПогрешность
	|ИЗ
	|	ВТ КАК ТЧ
	|ГДЕ
	|	((ВЫРАЗИТЬ(ВЫБОР
	|					КОГДА &ПроверитьВозможностьОкругления
	|							И ТЧ.МожноОкруглять
	|						ТОГДА ВЫБОР
	|								КОГДА ТЧ.Количество - ТЧ.КоличествоОкругленное > 0
	|									ТОГДА ТЧ.Количество - ТЧ.КоличествоОкругленное
	|								ИНАЧЕ ТЧ.КоличествоОкругленное - ТЧ.Количество
	|							КОНЕЦ
	|					ИНАЧЕ ВЫБОР
	|							КОГДА ТЧ.КоличествоВДокументе - ТЧ.Количество > 0
	|								ТОГДА ТЧ.КоличествоВДокументе - ТЧ.Количество
	|							ИНАЧЕ ТЧ.Количество - ТЧ.КоличествоВДокументе
	|						КОНЕЦ
	|				КОНЕЦ / ТЧ.КоэффициентУпаковки КАК ЧИСЛО(15, 3))) > (ВЫРАЗИТЬ(ВЫБОР
	|					КОГДА &ПроверитьВозможностьОкругления
	|							И ТЧ.МожноОкруглять
	|						ТОГДА &ДопустимыйПроцентОтклонения * ТЧ.КоличествоОкругленное / ТЧ.КоэффициентУпаковки / 100
	|					ИНАЧЕ 0
	|				КОНЕЦ КАК ЧИСЛО(15, 3)))
	|			ИЛИ (ВЫРАЗИТЬ(ВЫБОР
	|					КОГДА &ПроверитьВозможностьОкругления
	|							И ТЧ.МожноОкруглять
	|						ТОГДА ВЫБОР
	|								КОГДА ТЧ.КоличествоСуффикс - ТЧ.КоличествоСуффиксОкругленное > 0
	|									ТОГДА ТЧ.КоличествоСуффикс - ТЧ.КоличествоСуффиксОкругленное
	|								ИНАЧЕ ТЧ.КоличествоСуффиксОкругленное - ТЧ.КоличествоСуффикс
	|							КОНЕЦ
	|					ИНАЧЕ ВЫБОР
	|							КОГДА ТЧ.КоличествоВДокументеСуффикс - ТЧ.КоличествоСуффикс > 0
	|								ТОГДА ТЧ.КоличествоВДокументеСуффикс - ТЧ.КоличествоСуффикс
	|							ИНАЧЕ ТЧ.КоличествоСуффикс - ТЧ.КоличествоВДокументеСуффикс
	|						КОНЕЦ
	|				КОНЕЦ / ТЧ.КоэффициентУпаковки КАК ЧИСЛО(15, 3))) > (ВЫРАЗИТЬ(ВЫБОР
	|					КОГДА &ПроверитьВозможностьОкругления
	|							И ТЧ.МожноОкруглять
	|						ТОГДА &ДопустимыйПроцентОтклонения * ТЧ.КоличествоСуффиксОкругленное / ТЧ.КоэффициентУпаковки / 100
	|					ИНАЧЕ 0
	|				КОНЕЦ КАК ЧИСЛО(15, 3))))
	|
	|УПОРЯДОЧИТЬ ПО
	|	НомерСтроки";

	
	Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоСуффикс", "ТЧ.Количество"+СуффиксДопРеквизита);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоУпаковокСуффикс", "ТЧ.КоличествоУпаковок"+СуффиксДопРеквизита);
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоСуффикс", "0");
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоУпаковокСуффикс", "0");
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекстЗапросаКоэффициентУпаковки",
		Справочники.УпаковкиЕдиницыИзмерения.ТекстЗапросаКоэффициентаУпаковки(
			"ВТДляЗапроса.Упаковка",
			"ВТДляЗапроса.Номенклатура"));
			
	Если ПараметрыПроверки.УсловиеОтбораСтрокДляОкругления <> "" Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокДляОкругления", 
									СтрЗаменить(ПараметрыПроверки.УсловиеОтбораСтрокДляОкругления, ИмяТЧ + ".", "ТЧ."));
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокДляОкругления", "ИСТИНА");
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(ПараметрыПроверки.ДополнительныеПоля) Тогда
			
		Шаблон = "%1 КАК %2,
				 |%3";
		ТекстПолей = Шаблон;  			  
		Для каждого Поле Из ПараметрыПроверки.ДополнительныеПоля Цикл
			ТекстПолей = СтрШаблон(ТекстПолей, СтрЗаменить(Поле.Значение, ИмяТЧ + ".", "ТЧ."), Поле.Ключ, Шаблон);
		КонецЦикла;
			
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
			"&ДополнительныеПоля", 
			Сред(ТекстПолей, 1, СтрНайти(ТекстПолей, ",", НаправлениеПоиска.СКонца,, 2) - 1));
		
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ДополнительныеПоля", "ИСТИНА");
	КонецЕсли;	
		 
	Если ЗначениеЗаполнено(ПараметрыПроверки.УсловиеОтбораСтрокПоДополнительнымПолям) Тогда
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, 
			"&УсловиеОтбораСтрокПоДополнительнымПолям", 
			СтрЗаменить(ПараметрыПроверки.УсловиеОтбораСтрокПоДополнительнымПолям, ИмяТЧ + ".", "ВТДляЗапроса."));
		
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокПоДополнительнымПолям", "ИСТИНА");	
	КонецЕсли;	
			
	Если ПараметрыПроверки.ПроверитьВозможностьОкругления Тогда
		ДопустимыйПроцентОтклонения = Константы.ДопустимоеОтклонениеПриОкругленииКоличества.Получить();
	Иначе
		ДопустимыйПроцентОтклонения = 0;
	КонецЕсли;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Если ПараметрыПроверки.ПроверяемаяТаблица <> Неопределено Тогда
		Запрос.УстановитьПараметр("ТЧ", ПараметрыПроверки.ПроверяемаяТаблица);	
	ИначеЕсли ИмяТЧ = "Объект" Тогда
		
		Таблица = Новый ТаблицаЗначений;
		Таблица.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5,0,ДопустимыйЗнак.Неотрицательный)));	
		Таблица.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
		Таблица.Колонки.Добавить("Упаковка", Новый ОписаниеТипов("СправочникСсылка.УпаковкиЕдиницыИзмерения"));
		Таблица.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,3,ДопустимыйЗнак.Неотрицательный)));	
		Таблица.Колонки.Добавить("КоличествоУпаковок", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,3,ДопустимыйЗнак.Неотрицательный)));	
		
		СтрокаТаблицы = Таблица.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, Объект);
		
		Запрос.УстановитьПараметр("ТЧ", Таблица);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОбработкаОбъект.ПодборСерийВДокументы") Тогда 
		Таблица = Объект[ИмяТЧ].Выгрузить();
		Таблица.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
		Таблица.Колонки.Добавить("Упаковка", Новый ОписаниеТипов("СправочникСсылка.УпаковкиЕдиницыИзмерения"));
		Таблица.ЗаполнитьЗначения(Объект.ПараметрыПроверки.Номенклатура, "Номенклатура");
		Таблица.ЗаполнитьЗначения(Объект.ПараметрыПроверки.Упаковка, "Упаковка");
		Запрос.УстановитьПараметр("ТЧ", Таблица);
	Иначе	
		Запрос.УстановитьПараметр("ТЧ", Объект[ИмяТЧ].Выгрузить());
	КонецЕсли;	
	
	Запрос.УстановитьПараметр("ДопустимыйПроцентОтклонения", ДопустимыйПроцентОтклонения);
	Запрос.УстановитьПараметр("ПроверитьВозможностьОкругления", ПараметрыПроверки.ПроверитьВозможностьОкругления);
	
	МерныеТипы = Новый Массив;
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Вес);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Объем);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Площадь);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Длина);
	Запрос.УстановитьПараметр("МерныеТипы", МерныеТипы);
	Запрос.УстановитьПараметр("ШтучныйТип", Перечисления.ТипыИзмеряемыхВеличин.КоличествоШтук);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если ИмяТЧ = "Объект" Тогда
		Если Не ПараметрыПроверки.ПроверитьВозможностьОкругления Тогда
			ШаблонОшибкаОкругления = НСтр("ru = 'Количество в ""%Упаковка%"" переведено в количество в ""%БазоваяЕдиницаИзмерения%"" с погрешностью - %КоличествоОтклонение% %Упаковка%, что недопустимо, что свидетельствует об ошибке в работе программы. Обратитесь к администратору.'");
		ИначеЕсли ДопустимыйПроцентОтклонения > 0 Тогда
			ШаблонОшибкаОкругления = НСтр("ru = 'После округления количество товара будет равно %КоличествоОкругленное% %БазоваяЕдиницаИзмерения%, при этом погрешность округления составит %КоличествоОтклонение% %Упаковка%, что превышает максимальную погрешность - %КоличествоМаксимальнаяПогрешность% %Упаковка%.'");
		Иначе
			ШаблонОшибкаОкругления = НСтр("ru = 'Количество в ""%Упаковка%"" некратно количеству в ""%БазоваяЕдиницаИзмерения%"". Отклонение - %КоличествоОтклонение% %Упаковка%.'");
		КонецЕсли;
	Иначе
		
		ПредставлениеТЧ	= ?(ПараметрыПроверки.ПредставлениеТЧ = "",	
								Объект.Метаданные().ТабличныеЧасти[ИмяТЧ].Синоним, 
								ПараметрыПроверки.ПредставлениеТЧ);
		
		Если Не ПараметрыПроверки.ПроверитьВозможностьОкругления Тогда
			ШаблонОшибкаОкругления = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" количество в ""%Упаковка%"" переведено в количество в ""%БазоваяЕдиницаИзмерения%"" с отклонением - %КоличествоОтклонение% %Упаковка%, что свидетельствует об ошибке в работе программы. Обратитесь к администратору.'");
		ИначеЕсли ДопустимыйПроцентОтклонения > 0 Тогда
			ШаблонОшибкаОкругления = НСтр("ru = 'После округления количество товара будет равно %КоличествоОкругленное% %БазоваяЕдиницаИзмерения% в строке %НомерСтроки% списка ""%ПредставлениеТЧ%"", при этом погрешность округления составит %КоличествоОтклонение% %Упаковка%, что превышает максимальную погрешность - %КоличествоМаксимальнаяПогрешность% %Упаковка%.'");
		Иначе 
			ШаблонОшибкаОкругления = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" количество в ""%Упаковка%"" некратно количеству в ""%БазоваяЕдиницаИзмерения%"". Отклонение - %КоличествоОтклонение% %Упаковка%.'");
		КонецЕсли;
		
		ШаблонОшибкаОкругления = СтрЗаменить(ШаблонОшибкаОкругления, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		
	КонецЕсли;
	
	Пока Выборка.Следующий() Цикл
		Если Выборка.КоличествоОтклонение > Выборка.КоличествоМаксимальнаяПогрешность Тогда
			ТекстСообщения = ШаблонОшибкаОкругления;
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%БазоваяЕдиницаИзмерения%", Выборка.БазоваяЕдиницаИзмерения);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОтклонение%", Выборка.КоличествоОтклонение);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Упаковка%", Выборка.Упаковка);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоМаксимальнаяПогрешность%", Выборка.КоличествоМаксимальнаяПогрешность);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОкругленное%", Выборка.КоличествоОкругленное);
			Если ИмяТЧ = "Объект" Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения, КлючДанных, "КоличествоУпаковок", ПараметрыПроверки.ПутьКДанным, Отказ);
			Иначе
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Строка(Выборка.НомерСтроки));
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "КоличествоУпаковок");
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,ПараметрыПроверки.ПутьКДанным,Отказ);
			КонецЕсли;
		КонецЕсли;
		Если Выборка.КоличествоСуффиксОтклонение > Выборка.КоличествоСуффиксМаксимальнаяПогрешность Тогда
			ТекстСообщения = ШаблонОшибкаОкругления;
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%БазоваяЕдиницаИзмерения%", Выборка.БазоваяЕдиницаИзмерения);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОтклонение%", Выборка.КоличествоСуффиксОтклонение);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Упаковка%", Выборка.Упаковка);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоМаксимальнаяПогрешность%", Выборка.КоличествоСуффиксМаксимальнаяПогрешность);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОкругленное%", Выборка.КоличествоСуффиксОкругленное);
			Если ИмяТЧ = "Объект" Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения, КлючДанных, "КоличествоУпаковок"+СуффиксДопРеквизита, ПараметрыПроверки.ПутьКДанным, Отказ);
			Иначе
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Строка(Выборка.НомерСтроки));
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "КоличествоУпаковок"+СуффиксДопРеквизита);
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,ПараметрыПроверки.ПутьКДанным,Отказ);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Функция возвращает параметры для округления
//
//	Возвращаемое значение:
//		Структура:
//			*ИмяТЧ - Строка - значение по умолчанию "Товары"
//			*СуффиксДопРеквизита - Строка - значение по умолчанию "" - если в ТЧ два реквизита "Количество", то второй назван с суффиксом. 
//											если суффикс передан, то проверяются оба реквизита
//			*УсловиеОтбораСтрокДляОкругления - Строка - Условие выбора строк для проверки округления.
//											в качестве имени таблицы нужно использовать имя переданное в ИмяТЧ.
//			*УсловиеОтбораСтрокПоДополнительнымПолям - Строка - см. ПараметрыПроверкиЗаполненияКоличества
//			*ДополнительныеПоля - Структура - см. ПараметрыПроверкиЗаполненияКоличества								
//
Функция ПараметрыОкругленияКоличестваШтучныхТоваров() Экспорт
	
	ПараметрыОкругления = Новый Структура;
	ПараметрыОкругления.Вставить("ИмяТЧ",                                   "Товары");	
	ПараметрыОкругления.Вставить("СуффиксДопРеквизита",                     "");
	ПараметрыОкругления.Вставить("УсловиеОтбораСтрокДляОкругления",         "");
	ПараметрыОкругления.Вставить("УсловиеОтбораСтрокПоДополнительнымПолям", "");
	ПараметрыОкругления.Вставить("ДополнительныеПоля", 					    Новый Структура);

	Возврат ПараметрыОкругления;
	
КонецФункции

// Округляет количество товара до целых штук при указании количества в документе в мерных единицах измерения.
//
Процедура ОкруглитьКоличествоШтучныхТоваров(Объект, РежимЗаписи = Неопределено, ПараметрыОкругления = Неопределено) Экспорт
	
	Если РежимЗаписи <> Неопределено 
		И РежимЗаписи <> РежимЗаписиДокумента.Проведение
		И ТипЗнч(РежимЗаписи) = Тип("РежимЗаписиДокумента")
		И Объект.Метаданные().Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
		Возврат;
	КонецЕсли;
	
	Если ПараметрыОкругления = Неопределено Тогда
		ПараметрыОкругления = ПараметрыПроверкиЗаполненияКоличества();
	КонецЕсли;
	
	ИмяТЧ = ПараметрыОкругления.ИмяТЧ;
	СуффиксДопРеквизита = ПараметрыОкругления.СуффиксДопРеквизита;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ТЧ.НомерСтроки КАК НомерСтроки,
	|	ТЧ.Номенклатура КАК Номенклатура,
	|	ТЧ.Упаковка,
	|	ВЫРАЗИТЬ(ТЧ.Количество КАК ЧИСЛО(15, 0)) КАК КоличествоОкругленное,
	|	ВЫРАЗИТЬ(&ИмяПоляКоличествоСуффикс КАК ЧИСЛО(15, 0)) КАК КоличествоСуффиксОкругленное,
	|	&ДополнительныеПоля
	|ПОМЕСТИТЬ ВТ
	|ИЗ
	|	&ТЧ КАК ТЧ
	|ГДЕ
	|	ТЧ.Упаковка <> ЗНАЧЕНИЕ(Справочник.УпаковкиЕдиницыИзмерения.ПустаяСсылка)
	|	И (ТЧ.Количество <> (ВЫРАЗИТЬ(ТЧ.Количество КАК ЧИСЛО(15, 0)))
	|			ИЛИ &ИмяПоляКоличествоСуффикс <> (ВЫРАЗИТЬ(&ИмяПоляКоличествоСуффикс КАК ЧИСЛО(15, 0))))
	|	И (&УсловиеОтбораСтрокДляОкругления)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТЧ.НомерСтроки КАК НомерСтроки,
	|	ТЧ.КоличествоОкругленное КАК КоличествоОкругленное,
	|	ТЧ.КоличествоСуффиксОкругленное КАК КоличествоСуффиксОкругленное
	|ИЗ
	|	ВТ КАК ТЧ
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Номенклатура КАК ТНоменклатура
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.УпаковкиЕдиницыИзмерения КАК ТУпаковкиЕдиницыХранения
	|			ПО (ТУпаковкиЕдиницыХранения.Ссылка = ТНоменклатура.ЕдиницаИзмерения)
	|				И (ТУпаковкиЕдиницыХранения.ТипИзмеряемойВеличины = &ШтучныйТип)
	|		ПО (ТНоменклатура.Ссылка = ТЧ.Номенклатура)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.УпаковкиЕдиницыИзмерения КАК ТУпаковкиТЧ
	|		ПО (ТУпаковкиТЧ.Ссылка = ТЧ.Упаковка)
	|			И (ТУпаковкиТЧ.ТипИзмеряемойВеличины В (&МерныеТипы))
	|ГДЕ
	|	&УсловиеОтбораСтрокПоДополнительнымПолям";
	
	Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоСуффикс", "ТЧ.Количество"+СуффиксДопРеквизита);
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоСуффикс", "0");
	КонецЕсли;
	
	Если ПараметрыОкругления.УсловиеОтбораСтрокДляОкругления <> "" Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокДляОкругления", 
									СтрЗаменить(ПараметрыОкругления.УсловиеОтбораСтрокДляОкругления, ИмяТЧ + ".", "ТЧ."));
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокДляОкругления", "ИСТИНА");
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(ПараметрыОкругления.ДополнительныеПоля) Тогда
			
		Шаблон = "%1 КАК %2,
				 |%3";
		ТекстПолей = Шаблон;  			  
		Для каждого Поле Из ПараметрыОкругления.ДополнительныеПоля Цикл
			ТекстПолей = СтрШаблон(ТекстПолей, СтрЗаменить(Поле.Значение, ИмяТЧ + ".", "ТЧ."), Поле.Ключ, Шаблон);
		КонецЦикла;
			
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
			"&ДополнительныеПоля", 
			Сред(ТекстПолей, 1, СтрНайти(ТекстПолей, ",", НаправлениеПоиска.СКонца,, 2) - 1));
		
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ДополнительныеПоля", "ИСТИНА");
	КонецЕсли;	
		 
	Если ЗначениеЗаполнено(ПараметрыОкругления.УсловиеОтбораСтрокПоДополнительнымПолям) Тогда
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, 
			"&УсловиеОтбораСтрокПоДополнительнымПолям", 
			СтрЗаменить(ПараметрыОкругления.УсловиеОтбораСтрокПоДополнительнымПолям, ИмяТЧ + ".", "ТЧ."));
		
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокПоДополнительнымПолям", "ИСТИНА");	
	КонецЕсли;	
	
	Запрос = Новый Запрос(ТекстЗапроса);
		
	Если ИмяТЧ = "Объект" Тогда
		
		Таблица = Новый ТаблицаЗначений;
		Таблица.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5,0,ДопустимыйЗнак.Неотрицательный)));	
		Таблица.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
		Таблица.Колонки.Добавить("Упаковка", Новый ОписаниеТипов("СправочникСсылка.УпаковкиЕдиницыИзмерения"));
		Таблица.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,3,ДопустимыйЗнак.Неотрицательный)));	
		
		СтрокаТаблицы = Таблица.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, Объект);
		
		Запрос.УстановитьПараметр("ТЧ", Таблица);
	Иначе	
		Запрос.УстановитьПараметр("ТЧ", Объект[ИмяТЧ].Выгрузить());
	КонецЕсли;	
	
	МерныеТипы = Новый Массив;
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Вес);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Объем);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Площадь);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Длина);
	Запрос.УстановитьПараметр("МерныеТипы", МерныеТипы);
	Запрос.УстановитьПараметр("ШтучныйТип", Перечисления.ТипыИзмеряемыхВеличин.КоличествоШтук);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Если ИмяТЧ = "Объект" Тогда
			Объект.Количество = Выборка.КоличествоОкругленное;
			Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
				Объект["Количество" + СуффиксДопРеквизита] = Выборка.КоличествоСуффиксОкругленное;
			КонецЕсли;
		Иначе
			Объект[ИмяТЧ][Выборка.НомерСтроки - 1].Количество = Выборка.КоличествоОкругленное;
			Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
				Объект[ИмяТЧ][Выборка.НомерСтроки - 1]["Количество" + СуффиксДопРеквизита] = Выборка.КоличествоСуффиксОкругленное;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Процедура проверяет дубли строк в табличной части
//
// Параметры:
//  Объект				 - ДокументОбъект	 - проверяемый ДокументОбъект
//  ИмяТЧ				 - Строка			 - имя проверяемой табличной части
//  КлючевыеРеквизитыТЧ	 - Массив, Строка	 - массив имен реквизитов, по которым определяется уникальность строки
//  Отказ				 - Булево			 - отказ продолжения операции.
//  ПредставлениеТЧ		 - Строка			 - если не указано, то представление будет получено из метаданных.
//  УказыватьНомераСтрок - Булево			 - определяет необходимость вывода номера строки в сообщении об ошибке.
//
Процедура ПроверитьНаличиеДублейСтрокТЧ(Объект, ИмяТЧ, КлючевыеРеквизитыТЧ, Отказ, ПредставлениеТЧ = "", УказыватьНомераСтрок = Истина) Экспорт
	
	Если ТипЗнч(КлючевыеРеквизитыТЧ) = Тип("Строка") Тогда
		КлючевыеРеквизиты = СтрРазделить(КлючевыеРеквизитыТЧ, ",");
	Иначе
		КлючевыеРеквизиты = КлючевыеРеквизитыТЧ;
	КонецЕсли;
	
	КлючДанных = КлючДанныхДляСообщенияПользователю(Объект);
	
	МетаданныеОбъекта = Объект.Метаданные();
	Если ПустаяСтрока(ПредставлениеТЧ) Тогда
		ПредставлениеТЧ   = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Синоним;
	КонецЕсли;
	
	ТекстПоляВыборки = "";
	ТекстПоляСоединения = "";	
    ТекстПоляВыгрузки = "";
	ТекстДляСообщенияОДублях = "";
	
	Для Каждого СтрМас Из КлючевыеРеквизиты Цикл
		ТекстПоляВыборки = ТекстПоляВыборки + "
			|	ТаблицаПроверки." + СтрМас + ",";
		ТекстПоляСоединения = ТекстПоляСоединения + "
			|	И ТаблицаПроверки." + СтрМас + " = ДублирующиесяСтроки."+ СтрМас;
		ТекстПоляВыгрузки = ТекстПоляВыгрузки + СтрМас + ",";
		
		ПредставлениеРеквизита = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты[СтрМас].Синоним;
		
		ТекстДляСообщенияОДублях = ТекстДляСообщенияОДублях + """"  + ПредставлениеРеквизита  + """, "
	КонецЦикла;	
	
	ТекстДляСообщенияОДублях = Лев(ТекстДляСообщенияОДублях, СтрДлина(ТекстДляСообщенияОДублях) - 2);
	
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ТекстПоляВыборки,1);
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ТекстПоляВыгрузки,1);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ 
	|	ТаблицаПроверки.НомерСтроки, " +
		ТекстПоляВыборки + "
	|ПОМЕСТИТЬ ТаблицаПроверки
	|ИЗ
	|	&ТаблицаПроверки КАК ТаблицаПроверки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МИНИМУМ(ТаблицаПроверки.НомерСтроки) КАК НомерСтроки,
	|	СУММА(1) КАК КоличествоДублей,"+
		ТекстПоляВыборки + "
	|ПОМЕСТИТЬ ДублирующиесяСтроки
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|
	|СГРУППИРОВАТЬ ПО " +
		ТекстПоляВыборки + "
	|
	|ИМЕЮЩИЕ
	|	СУММА(1) > 1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаПроверки.НомерСтроки,
	|	ДублирующиесяСтроки.НомерСтроки КАК ПерваяСтрока,"+
		ТекстПоляВыборки + "
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ДублирующиесяСтроки КАК ДублирующиесяСтроки
	|		ПО ТаблицаПроверки.НомерСтроки <> ДублирующиесяСтроки.НомерСтроки " +
	     		ТекстПоляСоединения;
	Запрос.УстановитьПараметр("ТаблицаПроверки",Объект[ИмяТЧ].Выгрузить(,"НомерСтроки," + ТекстПоляВыгрузки));
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если УказыватьНомераСтрок Тогда
		Если КлючевыеРеквизиты.Количество() = 1 Тогда
			ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется значение ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
		Иначе
			ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется сочетание значений ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
		КонецЕсли;	
	Иначе
		Если КлючевыеРеквизиты.Количество() = 1 Тогда
			ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется значение ""%ПовторяемоеЗначение%"" в поле %НазванияПолей%.'");
		Иначе
			ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется сочетание значений ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
		КонецЕсли;	
	КонецЕсли;
	Пока Выборка.Следующий() Цикл
		
		ТекстСообщения =  СтрЗаменить(ШаблонСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Выборка.НомерСтроки);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПерваяСтрока%", Выборка.ПерваяСтрока);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НазванияПолей%", ТекстДляСообщенияОДублях);
		
		ПовторяемоеЗначение = "";
		
		Для Каждого СтрМас Из КлючевыеРеквизиты Цикл
			ПредставлениеЗначения = СокрЛП(Строка(Выборка[СтрМас]));
			Если ЗначениеЗаполнено(ПредставлениеЗначения) Тогда
				ПовторяемоеЗначение = ПовторяемоеЗначение + Выборка[СтрМас] + "/";
			КонецЕсли;
		КонецЦикла;
		
		ПовторяемоеЗначение = Лев(ПовторяемоеЗначение, СтрДлина(ПовторяемоеЗначение) - 1);
		
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПовторяемоеЗначение%", ПовторяемоеЗначение);
		
		Если УказыватьНомераСтрок Тогда
			Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "НомерСтроки");
		Иначе
			Поле = ИмяТЧ;
		КонецЕсли;
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
		
	КонецЦикла;
КонецПроцедуры

// Процедура заполняет значения реквизитов табличной части по структуре
//
// Параметры:
// 		КоллекцияДанных - ДанныеФормыКоллекция - Табличная часть
// 		СтруктураРеквизитов - Структура - Структура. Ключ - имя реквизита флага активности. Значение - строка перечисления зависимых реквизитов.
//
Процедура ЗаполнитьДубликатыЗависимыхРеквизитовВКоллекции(КоллекцияДанных, СтруктураРеквизитов) Экспорт
	
	// Получение шаблона поля выборки для значения дубликата реквизита
	// 		Если флаг активности ИСТИНА - скопировать значение из реквизита
	// 		Иначе - заполнить пустым значением.
	ШаблонПоляВыборки = ",
	|	ВЫБОР КОГДА Коллекция.%ИмяФлага% = ИСТИНА
	|		ТОГДА Коллекция.%ИмяРеквизита%
	|		ИНАЧЕ 0
	|	КОНЕЦ КАК %ИмяРеквизита%%ИмяФлага%";
	
	ПоляВыборки = ""; // Поля выборки для запроса получения данных
	ПоляВыгрузки = "НомерСтроки"; // Перечисление через запятую полей, выгружаемых из коллекции
	Для Каждого РеквизитФлага Из СтруктураРеквизитов Цикл
		ПоляВыгрузки = ПоляВыгрузки + ", " + РеквизитФлага.Ключ;
		ЗависимыеРеквизиты = Новый Структура(РеквизитФлага.Значение);
		Для Каждого ЗависимыйРеквизит Из ЗависимыеРеквизиты Цикл
			ПоляВыборки = ПоляВыборки + СтрЗаменить(СтрЗаменить(ШаблонПоляВыборки, "%ИмяФлага%", РеквизитФлага.Ключ), "%ИмяРеквизита%", ЗависимыйРеквизит.Ключ);
			ПоляВыгрузки = ПоляВыгрузки + ", " + ЗависимыйРеквизит.Ключ + ", " + ЗависимыйРеквизит.Ключ + РеквизитФлага.Ключ;
		КонецЦикла;
	КонецЦикла;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Коллекция.НомерСтроки" + ПоляВыборки + "
	|ПОМЕСТИТЬ втКоллекция
	|ИЗ &КоллекцияДанных КАК Коллекция;
	|
	|ВЫБРАТЬ *
	|ИЗ втКоллекция КАК втКоллекция
	|УПОРЯДОЧИТЬ ПО НомерСтроки");
	Запрос.УстановитьПараметр("КоллекцияДанных", КоллекцияДанных.Выгрузить( , ПоляВыгрузки));
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(КоллекцияДанных[Выборка.НомерСтроки-1], Выборка, , "НомерСтроки");
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьДубликатыЗависимыхРеквизитовВКоллекции()

// Процедура проверяет отмену строк в табличной части документа
// Параметры:
//	Объект - проверяемый ДокументОбъект
//	ИмяТЧ - Строка - имя проверяемой табличной части
//	ИмяРеквизитаОтменыСтрок - Строка - имя проверяемого булевого реквизита ТЧ.
//
Функция ВсеСтрокиОтменены(Объект, ИмяТЧ, ИмяРеквизитаОтменыСтрок) Экспорт
	
	СтруктураОтбора = Новый Структура(ИмяРеквизитаОтменыСтрок, Ложь);
	НеОтмененныеСтроки = Объект[ИмяТЧ].НайтиСтроки(СтруктураОтбора);
	
	Возврат (НеОтмененныеСтроки.Количество() = 0);
	
КонецФункции

// Создает фиксированную структуру, содержащую свойства одноименные колонкам таблицы формы.
//
//  Параметры:
//   - Форма - ФормаКлиентскогоПриложения - форма, содержащая таблицу и служебный реквизит,
//                                имя которого образовано именем таблицы с префиксом "Кеш".
//  ИмяТабличнойЧасти - Строка - имя таблицы формы, текущие данные которой необходимо скопировать в служебный реквизит формы.
//		Имя служебного реквизита должно состоять из префикса Кеш и имени табличной части.
//
Процедура ИнициализироватьКешТекущейСтроки(Форма, ИмяТабличнойЧасти, ПутьКТабличнойЧасти = "Объект") Экспорт

	Если ЗначениеЗаполнено(ПутьКТабличнойЧасти) Тогда
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты(ПутьКТабличнойЧасти + "." + ИмяТабличнойЧасти);
	Иначе
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты(ИмяТабличнойЧасти);
	КонецЕсли;
	
	РезультатСтруктура = Новый Структура;
	Для Каждого РеквизитФормы Из МассивРеквизитовФормы Цикл
		РезультатСтруктура.Вставить(РеквизитФормы.Имя, Истина);
	КонецЦикла;

	Форма[ИмяТабличнойЧасти + "КешТекущейСтроки"] = Новый ФиксированнаяСтруктура(РезультатСтруктура);

КонецПроцедуры

#КонецОбласти

#Область КонтрольНесогласованныхИзменений

// Осуществляет установку подписки на события изменения элементов формы.
//
// Параметры:
// 		Форма                    - ДокументОбъект, СправочникОбъект - Проверяемый объект.
// 		МассивЭлементов          - Массив - массив элементов формы.
// 		УстановитьПодписку - Булево - необходимость установки или снятия предупреждения.
//
Процедура УстановитьПодпискуНаСобытияИзмененияЭлементовФормы(Форма, ИменаЭлементов, Установить) Экспорт
	
	Если Не ЗначениеЗаполнено(Форма.Объект.Ссылка) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураПолейТаблиц = Новый Структура;
	
	ТипУправляемаяФорма = Тип("ФормаКлиентскогоПриложения");
	ТипДанныеФормыКоллекция = Тип("ДанныеФормыКоллекция");
	ТипДанныеФормыДерево = Тип("ДанныеФормыДерево");
	ТипДанныеФормыСтруктура = Тип("ДанныеФормыСтруктура");
	ТипПолеФормы = Тип("ПолеФормы");
	ТипКнопкаФормы = Тип("КнопкаФормы");
	ТипТаблицаФормы = Тип("ТаблицаФормы");
	
	Элементы = Форма.Элементы;
	
	ОбработчикиСобытийТабличныхЧастей = Новый Структура();
	МассивЭлементов = Новый Массив;
	Для Каждого ИмяЭлементаПолное Из ИменаЭлементов Цикл
		
		ПозицияРазделителя = СтрНайти(ИмяЭлементаПолное, ";");
		Если ПозицияРазделителя > 0 Тогда
			Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭлементаПолное, ";");
			ИмяЭлемента = Массив[0];
		Иначе
			ИмяЭлемента = ИмяЭлементаПолное;
		КонецЕсли;
		
		Если МассивЭлементов.Найти(ИмяЭлемента) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Элемент = Элементы.Найти(ИмяЭлемента);
		Если Элемент = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		МассивЭлементов.Добавить(ИмяЭлемента);
		
		Если ПозицияРазделителя > 0 И Массив.Количество() > 1 Тогда
			Если СтрНайти(Массив[1], ",") > 0 Тогда
				ОбработчикиСобытийТабличныхЧастей.Вставить(ИмяЭлемента, СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Массив[1], ","));
			Иначе	
				ОбработчикиСобытийТабличныхЧастей.Вставить(ИмяЭлемента, Массив[1]);
			КонецЕсли;
		КонецЕсли;
		
		ПоляИсключения = Новый Массив;
		Если ПозицияРазделителя > 0
			И Массив.Количество() > 2 Тогда
			ПоляИсключения = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Массив[2], ",");
		КонецЕсли;
		
		ОбработатьВложенныеПоля(Элементы, Элемент, МассивЭлементов, СтруктураПолейТаблиц, ПоляИсключения);
		
	КонецЦикла;
	
	ИмяОбработчикаПустой = "Подключаемый_ПустойОбработчик_УстановитьДоступностьЭлементовПоСтатусуСервер";
	Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений = Неопределено Тогда
		
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений = Новый Структура;
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("Команды", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПриИзменении", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("Нажатие", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередНачаломИзменения", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередНачаломДобавления", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередУдалением", Новый Структура);
		
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ОжидаетсяОповещение", Ложь);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ЗначенияРеквизитов", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПутьКДанным", Новый Структура);
		
		Для Каждого ИмяТаблицы Из СтруктураПолейТаблиц Цикл
			
			Имена = Новый Массив;
			Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов.Вставить(ИмяТаблицы.Ключ, Новый Структура);
			
			Для Каждого ИмяЭлемента Из СтруктураПолейТаблиц[ИмяТаблицы.Ключ] Цикл
				
				Данные = Неопределено;
				ПутьКДанным = Элементы[ИмяЭлемента].ПутьКДанным;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					
					Позиция = СтрНайти(ПутьКДанным, ".");
					Пока Позиция > 0 Цикл
						Подстрока = Лев(ПутьКДанным, Позиция - 1);
						ПутьКДанным = Сред(ПутьКДанным, Позиция + 1);
						Позиция = СтрНайти(ПутьКДанным, ".");
					КонецЦикла;					
					Имена.Добавить(ПутьКДанным);
					
				КонецЕсли;
				
			КонецЦикла;
			
			Для Каждого Имя Из Имена Цикл
				Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов[ИмяТаблицы.Ключ].Вставить(Имя);
			КонецЦикла;
			
		КонецЦикла;
		
		ИмяОбработчикаПриИзменении            = "Подключаемый_ПриИзменении_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаНажатие                 = "Подключаемый_Нажатие_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаКоманды                 = "Подключаемый_Команда_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередНачаломИзменения   = "Подключаемый_ПередНачаломИзменения_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередНачаломДобавления  = "Подключаемый_ПередНачаломДобавления_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередУдалением          = "Подключаемый_ПередУдалением_УстановитьДоступностьЭлементовПоСтатусуСервер";
		
		Для Каждого ИмяЭлементаПолное Из МассивЭлементов Цикл
			
			ПозицияРазделителя = СтрНайти(ИмяЭлементаПолное, ";");
			Если ПозицияРазделителя > 0 Тогда
				ИмяЭлемента = Лев(ИмяЭлементаПолное, ПозицияРазделителя - 1);
			Иначе
				ИмяЭлемента = ИмяЭлементаПолное;
			КонецЕсли;
			
			Элемент = Элементы[ИмяЭлемента];
			Если Элемент = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗнчЭлемент = ТипЗнч(Элемент);
			
			Если ТипЗнчЭлемент = ТипПолеФормы Тогда
				
				Действие = Элемент.ПолучитьДействие("ПриИзменении");
				Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПриИзменении.Вставить(ИмяЭлемента, Действие);
				КонецЕсли;
				
				Данные = Неопределено;
				ПутьКДанным = Элемент.ПутьКДанным;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьКДанным, ".");
					Данные = Форма;
					Для Каждого СтрокаМассива Из Массив Цикл
						ТипЗнчДанные = ТипЗнч(Данные);
						Если ТипЗнчДанные = ТипУправляемаяФорма
							ИЛИ ТипЗнчДанные = ТипДанныеФормыСтруктура Тогда
							Данные = Данные[СтрокаМассива];
						Иначе
							Данные = Неопределено;
							Прервать;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Если Данные <> Неопределено Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов.Вставить(ИмяЭлемента, Данные);
				КонецЕсли;
				Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПутьКДанным.Вставить(ИмяЭлемента, ПутьКДанным);
				Элемент.УстановитьДействие("ПриИзменении", ИмяОбработчикаПриИзменении);
				
			ИначеЕсли ТипЗнчЭлемент = ТипТаблицаФормы Тогда
				
				Действия = Неопределено;
				ОбработчикиСобытийТабличныхЧастей.Свойство(ИмяЭлемента, Действия);
				
				Если Не ЗначениеЗаполнено(Действия) Или Действия.Найти("ПередНачаломДобавления") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередНачаломДобавления");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередНачаломДобавления.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередНачаломДобавления", ИмяОбработчикаПередНачаломДобавления);
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(Действия) Или Действия.Найти("ПередУдалением") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередУдалением");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередУдалением.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередУдалением", ИмяОбработчикаПередУдалением);
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(Действия) Или Действия.Найти("ПередНачаломИзменения") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередНачаломИзменения");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередНачаломИзменения.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередНачаломИзменения", ИмяОбработчикаПередНачаломИзменения);
				КонецЕсли;
				
			ИначеЕсли ТипЗнчЭлемент = ТипКнопкаФормы Тогда
				
				ИмяКоманды = Элемент.ИмяКоманды;
				
				Если Не ЗначениеЗаполнено(ИмяКоманды) Тогда
					Продолжить;
				КонецЕсли;
				
				Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Команды.Свойство(ИмяКоманды) Тогда
					Продолжить;
				КонецЕсли;
				
				Действие = Форма.Команды[ИмяКоманды].Действие;
				Если ЗначениеЗаполнено(Действие) Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Команды.Вставить(ИмяКоманды, Действие);
				КонецЕсли;
				
				Форма.Команды[ИмяКоманды].Действие = ИмяОбработчикаКоманды;
				
			ИначеЕсли ТипЗнчЭлемент = Тип("ДекорацияФормы") Тогда
				
				Действие = Элемент.ПолучитьДействие("Нажатие");
				Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Нажатие.Вставить(ИмяЭлемента, Действие);
				КонецЕсли;
				
				Элемент.УстановитьДействие("Нажатие", ИмяОбработчикаНажатие);
				
			Иначе
				ВызватьИсключение НСтр("ru = 'Внутренняя ошибка'");
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений <> Неопределено Тогда
			Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ОжидаетсяОповещение = Ложь;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область УсловноеОформление

// Устанавливаем условное оформление для поля формы "Приоритет"
//    в зависимости от его значения.
//
// Параметры:
// 		Форма - Форма - Содержит данную форму.
//
Процедура УстановитьУсловноеОформлениеПриоритета(Форма) Экспорт
	
	Если Форма.ИмяФормы = "Обработка.СамообслуживаниеПартнеров.Форма.МастерОформленияЗаказа" Тогда
		ПутьКРеквизитуПриоритет = "Приоритет";
	Иначе
		ПутьКРеквизитуПриоритет = "Объект.Приоритет";
	КонецЕсли;
	
	УсловноеОформление = Форма.УсловноеОформление;
	ЭлементыФормы = Форма.Элементы;
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы["Приоритет"].Имя);

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Справочники.Приоритеты.ПолучитьВысшийПриоритет();

	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", ЦветаСтиля.ВысокийПриоритетДокумента);

	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы["Приоритет"].Имя);

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Справочники.Приоритеты.ПолучитьНизшийПриоритет();

	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", ЦветаСтиля.НизкийПриоритетДокумента);
	
	//
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Приоритеты.Ссылка КАК Приоритет,
	|	Приоритеты.Цвет   КАК Цвет
	|ИЗ
	|	Справочник.Приоритеты КАК Приоритеты");
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			Элемент = УсловноеОформление.Элементы.Добавить();

			ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
			ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы.Приоритет.Имя);

			ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
			ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			ОтборЭлемента.ПравоеЗначение = Выборка.Приоритет;

			Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", Выборка.Цвет.Получить());
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура заполняет всеми подчиненными полями (с учетом вложенности в группы) оформляемые поля условного оформления
// Пример вызова: ЗаполнитьРекурсивноПоляУсловногоОформления(ЭлементУО.Поля, Элементы.Товары.ПодчиненныеЭлементы).
//
// Параметры:
//	ОформляемыеПоляКомпоновкиДанных	- ОформляемыеПоляКомпоновкиДанных
//	КоллекцияЭлементов - ЭлементыФормы
//	ИсключаяПоля - Массив, Строка, Неопределено - значение по умолчанию Неопределено, массив имен элементов, которые не нужно добавлять в оформляемые поля.
//
Процедура ЗаполнитьРекурсивноПоляУсловногоОформления(ОформляемыеПоляКомпоновкиДанных, КоллекцияЭлементов, Знач ИсключаяПоля = Неопределено) Экспорт
	
	Если ТипЗнч(ИсключаяПоля) = Тип("Строка") Тогда
		ИсключаяПоля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаяПоля);
	КонецЕсли;
	
	Для Каждого Поле Из КоллекцияЭлементов Цикл
		Если ТипЗнч(Поле) = Тип("ПолеФормы") Тогда
			Если ИсключаяПоля = Неопределено
				Или ИсключаяПоля.Найти(Поле.Имя) = Неопределено Тогда
					ПолеЭлемента = ОформляемыеПоляКомпоновкиДанных.Элементы.Добавить();
					ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Поле.Имя);
			КонецЕсли;
		ИначеЕсли ТипЗнч(Поле) = Тип("ГруппаФормы")Тогда	
			ЗаполнитьРекурсивноПоляУсловногоОформления(ОформляемыеПоляКомпоновкиДанных, Поле.ПодчиненныеЭлементы);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Добавляет на форму условное оформление элемента (отметку незаполненного), исходя из значения служебного реквизита
// по следующему правилу: если реквизит не заполнен а служебный реквизит заполнен то пометка устанавливается, иначе снимается.
//
//  Параметры:
//   УсловноеОформление - УсловноеОформление - условное оформление формы.
//   ИмяЭлемента - Строка - имя элемента для условного оформления.
//   ИмяРеквизита - Произвольный - Реквизит формы, связанный с элементом формы.
//   ИмяТЧ - Строка - имя табличной части, если требуется оформлять поле таблицы формы.
//   ИмяПризнака - Строка - имя служебного реквизита.
//
Процедура УстановитьСнятьОтметкуНезаполненного(УсловноеОформление, ИмяЭлемента, ИмяРеквизита, ИмяТЧ, ИмяПризнака) Экспорт
	
	Подстановка = ?(ИмяТЧ = "", "", "Объект." + ИмяТЧ + ".");
	ПутьКПризнаку = "Объект.Товары.ИмяПризнака";
	ПутьКПризнаку = СтрЗаменить(ПутьКПризнаку, "Объект.Товары.", Подстановка);
	ПутьКПризнаку = СтрЗаменить(ПутьКПризнаку, "ИмяПризнака", ИмяПризнака);
	
	Подстановка = ?(ИмяТЧ = "", "", ИмяТЧ + ".");
	ПутьКРеквизиту = "Объект.Товары.ИмяРеквизита";
	ПутьКРеквизиту = СтрЗаменить(ПутьКРеквизиту, "Товары.", Подстановка);
	ПутьКРеквизиту = СтрЗаменить(ПутьКРеквизиту, "ИмяРеквизита", ИмяРеквизита);
	
	// Установка отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Истина);
	
	// Установка отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	Отбор.ПравоеЗначение = Истина;
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Истина);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	Отбор.ПравоеЗначение = Ложь;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
КонецПроцедуры

#КонецОбласти

#Область ПереключениеИнтерфейса

// Установка набора видимых подсистем командного интерфейса
//  и настроек всем пользователям вида интерфейса (Такси / в закладках).
//
// Параметры:
//  Режим	 - Строка	 - ИнтерфейсТакси / ИнтерфейсВерсии82 - соответствует константе, которая будет установлена в Истину.
//
Процедура УстановитьРежимКомандногоИнтерфейса(Режим) Экспорт
	
	Если НЕ ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	// Установка констант
	
	РежимТакси = ВРег(Режим) = ВРег("ИнтерфейсТакси");
	Режим82    = ВРег(Режим) = ВРег("ИнтерфейсВерсии82");
	
	Если НЕ РежимТакси
		И НЕ Режим82 Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	Константы.ИнтерфейсВерсии82.Установить(Режим82);
	
	// Установка настроек по умолчанию всем пользователям
	
	ВсеПользователи = ПользователиИнформационнойБазы.ПолучитьПользователей();
	Если ВсеПользователи.Количество() > 0 Тогда
		Для каждого ПользовательИБ Из ВсеПользователи Цикл
			ПользователиСлужебный.УстановитьНачальныеНастройки(ПользовательИБ.Имя);
		КонецЦикла;
	Иначе
		ПользователиСлужебный.УстановитьНачальныеНастройки("");
	КонецЕсли;

КонецПроцедуры

// Процедура - Переключение интерфейса при создании на сервере
//
// Параметры:
//  Форма	 - ФормаКлиентскогоПриложения	 - Форма панели администрирования.
//
Процедура ПереключениеИнтерфейсаПриСозданииНаСервере(Форма) Экспорт 

	// Значения реквизитов формы
	Если Константы.ИнтерфейсВерсии82.Получить() Тогда
		Форма.ВариантИнтерфейса = "ИнтерфейсВерсии82";
	Иначе
		Форма.ВариантИнтерфейса = "ИнтерфейсТакси";
	КонецЕсли;
	Форма.ВариантИнтерфейсаДоИзменения = Форма.ВариантИнтерфейса;
	
	ТекущийРежим = Метаданные.РежимСовместимостиИнтерфейса;
	Такси = (ТекущийРежим = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.Такси
		ИЛИ ТекущийРежим = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.ТаксиРазрешитьВерсия8_2);
	
	Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Очистить();
	ПредставлениеИнтерфейса82 = НСтр("ru = 'Как в предыдущих версиях УправлениеТорговлей'");
	//++ НЕ УТ
	ПредставлениеИнтерфейса82 = НСтр("ru = 'Как в предыдущих версиях 1С:ERP'");
	//-- НЕ УТ
	Если Такси ИЛИ ПолучитьФункциональнуюОпцию("БазоваяВерсия") Тогда
	
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсТакси", НСтр("ru = '""Такси"" (рекомендуется)'"));
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсВерсии82", ПредставлениеИнтерфейса82);
		
	Иначе
		
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсТакси", НСтр("ru = '""Такси""'"));
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсВерсии82", ПредставлениеИнтерфейса82 + " " + НСтр("ru = '(рекомендуется)'"));
		
	КонецЕсли; 

КонецПроцедуры

#КонецОбласти

// Возвращает представление переданного объекта.
//
// Параметры:
//	ПараметрОбъект - Строка или ОбъектМетаданных - объект для получения представления
//
// Возвращаемое значение:
//	Строка - представление объекта
//
Функция ПредставлениеОбъекта(ПараметрОбъект) Экспорт
	
	Если ПараметрОбъект = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	МетаданныеОбъекта = ?(ТипЗнч(ПараметрОбъект) = Тип("Строка"), Метаданные.НайтиПоПолномуИмени(ПараметрОбъект), ПараметрОбъект);
	
	Представление = Новый Структура("ПредставлениеОбъекта");
	ЗаполнитьЗначенияСвойств(Представление, МетаданныеОбъекта);
	Если Не ПустаяСтрока(Представление.ПредставлениеОбъекта) Тогда
		Возврат Представление.ПредставлениеОбъекта;
	КонецЕсли;
	
	Возврат МетаданныеОбъекта.Представление();
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПроцедурыИФункцииУстановкиСтатусовДляМассиваДокументов

// Возвращает соответствие массивов документов по типам
//
// Параметры:
// 		МассивСсылок - Массив - Массив ссылок.
//
// Возвращаемое значение:
// 		Соответствие - Ключ: Тип; значение: Массив ссылок на документы.
//
Функция РазложитьМассивСсылокПоТипам(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Счетчик = 0 По МассивСсылок.Количество() -1 Цикл
		
		ТипСсылки = ТипЗнч(МассивСсылок[Счетчик]);
		Массив = СоответствиеТипов[ТипСсылки];
		Если Массив = Неопределено Тогда
			Массив = Новый Массив;
			СоответствиеТипов.Вставить(ТипСсылки, Массив);
		КонецЕсли;
		Массив.Добавить(МассивСсылок[Счетчик]);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции // РазложитьМассивСсылокПоТипам

#КонецОбласти

#Область МетодыРаботыСРеквизитамиОбъектов

// Позволяет определить есть ли среди реквизитов табличной части объекта реквизит с переданным именем.
//
// Параметры:
//  ИмяРеквизита - строковое имя искомого реквизита.
//  МетаданныеОбъекта - описание метаданных объекта, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части объекта, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиОбъекта(ИмяРеквизита, МетаданныеОбъекта, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеОбъекта.ТабличныеЧасти.Найти(ИмяТабЧасти);

	Если ТабЧасть = Неопределено Тогда // нет такой таб. части
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ТабЧасть.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;
	
КонецФункции

#КонецОбласти

#Область ЗаменаСсылокПоИнформационнойБазе

// Заменяет ссылки по информационной базе.
//
// Параметры:
//	ПарыЗамены - Соответствие - ключи содержат замещаемых, значения содержат заменители
//	Исключения - Массив - необязателен, значения типа ОбъектМетаданных, в экземплярах которых замены проводить нельзя.
//
Процедура ЗаменитьСсылки(ПарыЗамен, Исключения = Неопределено) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	Английский = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Английский;
	ДвиженияССубконтоИмя = ?(Метаданные.ВариантВстроенногоЯзыка = Английский, ".RecordsWithExtDimensions", ".ДвиженияССубконто");
	
	Если Исключения = Неопределено Тогда
		Исключения = Новый Массив;
	КонецЕсли;
	
	// [ссылающийся объект](.Метаданные, .Замены[(.Замещаемое, .Заменитель)], .ТипыЗамещаемых[]).
	ИндексЗамены = ИндексЗамены(ПарыЗамен);
	КешПолей = Новый Соответствие;
	// Обходим индекс и в каждом ключе-объекта полностью замещаем все ссылки, подлежащие замене.
	Для Каждого УзелЗамены Из ИндексЗамены Цикл
		Ссылка = УзелЗамены.Ключ;
		МетаданныеУзла = УзелЗамены.Значение.Метаданные;
		Замены = УзелЗамены.Значение.Замены;
		ТипыЗамещаемых = УзелЗамены.Значение.ТипыЗамещаемых;
		
		Если Исключения.Найти(МетаданныеУзла) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЭтоСсылочныйОбъектМетаданных(МетаданныеУзла) Тогда
			// любой ссылочный объект
			ОбъектДанных = Ссылка.ПолучитьОбъект();
			Если ОбъектДанных <> Неопределено Тогда
				ПолноеИмя = МетаданныеУзла.ПолноеИмя();
				ИменаПолей = ИменаПолейСТипами(КешПолей, ПолноеИмя, ТипыЗамещаемых, "Ссылка, Ref");
				ЗаменитьЗначения(ОбъектДанных, ИменаПолей, Замены);
				// табчасти объекта
				ЗаменитьВТабчастях(
					КешПолей, МетаданныеУзла.ТабличныеЧасти, ОбъектДанных, ПолноеИмя, Замены, ТипыЗамещаемых, Исключения);
				// стандартные табчасти планов
				Если Метаданные.ПланыСчетов.Содержит(МетаданныеУзла) Или Метаданные.ПланыВидовРасчета.Содержит(МетаданныеУзла) Тогда
					ЗаменитьВТабчастях(
						КешПолей, МетаданныеУзла.СтандартныеТабличныеЧасти, ОбъектДанных, ПолноеИмя, Замены, ТипыЗамещаемых, Исключения);
				КонецЕсли;
				// пишем сам объект
				ЗаписатьДанные(ОбъектДанных);
				ОбъектДанных = Неопределено;
			КонецЕсли;
		ИначеЕсли Метаданные.Константы.Содержит(МетаданныеУзла) Тогда
			// значения в константах
			Константа = Константы[МетаданныеУзла.Имя];
			Константа.Установить(НовоеЗначение(Константа.Получить(), Замены));
		ИначеЕсли Метаданные.РегистрыСведений.Содержит(МетаданныеУзла) Тогда
			// необъектные таблицы
			ИменаПолей = ИменаПолейСТипами(КешПолей, МетаданныеУзла.ПолноеИмя(), ТипыЗамещаемых);
			Отборы = ОтборыРегистраСведений(МетаданныеУзла, Ссылка);
			Набор = НаборЗаписей(РегистрыСведений[МетаданныеУзла.Имя], Отборы);
			
			Таблица = Набор.Выгрузить();
			Набор.Очистить();
			ЗаписатьДанные(Набор);

			ЗаменитьЗначения(Таблица[0], ИменаПолей, Замены);
			Для Каждого ИмяПоля Из ИменаПолей Цикл
				Если Не Отборы.Свойство(ИмяПоля) Тогда
					Продолжить;
				КонецЕсли;
				Набор.Отбор[ИмяПоля].Установить(НовоеЗначение(Отборы[ИмяПоля], Замены));
			КонецЦикла;
			Набор.Загрузить(Таблица);
			ЗаписатьДанные(Набор);
		КонецЕсли;
		// обработка движений документа
		Если Метаданные.Документы.Содержит(МетаданныеУзла) Тогда
			Для Каждого Движение Из МетаданныеУзла.Движения Цикл
				ДопТаблица = "";
				Если Исключения.Найти(Движение) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если Метаданные.РегистрыНакопления.Содержит(Движение) Тогда
					Регистр = РегистрыНакопления[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыСведений.Содержит(Движение) Тогда
					Регистр = РегистрыСведений[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Движение) Тогда
					ДопТаблица = ДвиженияССубконтоИмя;
					Регистр = РегистрыБухгалтерии[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Движение) Тогда
					Регистр = РегистрыРасчета[Движение.Имя];
				КонецЕсли;
				ЗаменитьВПодчиненномРегистре(КешПолей, Регистр, Ссылка, Движение.ПолноеИмя() + ДопТаблица, Замены, ТипыЗамещаемых);
			КонецЦикла;
			// обработка последовательностей, включающих документ
			Для Каждого Движение Из Метаданные.Последовательности Цикл
				Если Исключения.Найти(Движение) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если Движение.Документы.Содержит(МетаданныеУзла) Тогда
					ЗаменитьВПодчиненномРегистре(
						КешПолей, Последовательности[Движение.Имя], Ссылка, Движение.ПолноеИмя(), Замены, ТипыЗамещаемых);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Строим соответствие вида [ссылающийся объект](.Метаданные, .Замены[(.Замещаемое, .Заменитель)], .ТипыЗамещаемых[])
// в итоге представляем результаты поиска по ссылкам в индексе с ключом-объектом, содержащим замещаемые ссылки.
Функция ИндексЗамены(ПарыЗамен)
	
	СписокСсылок = Новый Массив;
	Для Каждого Пара Из ПарыЗамен Цикл
		СписокСсылок.Добавить(Пара.Ключ);
	КонецЦикла;
	РезультатыПоиска = НайтиПоСсылкам(СписокСсылок);
	// (.Ссылка: исходная ссылка; .Данные: ссылающийся объект; .Метаданные: метаданные ссылающегося объекта).
	
	ИндексЗамены = Новый Соответствие;
	Для Каждого Результат Из РезультатыПоиска Цикл
		УзелЗамены = ИндексЗамены[Результат.Данные];
		Если Неопределено = УзелЗамены Тогда
			УзелЗамены =
				Новый Структура("Метаданные, Замены, ТипыЗамещаемых", Результат.Метаданные, Новый Массив, Новый Массив);
			ИндексЗамены.Вставить(Результат.Данные, УзелЗамены);
		КонецЕсли;

		УзелЗамены.Замены.Добавить(
			Новый Структура("Замещаемое, Заменитель", Результат.Ссылка, ПарыЗамен[Результат.Ссылка]));

		ТипЗамещаемого = ТипЗнч(Результат.Ссылка);
		Если Неопределено = УзелЗамены.ТипыЗамещаемых.Найти(ТипЗамещаемого) Тогда
			УзелЗамены.ТипыЗамещаемых.Добавить(ТипЗамещаемого);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИндексЗамены;
КонецФункции

Процедура ЗаменитьВТабчастях(КешПолей, ОписанияТабчастей, Объект, ИмяОсновнойТаблицы, Замены, ТипыЗамещаемых, Исключения)
	Для Каждого Описание Из ОписанияТабчастей Цикл
		Если Исключения.Найти(Описание) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ИменаПолей = ИменаПолейСТипами(КешПолей, ИмяОсновнойТаблицы + "." + Описание.Имя, ТипыЗамещаемых, "Ссылка, Ref");
		Для Каждого Табстрока Из Объект[Описание.Имя] Цикл
			ЗаменитьЗначения(Табстрока, ИменаПолей, Замены);
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаменитьВПодчиненномРегистре(КешПолей, МенеджерРегистра, Ссылка, ИмяТаблицыРегистра, Замены, ТипыЗамещаемых)
	ИменаПолей = ИменаПолейСТипами(КешПолей, ИмяТаблицыРегистра, ТипыЗамещаемых, "Регистратор, Recorder");
	Набор = НаборЗаписей(МенеджерРегистра, Новый Структура("Регистратор", Ссылка));
	ЗначениеЗаменено = Ложь;
	Для Каждого Запись Из Набор Цикл
		ЗаменитьЗначения(Запись, ИменаПолей, Замены, ЗначениеЗаменено);
	КонецЦикла;
	ЗаписатьДанные(Набор, ЗначениеЗаменено);
КонецПроцедуры

Функция ИменаПолейСТипами(КешПолейТаблиц, ИмяТаблицы, ТипыДанных, ИменаИсключений = "")
	
	ИменаПолей  = Новый Массив;
	Исключения  = Новый Структура(ИменаИсключений);
	ПоляТаблицы = КешПолейТаблиц.Получить(ИмяТаблицы);
	
	Если ПоляТаблицы = Неопределено Тогда
		
	    ПоляТаблицы = Новый Массив;
		
	    СхемаЗапроса = Новый СхемаЗапроса;
	    СхемаЗапроса.УстановитьТекстЗапроса(
			СтрЗаменить("ВЫБРАТЬ * ИЗ ТаблицаВыборки КАК Т ГДЕ ЛОЖЬ", "ТаблицаВыборки", ИмяТаблицы));
		
		Для Каждого КолонкаЗапроса Из СхемаЗапроса.ПакетЗапросов[0].Колонки Цикл
	        Если ТипЗнч(КолонкаЗапроса) = Тип("КолонкаСхемыЗапроса") Тогда
	            ПоляТаблицы.Добавить(
					Новый Структура("Имя,ТипЗначения", КолонкаЗапроса.Псевдоним, КолонкаЗапроса.ТипЗначения));
	        КонецЕсли; 
	    КонецЦикла;
		
	    КешПолейТаблиц.Вставить(ИмяТаблицы, ПоляТаблицы);
		
	КонецЕсли;
	
	Для Каждого Поле Из ПоляТаблицы Цикл
		
		Если Исключения.Свойство(Поле.Имя) Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого ТипДанных Из ТипыДанных Цикл
			Если Поле.ТипЗначения.СодержитТип(ТипДанных) И ИменаПолей.Найти(Поле.Имя) = Неопределено Тогда
				ИменаПолей.Добавить(Поле.Имя);
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
    Возврат ИменаПолей;
	
КонецФункции

Процедура ЗаменитьЗначения(Данные, ИменаПолей, Замены, Заменено = Ложь)
	Для Каждого ИмяПоля Из ИменаПолей Цикл
		НовоеЗначение = НовоеЗначение(Данные[ИмяПоля], Замены);
		Если НовоеЗначение <> Данные[ИмяПоля] Тогда;
			Заменено = Истина;
			Данные[ИмяПоля] = НовоеЗначение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция НовоеЗначение(СтароеЗначение, Замены)
	Для Каждого Замена Из Замены Цикл
		Если СтароеЗначение = Замена.Замещаемое Тогда
			Возврат Замена.Заменитель;
		КонецЕсли;
	КонецЦикла;
	Возврат СтароеЗначение;
КонецФункции

Процедура ЗаписатьДанные(Данные, Принудительно = Ложь)
	Если Данные.Модифицированность() Или Принудительно Тогда
		Данные.ОбменДанными.Загрузка = Истина;
		Данные.Записать();
	КонецЕсли;
КонецПроцедуры

Функция ОтборыРегистраСведений(МетаданныеРегистра, Запись)
	Отборы = Новый Структура;
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		Отборы.Вставить("Период", Запись.Период);
	КонецЕсли;
	Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
		Отборы.Вставить(Измерение.Имя, Запись[Измерение.Имя]);
	КонецЦикла;
	Возврат Отборы;
КонецФункции

Функция НаборЗаписей(МенеджерРегистра, Отборы)
	Набор = МенеджерРегистра.СоздатьНаборЗаписей();
	Для Каждого Отбор Из Отборы Цикл
		Набор.Отбор[Отбор.Ключ].Установить(Отбор.Значение);
	КонецЦикла;
	Набор.Прочитать();
	Возврат Набор;
КонецФункции

Функция ЭтоСсылочныйОбъектМетаданных(ОбъектМетаданных)
	Возврат Метаданные.Справочники.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Документы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Перечисления.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Задачи.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных);
КонецФункции

#КонецОбласти

#Область МетодыДляОтладкиИТестирования

// Показать произвольную выборку данных в отладчике
// Пример:
//	ОбщегоНазначенияУТ.ЗапросВыполнитьВыгрузить("выбрать * из Справочник.Валюты где Валюты.Код = &Код", Новый Структура("Код", "810"))
//
Функция ЗапросВыполнитьВыгрузить(ТекстЗапроса, ПараметрыЗапроса = Неопределено, МенеджерВременныхТаблиц = Неопределено) Экспорт
	
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Если МенеджерВременныхТаблиц <> Неопределено Тогда
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Для Каждого Параметр Из ПараметрыЗапроса Цикл
			Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Показать временную таблицу из менеджера временных таблиц.
// Используется для просмотра временных таблиц в отладчике.
// Пример вызова функции:
//	ОбщегоНазначенияУТ.ПоказатьВременнуюТаблицу(Запрос, "ТаблицаТоваров")
//
Функция ПоказатьВременнуюТаблицу(МенеджерВременныхТаблицИлиЗапрос, ИмяВременнойТаблицы) Экспорт
	
	ЗакрытьМенеджерВременныхТаблиц = Ложь;
	
	Если ТипЗнч(МенеджерВременныхТаблицИлиЗапрос) = Тип("Запрос") Тогда
		Если МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = Неопределено Тогда
			МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
			ЗакрытьМенеджерВременныхТаблиц = Истина;
			МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц; 
		Иначе
			МенеджерВременныхТаблиц = МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц;
		КонецЕсли;
		МенеджерВременныхТаблицИлиЗапрос.Выполнить();
	Иначе
		МенеджерВременныхТаблиц = МенеджерВременныхТаблицИлиЗапрос;
	КонецЕсли; 
	
	ДанныеТаблицы = ЗапросВыполнитьВыгрузить("ВЫБРАТЬ * ИЗ " + ИмяВременнойТаблицы,, МенеджерВременныхТаблиц);
	
	Если ЗакрытьМенеджерВременныхТаблиц Тогда
		МенеджерВременныхТаблиц.Закрыть();
		МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = Неопределено;
	КонецЕсли; 
	
	Возврат ДанныеТаблицы;
	
КонецФункции

// Преобразует таблицу значений в табличный документ и сохраняет его в файл.
//
// Параметры:
//  Таблица									 - ТаблицаЗначений	 - произвольная таблица значений
//  ПолноеИмяФайла							 - Строка			 - полное имя сохраняемого файла, с расширением.
//  Оформить								 - Булево			 - см. описание параметра в функции ОбщегоНазначенияУТ.ТабличныйДокументИзТаблицыЗначений
//  МетаданныеТабличнойЧастиДляЗаголовков	 - ОбъектМетаданных: ТабличнаяЧасть, Неопределено - см. описание
//																		параметра в функции ОбщегоНазначенияУТ.ТабличныйДокументИзТаблицыЗначений
// 
// Возвращаемое значение:
//  Строка - текст сообщения об ошибке или пустая строка, если запись выполнена успешно.
//
// Примеры:
// 	ОбщегоНазначенияУТ.СохранитьТаблицуЗначенийВФайл(Таблица, "c:\temp\таблица.mxl")
//  ОбщегоНазначенияУТ.СохранитьТаблицуЗначенийВФайл(ОбщегоНазначенияУТ.ПоказатьВременнуюТаблицу(МВТ, "Таблица"), "c:\temp\таблица.mxl")
//
Функция СохранитьТаблицуЗначенийВФайл(Таблица, ПолноеИмяФайла, Оформить = Ложь, МетаданныеТабличнойЧастиДляЗаголовков = Неопределено) Экспорт
	
	ВыгрузкаТаблицы = ТабличныйДокументИзТаблицыЗначений(Таблица, Оформить, МетаданныеТабличнойЧастиДляЗаголовков);
	
	// Сохраним табличный документ в файл
	ТекстОшибки = "";
	Попытка
		ВыгрузкаТаблицы.Записать(ПолноеИмяФайла);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат ТекстОшибки;
	
КонецФункции

// Возвращает представление таблицы значений в виде табличного документа
//
// Параметры:
//  Таблица									 - ТаблицаЗначений 
//  Оформить								 - Булево - если передано ИСТИНА, то
//														добавляется пустая строка перед шапкой,
//														шапка выделяется цветом фона, иначе - жирным шрифтом,
//														ширина колонки устанавливается по ширине заголовка, иначе ширина по умолчанию,
//														устанавливаются свойства табличного документа ТолькоПросмотр = Истина,
//  																								  ОтображатьСетку = Ложь,
//																									  ОтображатьЗаголовки = Ложь
//  МетаданныеТабличнойЧастиДляЗаголовков	 - ОбъектМетаданных: ТабличнаяЧасть, Неопределено -
//  											если переданы метаданные, то в шапке таблицы выводятся синонимы полей из метаданных
//                                              если колонка таблицы значений не найдена - она не выводится в табличный документ
//                                              если метаданные не переданы, то в шапке показываются заголовки колонок из таблицы значений,
//                                              	если заголовков нет - показываются имена колонок
// 
// Возвращаемое значение:
//   ТабличныйДокумент 
//
Функция ТабличныйДокументИзТаблицыЗначений(Таблица, Оформить = Ложь, МетаданныеТабличнойЧастиДляЗаголовков = Неопределено) Экспорт
	
	ВыгрузкаТаблицы = Новый ТабличныйДокумент; // преобразованная в mxl таблица значений
	
	Если Оформить Тогда
		НомерСтроки  = 2;
	Иначе
		НомерСтроки  = 1;
	КонецЕсли;	
		
	НомерКолонки = 0;
	
	// Сформируем шапку табличного документа - выведем имена колонок таблицы значений
	Для Каждого ТекКолонка Из Таблица.Колонки Цикл
		
		НомерКолонки = НомерКолонки + 1;
		
		Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
		Если МетаданныеТабличнойЧастиДляЗаголовков = Неопределено Тогда 
			Область.Текст = ?(ЗначениеЗаполнено(ТекКолонка.Заголовок), ТекКолонка.Заголовок, ТекКолонка.Имя);
		Иначе
			Реквизит = МетаданныеТабличнойЧастиДляЗаголовков.Реквизиты.Найти(ТекКолонка.Имя);
			Если Реквизит = Неопределено Тогда
				Область.ШиринаКолонки = 1;
				Продолжить;
			Иначе
				Область.Текст = Реквизит.Синоним;
			КонецЕсли;
		КонецЕсли;
		Область.ГраницаСнизу  = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		Область.ГраницаСверху = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		Область.ГраницаСлева  = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		Область.ГраницаСправа = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		
		Если Оформить Тогда
			Область.ЦветФона = ЦветаСтиля.ИтогиФонГруппы;	
			Область.ШиринаКолонки = СтрДлина(Область.Текст);
		Иначе
			Область.Шрифт    = Новый Шрифт(Область.Шрифт,,, Истина); 
		КонецЕсли;
		
	КонецЦикла;
	
	// Выведем строки таблицы значений
	Для Каждого ТекСтр Из Таблица Цикл
		
		НомерСтроки = НомерСтроки + 1;
		НомерКолонки = 0;
		
		Для Каждого ТекКолонка Из Таблица.Колонки Цикл
			НомерКолонки = НомерКолонки + 1;
			
			Если МетаданныеТабличнойЧастиДляЗаголовков <> Неопределено Тогда 
				Реквизит = МетаданныеТабличнойЧастиДляЗаголовков.Реквизиты.Найти(ТекКолонка.Имя);
				Если Реквизит = Неопределено Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;	
			
			Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
			Область.Текст         = Строка(ТекСтр[ТекКолонка.Имя]);
			Область.ГраницаСнизу  = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
			Область.ГраницаСверху = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
			Область.ГраницаСлева  = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
			Область.ГраницаСправа = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
			
		КонецЦикла;
		
	КонецЦикла;
	
	ВыгрузкаТаблицы.ФиксацияСверху = 1;
	ВыгрузкаТаблицы.ФиксацияСлева  = 1;
	
	Если Оформить Тогда
		
		ВыгрузкаТаблицы.ТолькоПросмотр      = Истина;
		ВыгрузкаТаблицы.ОтображатьСетку     = Ложь;
		ВыгрузкаТаблицы.ОтображатьЗаголовки = Ложь;
		
	КонецЕсли;
	
	Возврат ВыгрузкаТаблицы;
	
КонецФункции

// Считывает таблицу значений из табличного документа.
// Помещение таблицы значений в текстовый документ можно выполнить функцией СохранитьТаблицуЗначенийВФайл().
// В первой строке таблицы должны быть указаны имена колонок таблицы значений,
// в остальных строках - значения в соответствующих ячейках таблицы значений.
// Пример вызова функции:
// 	ОбщегоНазначенияУТ.ПолучитьТаблицуЗначенийИзФайла("c:\temp\таблица.mxl").
//
// Параметры:
//	ПолноеИмяФайла - Строка - полное имя считываемого файла, с расширением.
//
// Возвращаемое значение:
//	Строка 			- если при чтении файла произошла ошибка, то возвращается текст сообщения об ошибке;
//	ТаблицаЗначений - если ошибок не было, то возвращается считанная таблица значений.
//
Функция ПолучитьТаблицуЗначенийИзФайла(ПолноеИмяФайла) Экспорт
	
	ВыгрузкаТаблицы = Новый ТабличныйДокумент; // преобразованная в mxl таблица значений
	
	// Прочитаем файл.
	Попытка
		ВыгрузкаТаблицы.Прочитать(ПолноеИмяФайла);
	Исключение
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Невозможно прочитать таблицу значений из файла ""%1"":
				|%2'"),
			ПолноеИмяФайла,
			ИнформацияОбОшибке());
		
		Возврат ТекстОшибки;
		
	КонецПопытки;
	
	Таблица = Новый ТаблицаЗначений;
	
	Если ВыгрузкаТаблицы.ВысотаТаблицы = 0 ИЛИ ВыгрузкаТаблицы.ШиринаТаблицы = 0 Тогда
		Возврат Таблица;
	КонецЕсли;
	
	// Создадим колонки таблицы значений.
	НомерСтроки = 1;
	
	// В первой строке таблицы должны быть перечислены имена колонок.
	// Если в ячейке первой строки указан текст, не подходящий для имени колонки таблицы значений, то вернем сообщение об ошибке.
	Для НомерКолонки = 1 По ВыгрузкаТаблицы.ШиринаТаблицы Цикл
		
		Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
		ТекстЯчейки = СокрЛП(Область.Текст);
		
		Попытка
			Таблица.Колонки.Добавить(ТекстЯчейки, Новый ОписаниеТипов("Строка"));
		Исключение
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Невозможно прочитать таблицу значений из файла ""%1"":
					|недопустимое имя колонки таблицы значений: ""%2""'"),
				ПолноеИмяФайла,
				ТекстЯчейки);
			
			Возврат ТекстОшибки;
			
		КонецПопытки;
		
	КонецЦикла;
	
	Для НомерСтроки = 2 По ВыгрузкаТаблицы.ВысотаТаблицы Цикл
		
		НоваяСтрока = Таблица.Добавить();
		
		Для НомерКолонки = 1 По ВыгрузкаТаблицы.ШиринаТаблицы Цикл
			
			Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
			ТекстЯчейки = СокрЛП(Область.Текст);
			
			НоваяСтрока[Таблица.Колонки[НомерКолонки - 1].Имя] = ТекстЯчейки;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Таблица;
	
КонецФункции

// Сравнивает построчно указанные таблицы.
//
// Параметры:
//	Таблица1 			   - ТаблицаЗначений - таблица №1
//	Таблица2 			   - ТаблицаЗначений - таблица №2
//	КолонкиДолжныСовпадать - Булево - если Истина, то колонки должны быть идентичны.
//
// Возвращаемое значение:
//	Строка 			- если КолонкиДолжныСовпадать = Истина и колонки таблиц отличаются; возвращается описание отличий в колонках
//	ТаблицаЗначений - во всех остальных случаях; содержит только отличающиеся строки таблиц №1 и №2
//		состав колонок таблицы - общие колонки таблиц №1 и №2
//		служебная колонка "СчетчикСтрокСравниваемыхТаблиц" содержит число отличное от 0:
//			если счетчик > 0, то строка встречается в таблице №1 на указанное количество раз больше
//			если счетчик < 0, то строка встречается в таблице №2 на указанное количество раз больше.
//
Функция СравнитьТаблицыЗначений(Таблица1, Таблица2, КолонкиДолжныСовпадать = Истина) Экспорт
	
	ОписаниеОтличийВКолонках = Новый Массив;
	ОбщиеКолонки = Новый Массив;
	
	// Проверим колонки Таблица1 в Таблица2
	Для Каждого ТекущаяКолонка Из Таблица1.Колонки Цикл
		
		Если Таблица2.Колонки.Найти(ТекущаяКолонка.Имя) = Неопределено Тогда
			
			// Колонка только в Таблица1
			ОписаниеОтличийВКолонках.Добавить(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru='Колонка присутствует только в таблице №1: ""%1""'"),
					ТекущаяКолонка.Имя));
			
		Иначе
			
			// Общая колонка
			ОбщиеКолонки.Добавить(ТекущаяКолонка.Имя);
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверим колонки Таблица2 в Таблица1
	Для Каждого ТекущаяКолонка Из Таблица2.Колонки Цикл
		
		Если Таблица1.Колонки.Найти(ТекущаяКолонка.Имя) = Неопределено Тогда
			
			// Колонка только в Таблица2
			ОписаниеОтличийВКолонках.Добавить(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru='Колонка присутствует только в таблице №2: ""%1""'"),
					ТекущаяКолонка.Имя));
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если КолонкиДолжныСовпадать И ОписаниеОтличийВКолонках.Количество() > 0 Тогда
		Возврат СтрСоединить(ОписаниеОтличийВКолонках, Символы.ПС);
	КонецЕсли;
	
	СтрокаОбщиеКолонки = СтрСоединить(ОбщиеКолонки, ", ");
	
	// Объединим таблицы 1 и 2.
	// При этом в служебную колонку "СчетчикСтрокСравниваемыхТаблиц" запишем число 1 для 1й и -1 для 2й таблицы.
	ТаблицаОтличий = Таблица1.Скопировать(, СтрокаОбщиеКолонки);
	
	ТаблицаОтличий.Колонки.Добавить("СчетчикСтрокСравниваемыхТаблиц", Новый ОписаниеТипов("Число"));
	ТаблицаОтличий.ЗаполнитьЗначения(1, "СчетчикСтрокСравниваемыхТаблиц");
	
	Для Каждого СтрокаТаблицы Из Таблица2 Цикл
		
		НоваяСтрока = ТаблицаОтличий.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);
		
		НоваяСтрока.СчетчикСтрокСравниваемыхТаблиц = -1;
		
	КонецЦикла;
	
	// Свернем строки объединенной таблицы.
	// Строки, в которых СчетчикСтрокСравниваемыхТаблиц <> 0, являются различиями таблиц 1 и 2.
	// Вернем только отличающиеся строки.
	
	ТаблицаОтличий.Свернуть(СтрокаОбщиеКолонки, "СчетчикСтрокСравниваемыхТаблиц");
	
	НайтиИУдалитьСтрокиТаблицыЗначений(
		ТаблицаОтличий,
		Новый Структура("СчетчикСтрокСравниваемыхТаблиц", 0));
	
	Возврат ТаблицаОтличий;
	
КонецФункции

#КонецОбласти

#Область СистемныеОпределяютПоведениеКонфигурации

// Проверяет соблюдение условий открытия базовой версии конфигурации в режиме Предприятие.
//
// Возвращаемое значение:
// 	- если текущая версия конфигурации не является базовой, то возвращается значение Истина.
//  - если текущая версия конфигурации является базовой, то возвращается значение Истина
//	  в случае, если ИБ развернута в файловом варианте и запускается в однопользовательском режиме.
//
Функция ВозможенЗапускБазовойВерсии() Экспорт
	
	Если НЕ СтандартныеПодсистемыСервер.ЭтоБазоваяВерсияКонфигурации() Тогда
		Возврат Истина; // ОК: это не базовая версия
	КонецЕсли;
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая(СтрокаСоединенияИнформационнойБазы()) Тогда
		Возврат Ложь; // не файловая ИБ
	КонецЕсли;
	
	СеансыИнформационнойБазы = ПолучитьСеансыИнформационнойБазы();
	НомерТекущегоСеанса		 = НомерСеансаИнформационнойБазы();
	ЗапрещенныеПриложения	 = ",1CV8,1CV8C,WebClient,WSConnection,COMConnection,";
	
	Для Каждого СеансИБ Из СеансыИнформационнойБазы Цикл
		
		Если СеансИБ.НомерСеанса = НомерТекущегоСеанса Тогда
			Продолжить;
		ИначеЕсли СтрНайти(ЗапрещенныеПриложения, "," + СеансИБ.ИмяПриложения + ",") > 0 Тогда
			Возврат Ложь; // открыты другие сеансы 1С:Предприятия
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина; // ОК: это файловая ИБ в однопользовательском режиме
	
КонецФункции

#КонецОбласти

#Область Версионирование

// Возвращает признак использования версионирования для указанного объекта метаданных.
//
// Параметры:
//  ПолноеИмяОбъекта - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//
// Возвращаемое значение:
//  Булево
//
Функция ИспользоватьВерсионированиеОбъекта(ПолноеИмяОбъекта) Экспорт
	
 	Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ПолноеИмяОбъекта);	
	Возврат ПолучитьФункциональнуюОпцию("ИспользоватьВерсионированиеОбъекта",
		Новый Структура("ТипВерсионируемогоОбъекта", Идентификатор));
		
КонецФункции	

// Включает версионирования для указанного объекта метаданных.
//
// Параметры:
//  ПолноеИмяОбъекта - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//	ВариантВерсионирования - Строка - имя значения перечисления ВариантыВерсионированияОбъектов.
//
// Возвращаемое значение:
//  Булево - Истина, если для указанного объекта было включено версионирование.
//
Функция ВключитьВерсионированиеОбъекта(ПолноеИмяОбъекта, ВариантВерсионирования = "ВерсионироватьПриЗаписи")
	
	ВерсионированиеВключено = Ложь;
	
	ПеречислениеВариантВерсионирования = Перечисления.ВариантыВерсионированияОбъектов[ВариантВерсионирования];
	
	Если НЕ ИспользоватьВерсионированиеОбъекта(ПолноеИмяОбъекта) Тогда
		
		ВерсионированиеОбъектов.ЗаписатьНастройкуВерсионированияПоОбъекту(ПолноеИмяОбъекта, ПеречислениеВариантВерсионирования);
		ВерсионированиеВключено = Истина;
		
	КонецЕсли;
	
	Возврат ВерсионированиеВключено;
	
КонецФункции

// Включает версионирования для указанных объектов метаданных.
//
// Параметры:
//	Объекты - Соответствие
//  	Ключ 	 - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//		Значение - Строка - имя значения перечисления ВариантыВерсионированияОбъектов.
//
// Возвращаемое значение:
//  Булево - Истина, если хотя бы для одного из указанных объектов было включено версионирование.
//
Функция ВключитьВерсионированиеОбъектов(Объекты) Экспорт
	
	ВерсионированиеВключено = Ложь;
	
	Для Каждого КлючИЗначение Из Объекты Цикл
		ВерсионированиеВключено =
			ВключитьВерсионированиеОбъекта(КлючИЗначение.Ключ, КлючИЗначение.Значение)
			ИЛИ ВерсионированиеВключено;
	КонецЦикла;
	
	Возврат ВерсионированиеВключено;
	
КонецФункции

#КонецОбласти

#Область Константы

// Возвращает состав набор констант.
//
// Параметры:
//	Набор - КонстантыНабор
//
// Возвращаемое значение:
//  Структура
//		Ключ - имя константы из набора.
//
Функция ПолучитьСтруктуруНабораКонстант(Набор) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого МетаКонстанта Из Метаданные.Константы Цикл
		Если ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Набор, МетаКонстанта.Имя) Тогда
			Результат.Вставить(МетаКонстанта.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Перечисления

// Получает список выбора для указанного перечисления.
//
// Параметры:
//	ИмяПеречисления 	- Строка - имя перечисления как оно задано в конфигураторе.
//	ДанныеВыбора 		- Список значений - сформированный список выбора перечисления.
//	Параметры 			- Структура - подробнее см. ОбработкаПолученияДанныхВыбора
//	ИсключаемыеЗначения - Массив - значения перечисления, не включаемые в список выбора.
//
Процедура ДоступныеДляВыбораЗначенияПеречисления(ИмяПеречисления, ДанныеВыбора, Параметры, ИсключаемыеЗначения) Экспорт
	
	ДанныеВыбора = Новый СписокЗначений; // результат
	
	Запрос = Новый Запрос;
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ЗначенияПеречисления.Ссылка КАК Ссылка,
	|	ПРЕДСТАВЛЕНИЕ(ЗначенияПеречисления.Ссылка) КАК Представление
	|ИЗ
	|	Перечисление.%ИмяПеречисления% КАК ЗначенияПеречисления
	|ГДЕ
	|	НЕ ЗначенияПеречисления.Ссылка В (&ИсключаемыеЗначения)
	|	//%ТекстОтборПоПараметрам%
	|
	|УПОРЯДОЧИТЬ ПО
	|	ЗначенияПеречисления.Порядок";
	
	Запрос.УстановитьПараметр("ИсключаемыеЗначения", ИсключаемыеЗначения);
	
	Если Параметры.Отбор.Свойство("Ссылка") Тогда
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "//%ТекстОтборПоПараметрам%", "И ЗначенияПеречисления.Ссылка В (&ОтборПоСсылке)");
		
		Запрос.УстановитьПараметр("ОтборПоСсылке", Параметры.Отбор.Ссылка);
		
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(ТекстЗапроса, "%ИмяПеречисления%", ИмяПеречисления);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если НЕ ЗначениеЗаполнено(Параметры.СтрокаПоиска)
		 ИЛИ СтрНайти(НРег(Выборка.Представление), НРег(Параметры.СтрокаПоиска)) = 1 Тогда
			ДанныеВыбора.Добавить(Выборка.Ссылка);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область КонтактнаяИнформация

// Актуализирует значения полей КИ из ее представления.
//
//  Параметры:
//		АдресПредставление - представление КИ
//		АдресЗначенияПолей - служебная информация, значения полей КИ
//		ТипКИ			   - тип контактной информации (Перечисления.ТипыКонтактнойИнформации).
//
Процедура ЗаполнитьЗначенияПолейКИПоПредставлению(Представление, ЗначенияПолей, ТипКИ = Неопределено) Экспорт
	
	Если ТипКИ = Неопределено Тогда
		ТипКИ = Перечисления.ТипыКонтактнойИнформации.Адрес;
	КонецЕсли;
	
	Если УправлениеКонтактнойИнформацией.ПредставлениеКонтактнойИнформации(ЗначенияПолей) = Представление Тогда
		Возврат;
	КонецЕсли;
	
	// Сохраним комментарий из старых значений полей.
	Комментарий = СокрЛП(УправлениеКонтактнойИнформацией.КомментарийКонтактнойИнформации(ЗначенияПолей));
	
	// Сформируем значения полей КИ по представлению.
	ЗначенияПолей = УправлениеКонтактнойИнформацией.КонтактнаяИнформацияПоПредставлению(Представление,	ТипКИ);
	
	Если ЗначениеЗаполнено(Комментарий) Тогда
		// Вернем комментарий обратно.
		УправлениеКонтактнойИнформацией.УстановитьКомментарийКонтактнойИнформации(ЗначенияПолей, Комментарий);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ДополнительныеРеквизитыИСведения

// Служебная. Возвращает наборы доп. реквизитов и сведений, доступных при данных настройках конфигурации.
//
// Возвращаемое значение:
//	Массив, элементы - СправочникСсылка.НаборыДополнительныхРеквизитовИСведений.
//
Функция ДоступныеДопРеквизитыИСведения() Экспорт
	
	ДоступныеСвойства = Новый Массив;
	
	СвязиСвойствИФО = ОбщегоНазначенияУТПовтИсп.СвязиДопРеквизитовИФункциональныхОпций();
	
	Для Каждого КлючИЗначение Из СвязиСвойствИФО Цикл
		
		Если НЕ ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
			
			// Этот набор доп. свойств не зависит от ФО
			ДоступныеСвойства.Добавить(КлючИЗначение.Ключ);
			
		Иначе
			
			РодительскиеФО = Новый Структура(КлючИЗначение.Значение);
			
			Для Каждого ТекущаяФО Из РодительскиеФО Цикл
				Если ПолучитьФункциональнуюОпцию(ТекущаяФО.Ключ) Тогда
					// Включена хотя бы одна ФО, от которой зависит этот набор доп. свойств
					ДоступныеСвойства.Добавить(КлючИЗначение.Ключ);
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ДоступныеСвойства;
	
КонецФункции

#КонецОбласти

#Область Подсистемы

// Добавляет подсистему в коллекцию.
//
// Параметры:
//	Коллекция - Массив или СписокЗначений - коллекция, куда добавляется подсистема из метаданных
//	ИмяПодсистемы - Строка - имя подсистемы
//		подчиненные подсистемы разделяются ".",	служебные слова "Подсистема" или "Подсистемы" указывать не нужно
//	Представление - Строка - представление подсистемы (для списка значений).
//
Процедура ДобавитьПодсистемуВКоллекцию(Коллекция, ИмяПодсистемы, Представление = "") Экспорт
	
	Подсистема = ПодсистемаПоИмени(ИмяПодсистемы);
	Если Подсистема = Неопределено Тогда
		Возврат; // нет такой подсистемы в метаданных
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Представление) Тогда
		Коллекция.Добавить(Подсистема, Представление);
	Иначе
		Коллекция.Добавить(Подсистема);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает метаданные подсистемы по ее имени.
//
// Параметры:
//	ИмяПодсистемы - Строка - имя подсистемы
//		подчиненные подсистемы разделяются ".",	служебные слова "Подсистема" или "Подсистемы" указывать не нужно.
//
// Возвращаемое значение:
//	Объект метаданных - метаданные подсистемы или Неопределено, если подсистемы с таким именем не существует.
//
Функция ПодсистемаПоИмени(ИмяПодсистемы) Экспорт
	
	ПолноеИмяПодсистемы = Сред(СтрЗаменить("." + ИмяПодсистемы, ".", ".Подсистема."), 2);;
	
	Возврат Метаданные.НайтиПоПолномуИмени(ПолноеИмяПодсистемы);
	
КонецФункции

#КонецОбласти

#Область Прочее

Процедура ОбработатьВложенныеПоля(ЭлементыФормы, ЭлементФормы, МассивЭлементов, Структура, ПоляИсключения)
	
	ТипЗнчЭлементФормы = ТипЗнч(ЭлементФормы);
	
	Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы")
		ИЛИ ТипЗнчЭлементФормы = Тип("ГруппаФормы") Тогда
		Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы") Тогда
			ИмяЭлемента = ЭлементФормы.Имя;
			Структура.Вставить(ИмяЭлемента, Новый Массив);
			ОбработатьПоляТаблицыФормы(ЭлементыФормы, ЭлементФормы, Структура[ИмяЭлемента], ПоляИсключения);
		КонецЕсли;
		Для Каждого Элемент Из ЭлементФормы.ПодчиненныеЭлементы Цикл
			Имя = Элемент.Имя;
			ПодчиненныйЭлемент = ЭлементыФормы[Имя];
			ТипЗнчПодчиненныйЭлемент = ТипЗнч(ПодчиненныйЭлемент);
			Если ТипЗнчПодчиненныйЭлемент = Тип("ПолеФормы") Тогда
				Если МассивЭлементов.Найти(Имя) <> Неопределено
					Или ПоляИсключения.Найти(Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивЭлементов.Добавить(Имя);
			ИначеЕсли ТипЗнчПодчиненныйЭлемент = Тип("ГруппаФормы") Тогда
				ОбработатьВложенныеПоля(ЭлементыФормы, ПодчиненныйЭлемент, МассивЭлементов, Структура, ПоляИсключения);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьПоляТаблицыФормы(ЭлементыФормы, ЭлементФормы, МассивЭлементов, ПоляИсключения)
	
	ТипЗнчЭлементФормы = ТипЗнч(ЭлементФормы);
	
	Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы")
		ИЛИ ТипЗнчЭлементФормы = Тип("ГруппаФормы") Тогда
		Для Каждого Элемент Из ЭлементФормы.ПодчиненныеЭлементы Цикл
			ПодчиненныйЭлемент = ЭлементыФормы[Элемент.Имя];
			ТипЗнчПодчиненныйЭлемент = ТипЗнч(ПодчиненныйЭлемент);
			Если ТипЗнчПодчиненныйЭлемент = Тип("ПолеФормы") Тогда
				Если МассивЭлементов.Найти(Элемент.Имя) <> Неопределено
					Или ПоляИсключения.Найти(Элемент.Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивЭлементов.Добавить(Элемент.Имя);
			ИначеЕсли ТипЗнчПодчиненныйЭлемент = Тип("ГруппаФормы") Тогда
				ОбработатьПоляТаблицыФормы(ЭлементыФормы, ПодчиненныйЭлемент, МассивЭлементов, ПоляИсключения);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает идентификатор конфигурации.
// Длина идентификатора не должна превышать 8 символов.
//
Функция ИДКонфигурации() Экспорт
	
	//++ НЕ УТ
	Возврат "КА2"; // в конфигурации КА2
	//-- НЕ УТ
	Возврат "УТ11" + ?(СтандартныеПодсистемыСервер.ЭтоБазоваяВерсияКонфигурации(), "Базовая", ""); // в конфигурации УТ11
	
КонецФункции

Функция ПолучитьПрефиксДляУИП(Ссылка)

	Соответствие = Новый Соответствие();
	Соответствие.Вставить("ДоговорыКонтрагентов",				"ДОГ");
	Соответствие.Вставить("АктВыполненныхРабот",				"АКТ");
	Соответствие.Вставить("ВозвратТоваровПоставщику",			"НКВ");
	Соответствие.Вставить("ВыкупВозвратнойТарыКлиентом",		"НК");
	Соответствие.Вставить("ЗаказКлиента",						"ЗК");
	Соответствие.Вставить("ЗаявкаНаВозвратТоваровОтКлиента",	"ЗКВ");
	Соответствие.Вставить("ОтчетКомиссионера",					"ОК");
	Соответствие.Вставить("ОтчетКомиссионераОСписании",			"ОКС");
	Соответствие.Вставить("ОтчетКомитенту",						"ОКТ");
	Соответствие.Вставить("ОтчетПоКомиссииМеждуОрганизациями",	"ОКО");
	Соответствие.Вставить("РеализацияТоваровУслуг",				"НК");
	Соответствие.Вставить("РеализацияУслугПрочихАктивов",		"НК");
	Соответствие.Вставить("ПередачаТоваровМеждуОрганизациями",	"НК");
	Соответствие.Вставить("СчетНаОплатуКлиенту",				"СЧ");
	Соответствие.Вставить("СчетФактураВыданный",				"СФ");
	
	Возврат Соответствие[Ссылка.Метаданные().Имя];
	
КонецФункции

Функция ПолучитьУникальныйИдентификаторПлатежаСКонтрольнымРазрядом(Код,Сдвиг = Неопределено)
	
	Если Сдвиг = Неопределено Тогда
		Сдвиг = 0;
	КонецЕсли;
	
	СтруктураСоответствий = СтруктураСоответствийБуквИЦифр();
	
	СтрокаЦифр = "0123456789";	
	ВесРазряда = 1+Сдвиг;
	Результат = 0;
	// Замена служебных символов в коде.
	СтрокаБукв = "АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЭЮЯЪЫЬABCDEFGHIJKLMNOPQRSTUVWXYZ";
	НовКод = "";
	Для Инд = 1 По СтрДлина(Код) Цикл
		Попытка
			СимволКода = ВРЕГ(Сред(Код,Инд,1));
		Исключение
			СимволКода = Сред(Код,Инд,1);
		КонецПопытки;
		Если СтрНайти(СтрокаЦифр,СимволКода)=0 И СтрНайти(СтрокаБукв,СимволКода)=0 Тогда
			НовКод = НовКод + "0";
		Иначе
			НовКод = НовКод + СимволКода;
		КонецЕсли;
	КонецЦикла;
	Код = НовКод;
	//Конец замены
	Если СтрДлина(Код)<19 Тогда
		СтрокаКода = СтроковыеФункцииКлиентСервер.ДополнитьСтроку(Код,19,"0","Справа");
	Иначе
		СтрокаКода = Лев(Код,19);
	КонецЕсли;
	
	Для Инд = 1 По 19 Цикл 
		СимволКода = Сред(СтрокаКода,Инд,1);
		Если СтрНайти(СтрокаЦифр,СимволКода)>0 Тогда
			Значение = Число(СимволКода);
		ИначеЕсли СтруктураСоответствий.Свойство(ВРег(СимволКода)) Тогда
			Значение = СтруктураСоответствий[СимволКода]%10;			
		КонецЕсли;		
		Результат = Результат + ВесРазряда*Значение;
		
		ВесРазряда = ВесРазряда + 1;
		Если ВесРазряда = 11 Тогда
			ВесРазряда = 1;
		КонецЕсли;
	КонецЦикла;
	
	КонтрольныйРазряд = Результат % 11;
	
	Если КонтрольныйРазряд = 10 Тогда
		Если Сдвиг = 0 Тогда
			Возврат ПолучитьУникальныйИдентификаторПлатежаСКонтрольнымРазрядом(Код,2);
		Иначе
			КонтрольныйРазряд = 0;
		КонецЕсли;
	КонецЕсли;
	
	ПолныйКод = СтрокаКода+Строка(КонтрольныйРазряд);
	
	Возврат ПолныйКод;
	
КонецФункции

Функция СтруктураСоответствийБуквИЦифр()
	
	СтруктураСоответствий = Новый Структура();
	
	СтруктураСоответствий.Вставить("А", 1);
	СтруктураСоответствий.Вставить("Б", 2);
	СтруктураСоответствий.Вставить("В", 3);
	СтруктураСоответствий.Вставить("Г", 4);
	СтруктураСоответствий.Вставить("Д", 5);
	СтруктураСоответствий.Вставить("Е", 6);
	СтруктураСоответствий.Вставить("Ж", 7);
	СтруктураСоответствий.Вставить("З", 8);
	СтруктураСоответствий.Вставить("И", 9);
	СтруктураСоответствий.Вставить("К", 10);
	СтруктураСоответствий.Вставить("Л", 11);
	СтруктураСоответствий.Вставить("М", 12);
	СтруктураСоответствий.Вставить("Н", 13);
	СтруктураСоответствий.Вставить("О", 14);
	СтруктураСоответствий.Вставить("П", 15);
	СтруктураСоответствий.Вставить("Р", 16);
	СтруктураСоответствий.Вставить("С", 17);
	СтруктураСоответствий.Вставить("Т", 18);
	СтруктураСоответствий.Вставить("У", 19);
	СтруктураСоответствий.Вставить("Ф", 20);
	СтруктураСоответствий.Вставить("Х", 21);
	СтруктураСоответствий.Вставить("Ц", 22);
	СтруктураСоответствий.Вставить("Ч", 23);
	СтруктураСоответствий.Вставить("Ш", 24);
	СтруктураСоответствий.Вставить("Щ", 25);
	СтруктураСоответствий.Вставить("Э", 26);
	СтруктураСоответствий.Вставить("Ю", 27);
	СтруктураСоответствий.Вставить("Я", 28);
	СтруктураСоответствий.Вставить("Ъ", 33);
	СтруктураСоответствий.Вставить("Ы", 36);
	СтруктураСоответствий.Вставить("Ь", 46);
	СтруктураСоответствий.Вставить("A", 1);
	СтруктураСоответствий.Вставить("B", 3);
	СтруктураСоответствий.Вставить("C", 17);
	СтруктураСоответствий.Вставить("D", 29);
	СтруктураСоответствий.Вставить("E", 6);
	СтруктураСоответствий.Вставить("F", 30);
	СтруктураСоответствий.Вставить("G", 31);
	СтруктураСоответствий.Вставить("H", 13);
	СтруктураСоответствий.Вставить("I", 32);
	СтруктураСоответствий.Вставить("J", 33);
	СтруктураСоответствий.Вставить("K", 10);
	СтруктураСоответствий.Вставить("L", 34);
	СтруктураСоответствий.Вставить("M", 12);
	СтруктураСоответствий.Вставить("N", 35);
	СтруктураСоответствий.Вставить("O", 14);
	СтруктураСоответствий.Вставить("P", 16);
	СтруктураСоответствий.Вставить("Q", 36);
	СтруктураСоответствий.Вставить("R", 37);
	СтруктураСоответствий.Вставить("S", 38);
	СтруктураСоответствий.Вставить("T", 18);
	СтруктураСоответствий.Вставить("U", 39);
	СтруктураСоответствий.Вставить("V", 40);
	СтруктураСоответствий.Вставить("W", 41);
	СтруктураСоответствий.Вставить("X", 21);
	СтруктураСоответствий.Вставить("Y", 19);
	СтруктураСоответствий.Вставить("Z", 42);
	
	Возврат СтруктураСоответствий;
	
КонецФункции

// Возвращает свернутую копию таблицы
//
// Параметры:
//  Таблица					 - ТаблицаЗначений, ТабличнаяЧасть	 - Исходная таблица
//  КолонкиГруппировок		 - Строка							 - Имена колонок, по которым необходимо группировать строки.
//  ДополнительныеАналитики	 - Строка							 - Имена колонок, по которым необходимо группировать строки, если они есть в исходной таблице.
//  КолонкиСуммирования		 - Строка							 - Имена колонок, по которым необходимо суммировать значения.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - свернутая копия таблицы значений
//
Функция СвернутаяКопияТаблицы(Таблица, Знач КолонкиГруппировок, Знач ДополнительныеАналитики = Неопределено, Знач КолонкиСуммирования = Неопределено) Экспорт
	
	Если ДополнительныеАналитики <> Неопределено Тогда
		
		СоставДопАналитик = СтрРазделить(ДополнительныеАналитики, ",", Ложь);
		
		Для Индекс = -СоставДопАналитик.ВГраница() По 0 Цикл
			ИмяКолонки = СокрЛП(СоставДопАналитик[-Индекс]);
			Если Таблица.Колонки.Найти(ИмяКолонки) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			СоставДопАналитик.Удалить(-Индекс);
		КонецЦикла;
		
		Если СоставДопАналитик.Количество() <> 0 Тогда
			КолонкиГруппировок = КолонкиГруппировок + "," + СтрСоединить(СоставДопАналитик, ",");
		КонецЕсли;
		
	КонецЕсли;
	
	Если КолонкиСуммирования <> Неопределено Тогда
		НовыйСоставКолонок = КолонкиГруппировок + "," + КолонкиСуммирования;
	Иначе
		НовыйСоставКолонок = КолонкиГруппировок;
	КонецЕсли;
	
	Если ТипЗнч(Таблица) <> Тип("ТаблицаЗначений") Тогда
		ВременнаяТаблица = Таблица.Выгрузить(, НовыйСоставКолонок);
	Иначе
		ВременнаяТаблица = Таблица.Скопировать(, НовыйСоставКолонок);
	КонецЕсли;
	
	ВременнаяТаблица.Свернуть(КолонкиГруппировок, КолонкиСуммирования);
	
	Возврат ВременнаяТаблица;
	
КонецФункции

// Возвращает массив уникальных значений из колонки таблицы
//
// Параметры:
//  Таблица    - ТаблицаЗначений, ДанныеФормыКоллекция, ТабличнаяЧасть - таблица, из которой необходимо выбрать данные
//  ИмяКолонки - Строка - имя колонки таблицы значений, из которой необходимо выбрать значения.
// 
// Возвращаемое значение:
//  Массив - набор уникальных значений.
//
Функция ВыгрузитьЗначенияКолонки(Таблица, ИмяКолонки) Экспорт
	
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		ТаблицаКопия = Таблица.Скопировать(, ИмяКолонки);
	Иначе
		ТаблицаКопия = Таблица.Выгрузить(, ИмяКолонки);
	КонецЕсли;
	
	ТаблицаКопия.Свернуть(ИмяКолонки);
	
	Возврат ТаблицаКопия.ВыгрузитьКолонку(0);
	
КонецФункции

// Возвращает таблицу значений с данными дерева значений
//
// Параметры:
//  ДеревоДанных - ДеревоЗначений - дерево с данными
//  Уровень		 - Число - уровень дерева, на котором расположены искомые данные (нумерация с 0). Если не передано, то 
//						   будут возвращенные данные со всех последних уровней веток.
//
// Возвращаемое значение:
//  ТаблицаЗначений - содержит данные дерева.
//
Функция ДанныеДерева(ДеревоДанных, Уровень = Неопределено) Экспорт
	
	ТаблицаВозврата = Новый ТаблицаЗначений;
	Для Каждого Колонка Из ДеревоДанных.Колонки Цикл
		ТаблицаВозврата.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	
	СтрокиДерева = ДеревоДанных.Строки;
	
	ЗаполнитьТаблицуРекурсивно(ТаблицаВозврата, СтрокиДерева, Уровень, 0);
	
	Возврат ТаблицаВозврата;

КонецФункции

Процедура ЗаполнитьТаблицуРекурсивно(ТаблицаЗначений, СтрокиДерева, ИскомыйУровень, ТекущийУровень)
	
	Для Каждого Строка Из СтрокиДерева Цикл

		Если ТипЗнч(СтрокиДерева) = Тип("КоллекцияСтрокДереваЗначений") Тогда
			Подстроки = Строка.Строки;
		ИначеЕсли ТипЗнч(СтрокиДерева) = Тип("ДанныеФормыКоллекцияЭлементовДерева") Тогда
			Подстроки = Строка.ПолучитьЭлементы();
		КонецЕсли;
		
		Если ИскомыйУровень = ТекущийУровень 
			Или (ИскомыйУровень = Неопределено И Подстроки.Количество() = 0) Тогда
			НовСтрока = ТаблицаЗначений.Добавить();
			ЗаполнитьЗначенияСвойств(НовСтрока, Строка);
		Иначе
			ЗаполнитьТаблицуРекурсивно(ТаблицаЗначений, Подстроки, ИскомыйУровень, ТекущийУровень + 1);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает свойства последнего задания.
//
// Параметры:
//  Задание - РегламентноеЗадание, Строка, ОчередьЗаданийОбластейДанных - строка уникального идентификатора РегламентногоЗадания.
//
// Возвращаемое значение:
//  СтруктураСвойств.
//
Функция ПолучитьСостояниеПоследнегоЗадания(Задание) Экспорт
	
	СвойстваЗадания = Новый Структура("ДатаНачала, ДатаЗавершения, Состояние");
	
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		
		ЭлементСправочника = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Задание.Идентификатор, "ДатаНачалаПоследнегоЗапуска, ДатаЗавершенияПоследнегоЗапуска, СостояниеЗадания");
		
		СвойстваЗадания.ДатаНачала = ЭлементСправочника.ДатаНачалаПоследнегоЗапуска;
		СвойстваЗадания.ДатаЗавершения = ЭлементСправочника.ДатаЗавершенияПоследнегоЗапуска;
		СвойстваЗадания.Состояние = ЭлементСправочника.СостояниеЗадания;
		
	Иначе
		
		РегламентныеЗаданияСлужебный.ВызватьИсключениеЕслиНетПраваАдминистрирования();
		УстановитьПривилегированныйРежим(Истина);
		
		ИдентификаторРегламентногоЗадания = ?(ТипЗнч(Задание) = Тип("РегламентноеЗадание"), Строка(Задание.УникальныйИдентификатор), Задание);
		Отбор = Новый Структура;
		Отбор.Вставить("ИдентификаторРегламентногоЗадания", ИдентификаторРегламентногоЗадания);
		Отбор.Вставить("ПолучитьПоследнееФоновоеЗаданиеРегламентногоЗадания");
		ТаблицаСвойствФоновыхЗаданий = РегламентныеЗаданияСлужебный.СвойстваФоновыхЗаданий(Отбор);
		ТаблицаСвойствФоновыхЗаданий.Сортировать("Конец Возр");
		
		Если ТаблицаСвойствФоновыхЗаданий.Количество() = 0 Тогда
			СвойстваРегЗадания = Неопределено;
		ИначеЕсли НЕ ЗначениеЗаполнено(ТаблицаСвойствФоновыхЗаданий[0].Конец) Тогда
			СвойстваРегЗадания = ТаблицаСвойствФоновыхЗаданий[0];
		Иначе
			СвойстваРегЗадания = ТаблицаСвойствФоновыхЗаданий[ТаблицаСвойствФоновыхЗаданий.Количество()-1];
		КонецЕсли;
		
		Если СвойстваРегЗадания <> Неопределено Тогда
		
			СвойстваЗадания.ДатаНачала = СвойстваРегЗадания.Начало;
			СвойстваЗадания.ДатаЗавершения = СвойстваРегЗадания.Конец;
			СвойстваЗадания.Состояние = СвойстваРегЗадания.Состояние;
		
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СвойстваЗадания;
	
КонецФункции

Функция СвойствоМетаданных(МетаданныеОбъекта, ЧастиИмени, Индекс = 0)
	
	Имя = ЧастиИмени[Индекс];
	Свойство = МетаданныеОбъекта[Имя];
	Если Индекс < ЧастиИмени.ВГраница() Тогда
		Свойство = СвойствоМетаданных(Свойство, ЧастиИмени, Индекс+1);
	КонецЕсли;
	Возврат Свойство;
	
КонецФункции

// Проверяет, что переданный тип - примитивный
//
// Параметры:
//  ПроверяемыйТип	 - Тип - 
// 
// Возвращаемое значение:
//  Булево 
//
Функция ЭтоПримитивныйТип(ПроверяемыйТип) Экспорт
	
	Если ПроверяемыйТип = Тип("Неопределено")
		Или ПроверяемыйТип = Тип("Булево")
		Или ПроверяемыйТип = Тип("Строка")
		Или ПроверяемыйТип = Тип("Число")
		Или ПроверяемыйТип = Тип("Дата")
		Или ПроверяемыйТип = Тип("УникальныйИдентификатор") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции

// Представление объекта по метаданным
//
// Параметры:
//  МетаданныеОбъекта	 - ОбъектМетаданных.
// 
// Возвращаемое значение:
//  Строка 
//
Функция ПредставлениеОбъектаПоМетаданным(МетаданныеОбъекта) Экспорт
		
	Если Не ПустаяСтрока(МетаданныеОбъекта.ПредставлениеОбъекта) Тогда
		Возврат МетаданныеОбъекта.ПредставлениеОбъекта;
	Иначе
		Возврат МетаданныеОбъекта.Синоним;
	КонецЕсли;
	
КонецФункции

// Получает склад который можно использовать по умолчанию
// Если склад не удалось определить и не используется несколько складов то пользователю выдается сообщение.
// 
// Возвращаемое значение:
//   СправочникСсылка.Склады
//
Функция ПолучитьПроверитьСкладПоУмолчанию() Экспорт

	СкладПоУмолчанию = ЗначениеНастроекПовтИсп.ПолучитьСкладПоУмолчанию();
	
	Если Не ЗначениеЗаполнено(СкладПоУмолчанию)
		И Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоСкладов") Тогда
		
		Запрос = Новый Запрос(
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
		|	Склады.Ссылка
		|ИЗ
		|	Справочник.Склады КАК Склады");
		
		Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
			ВызватьИсключение НСтр("ru = 'Не удалось определить склад, т.к. в информационной базе введено несколько складов,
			|Включите опцию ""НСИ и администрирование""-""Склад и доставка""-""Несколько складов""!'");
		Иначе
			ВызватьИсключение НСтр("ru = 'Не удалось определить склад. Возможно, в информационной базе не введено ни одного склада
			|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка складского учета"".'");
		КонецЕсли;
		
	КонецЕсли;

	Возврат СкладПоУмолчанию
	
КонецФункции

// Устанавливаем условное оформление для поля формы "ВариантОформления" в документе ТаможеннаяДекларация
//    в зависимости от его значения.
//
// Параметры:
// 		Список - Форма - Содержит данную форму.
//
Процедура УстановитьУсловноеОформлениеВариантОформленияГТД(Список) Экспорт
	
	УсловноеОформление = Список.УсловноеОформление;
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных("ВариантОформления");

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ВариантОформления");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Перечисления.ХозяйственныеОперации.ОформлениеГТДБрокером;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'Брокером'"));
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных("ВариантОформления");

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ВариантОформления");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Перечисления.ХозяйственныеОперации.ОформлениеГТДСамостоятельно;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'Самостоятельно'"));
	
КонецПроцедуры

Функция РазделительЗапросовПакета(ИмяЗапроса = Неопределено) Экспорт
	
	Текст = "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|" + ?(ЗначениеЗаполнено(ИмяЗапроса), "// "+ ИмяЗапроса, "") + "
	|";
	
	Возврат Текст;
	
КонецФункции

Функция ЭтоЗаписьВедомогоРегистраСведений(Ссылка, Регистры)
	
	Для Каждого Элемент Из Регистры Цикл
		Если ТипЗнч(Ссылка) = Тип("РегистрСведенийКлючЗаписи." + Элемент.Имя) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция НазначенияЗаказов(МассивЗаказов)
	
	Запрос = Новый Запрос();
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Таблица.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.Назначения КАК Таблица
		|ГДЕ
		|	Таблица.Заказ В(&МассивЗаказов)";
	Запрос.УстановитьПараметр("МассивЗаказов", МассивЗаказов);
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

// Переносит файл от прежнего владельца к новому
//
// Параметры:
//	ВладелецФайла - Ссылка - ссылка на новый объект-владелец файла
//	РеквизитПриемник - Ссылка на справочник присоединенных файлов - Значение переменной-приемника ссылки на новый файл
//	РеквизитИсточник - Ссылка на справочник присоединенных файлов - Значение переменной-источника ссылки на новый файл
//	ФормироватьНовуюСсылкуНаФайл - Булево - указывает создавать ли файл с новой ссылкой или использовать текущую.
//
Процедура СкопироватьПрисоединенныйФайл(ВладелецФайла, РеквизитПриемник, РеквизитИсточник, ФормироватьНовуюСсылкуНаФайл = Истина) Экспорт
	ФайлИсточник = РаботаСФайлами.ДанныеФайла(РеквизитИсточник, Новый УникальныйИдентификатор, Истина);
	
	Параметры = Новый Структура;
	Параметры.Вставить("Автор", Пользователи.ТекущийПользователь());
	Параметры.Вставить("ВладелецФайлов", ВладелецФайла);
	Параметры.Вставить("ИмяБезРасширения", ФайлИсточник.Наименование);
	Параметры.Вставить("РасширениеБезТочки", ФайлИсточник.Расширение);
	Параметры.Вставить("ВремяИзмененияУниверсальное", ФайлИсточник.ДатаМодификацииУниверсальная);
	
	ИмяСправочника = РаботаСФайламиСлужебный.ИмяСправочникаХраненияФайлов(ВладелецФайла,, Неопределено);
	
	РеквизитПриемник = РаботаСФайлами.ДобавитьФайл(
		Параметры,
		ФайлИсточник.СсылкаНаДвоичныеДанныеФайла,,
		РеквизитИсточник.Описание,
		?(ФормироватьНовуюСсылкуНаФайл, 
			Неопределено, 
			Справочники[ИмяСправочника].ПолучитьСсылку(РеквизитИсточник.УникальныйИдентификатор())
		)
	);
КонецПроцедуры

// Возвращает хеш сумму переданного объекта
//
// Параметры:
//	СериализуемыйОбъект - Произвольный - объект, который может быть сериализован. В противном случае будет выдано исключение.
//	ТипХешФункции - ХешФункция - один из типов хеш-функции CRC32, MD5, SHA1, SHA256.
//
// Возвращаемое значение:
//  Строка - хеш-сумма в виде строки.
//
Функция ХешСуммаСериализуемогоОбъекта(СериализуемыйОбъект, ТипХешФункции) Экспорт
	СериализованнаяСтрока = ОбщегоНазначения.ЗначениеВСтрокуXML(СериализуемыйОбъект);
	
	ХешированиеДанных = Новый ХешированиеДанных(ТипХешФункции);
	ХешированиеДанных.Добавить(СериализованнаяСтрока);
	ХешСумма = СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	
	Возврат ХешСумма;
КонецФункции

// Возвращает хеш сумму переданного объекта
//
// Параметры:
//	ИсходнаяСтрока - Строка - строка, по которой будет строится хеш. В противном случае будет выдано исключение.
//	ТипХешФункции - ХешФункция - один из типов хеш-функции CRC32, MD5, SHA1, SHA256.
//
// Возвращаемое значение:
//  Строка - хеш-сумма в виде строки.
//
Функция ХешСуммаСтроки(ИсходнаяСтрока, ТипХешФункции) Экспорт
	Если Не ТипЗнч(ИсходнаяСтрока) = Тип("Строка") Тогда
		ВызватьИсключение НСтр("ru = 'Недопустимый тип источника получения данных.'");
	КонецЕсли;
	
	ХешированиеДанных = Новый ХешированиеДанных(ТипХешФункции);
	ХешированиеДанных.Добавить(ИсходнаяСтрока);
	ХешСумма = СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	
	Возврат ХешСумма;
КонецФункции

// Выполняет добавление строк из таблицы источника в таблицу приемник с предварительной проверкой:
// - типов колонок
// - состава колонок
// При необходимости выполняет корректировку таблицы-приемника.
//
Процедура ОбъединитьТаблицыРезультатовЗапроса(ТаблицаИсточник, ТаблицаПриемник)
	
	КолонкиДляОбъединенияТипов = Новый Структура();
	КолонкиДляДобавления = Новый Структура();
	Для каждого КолонкаИсточника Из ТаблицаИсточник.Колонки Цикл
		КолонкаПриемника = ТаблицаПриемник.Колонки.Найти(КолонкаИсточника.Имя);
		Если КолонкаПриемника <> Неопределено Тогда
			
			КолонкаИсточникаТипы = КолонкаИсточника.ТипЗначения.Типы();
			ОтсутствующиеТипы = Новый Массив;
			
			// Проверим наличие типов входящих в описание источника в приемнике.
			// Если отсутствуют - объединим описания типов, пересоздадим колонки таблицы.
			Для каждого ТипКолонкиИсточника Из КолонкаИсточникаТипы Цикл
				Если НЕ КолонкаПриемника.ТипЗначения.СодержитТип(ТипКолонкиИсточника) Тогда
					ОтсутствующиеТипы.Добавить(ТипКолонкиИсточника);
				КонецЕсли;
			КонецЦикла;
			
			// Сравним квалификаторы примитивных типов источника и приемника.
			// Если в описании типов источника квалификаторы "более общие", то возьмем их.
			ИзменитьКвалификаторыЧисла = Ложь;
			КвалификаторыЧисла = КолонкаПриемника.ТипЗначения.КвалификаторыЧисла;
			Если КолонкаИсточника.ТипЗначения.СодержитТип(Тип("Число")) И КолонкаПриемника.ТипЗначения.СодержитТип(Тип("Число")) Тогда
				КвалификаторыЧислаИсточника = КолонкаИсточника.ТипЗначения.КвалификаторыЧисла;  
				Если КвалификаторыЧислаИсточника.Разрядность > КвалификаторыЧисла.Разрядность Тогда
					Разрядность = КвалификаторыЧислаИсточника.Разрядность;
					ИзменитьКвалификаторЧисла = Истина;
				Иначе
					Разрядность = КвалификаторыЧисла.Разрядность;
				КонецЕсли;
				Если КвалификаторыЧислаИсточника.РазрядностьДробнойЧасти > КвалификаторыЧисла.РазрядностьДробнойЧасти Тогда
					РазрядностьДробнойЧасти = КвалификаторыЧислаИсточника.РазрядностьДробнойЧасти;
					ИзменитьКвалификаторыЧисла = Истина;
				Иначе
					РазрядностьДробнойЧасти = КвалификаторыЧисла.РазрядностьДробнойЧасти;
				КонецЕсли;
				Если КвалификаторыЧислаИсточника.ДопустимыйЗнак <> КвалификаторыЧисла.ДопустимыйЗнак Тогда
					Знак = ДопустимыйЗнак.Любой;
					ИзменитьКвалификаторыЧисла = Истина;
				Иначе
					Знак = КвалификаторыЧисла.ДопустимыйЗнак;
				КонецЕсли;
				Если ИзменитьКвалификаторыЧисла Тогда
					КвалификаторыЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, Знак);
				КонецЕсли;
			КонецЕсли;
			
			ИзменитьКвалификаторыСтроки = Ложь;
			КвалификаторыСтроки = КолонкаПриемника.ТипЗначения.КвалификаторыСтроки;
			Если КолонкаИсточника.ТипЗначения.СодержитТип(Тип("Строка")) 
				 И КолонкаПриемника.ТипЗначения.СодержитТип(Тип("Строка")) Тогда
				КвалификаторыСтрокиИсточника = КолонкаИсточника.ТипЗначения.КвалификаторыСтроки;
				Если КвалификаторыСтроки.Длина <> 0 И КвалификаторыСтрокиИсточника.Длина > КвалификаторыСтроки.Длина Тогда
					ИзменитьКвалификаторЧисла = Истина;
					КвалификаторыСтроки = Новый КвалификаторыСтроки(КвалификаторыСтрокиИсточника.Длина);
				КонецЕсли; 
			КонецЕсли;
			
			ИзменитьКвалификаторыДаты = Ложь;
			КвалификаторыДаты = КолонкаПриемника.ТипЗначения.КвалификаторыДаты;
			Если КолонкаИсточника.ТипЗначения.СодержитТип(Тип("Дата")) 
				 И КолонкаПриемника.ТипЗначения.СодержитТип(Тип("Дата")) Тогда
				КвалификаторыДатыИсточника = КолонкаИсточника.ТипЗначения.КвалификаторыДаты;
				Если КвалификаторыДатыИсточника.ЧастиДаты <> КвалификаторыДаты.ЧастиДаты Тогда
					ИзменитьКвалификаторыДаты = Истина;
					КвалификаторыДаты = Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя);
				КонецЕсли; 
			КонецЕсли;
			
			ИзменитьКвалификаторыДвоичныхДанных = Ложь;
			КвалификаторыДвоичныхДанных = КолонкаПриемника.ТипЗначения.КвалификаторыДвоичныхДанных;
			Если КолонкаИсточника.ТипЗначения.СодержитТип(Тип("ДвоичныеДанные")) 
				 И КолонкаПриемника.ТипЗначения.СодержитТип(Тип("ДвоичныеДанные")) Тогда
				КвалификаторыДвоичныхДанныхИсточника = КолонкаИсточника.ТипЗначения.КвалификаторыДвоичныхДанных;
				Если КвалификаторыДвоичныхДанных.Длина <> 0 И КвалификаторыДвоичныхДанныхИсточника.Длина > КвалификаторыДвоичныхДанных.Длина Тогда
					ИзменитьКвалификаторыДвоичныхДанных = Истина;
					КвалификаторыДвоичныхДанных = Новый КвалификаторыДвоичныхДанных(КвалификаторыДвоичныхДанныхИсточника.Длина);
				КонецЕсли; 
			КонецЕсли;
			
			Если ОтсутствующиеТипы.Количество() > 0
				Или ИзменитьКвалификаторыЧисла 
				Или ИзменитьКвалификаторыСтроки 
				Или ИзменитьКвалификаторыДаты
				Или ИзменитьКвалификаторыДвоичныхДанных Тогда
				ОписаниеТиповОбъединение = Новый ОписаниеТипов(КолонкаПриемника.ТипЗначения, ОтсутствующиеТипы, , 
				                                               КвалификаторыЧисла, КвалификаторыСтроки, КвалификаторыДаты, КвалификаторыДвоичныхДанных);
				КолонкиДляОбъединенияТипов.Вставить(КолонкаПриемника.Имя, ОписаниеТиповОбъединение);
			КонецЕсли;
		Иначе
			КолонкиДляДобавления.Вставить(КолонкаИсточника.Имя, КолонкаИсточника.ТипЗначения)
		КонецЕсли;
	КонецЦикла;
	
	Для каждого Колонка Из КолонкиДляОбъединенияТипов Цикл
		ЗначенияВКолонке = ТаблицаПриемник.ВыгрузитьКолонку(Колонка.Ключ);
		ТаблицаПриемник.Колонки.Удалить(Колонка.Ключ);
		ТаблицаПриемник.Колонки.Добавить(Колонка.Ключ, Колонка.Значение);
		ТаблицаПриемник.ЗагрузитьКолонку(ЗначенияВКолонке, Колонка.Ключ);
	КонецЦикла;
	
	Для каждого Колонка Из КолонкиДляДобавления Цикл
		ТаблицаПриемник.Колонки.Добавить(Колонка.Ключ, Колонка.Значение);
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(ТаблицаИсточник, ТаблицаПриемник);
	
КонецПроцедуры

Процедура ПроверитьИспользованиеРеквизитаПолучитьПустоеЗначение(Объект, МетаданныеОбъекта, ИмяРеквизита, ПустыеЗначенияРеквизитов)
	
	Если ПустыеЗначенияРеквизитов.Свойство(ИмяРеквизита) Тогда
		Возврат;
	КонецЕсли;
	
	МетаданныеРеквизита = МетаданныеОбъекта.Реквизиты.Найти(ИмяРеквизита);
	
	Если МетаданныеРеквизита = Неопределено Тогда
		
		Для Каждого СтандартныйРеквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
			Если СтандартныйРеквизит.Имя = ИмяРеквизита Тогда
				МетаданныеРеквизита = СтандартныйРеквизит;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если МетаданныеРеквизита = Неопределено Тогда
			ТекстИсключения = НСтр("ru = 'Реквизит %ИмяРеквизита% не найден в %ИмяОъекта%. Ошибка в описании параметров синхронизации с ключами.'");
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяРеквизита%", ИмяРеквизита);
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяОъекта%", МетаданныеОбъекта.ПолноеИмя());
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
	Иначе
		
		Если (ОбщегоНазначения.ЭтоСправочник(МетаданныеОбъекта)
			Или ОбщегоНазначения.ЭтоПланВидовХарактеристик(МетаданныеОбъекта))
			И (МетаданныеОбъекта.Иерархический
			И МетаданныеОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов) Тогда
			
			Если МетаданныеРеквизита.Использование <> Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппыИЭлемента Тогда
				
				Если (Объект.ЭтоГруппа
					И МетаданныеРеквизита.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
					Или (Не Объект.ЭтоГруппа
					И МетаданныеРеквизита.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы) Тогда
					
					ПустыеЗначенияРеквизитов.Вставить(ИмяРеквизита, "Неиспользуется");
					Возврат;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ПустыеЗначенияРеквизитов.Вставить(ИмяРеквизита,	МетаданныеРеквизита.Тип.ПривестиЗначение()); 
		
КонецПроцедуры

#КонецОбласти

#Область РаботаСЖурналамиДокументов 

Процедура ЗаполнитьОтборыПоТаблицеХозОперацийИТиповДокументов(ТаблицаЗначенийДоступно, ОтборХозяйственныеОперации, ОтборТипыДокументов) Экспорт
	
	СтруктураОтбора = Новый Структура("Отбор", Истина);
	ТЗХозОперацииИТипыДокументов = ТаблицаЗначенийДоступно.Скопировать(СтруктураОтбора, "ХозяйственнаяОперация,ИдентификаторОбъектаМетаданных");
	
	ТЗХозОперации = ТЗХозОперацииИТипыДокументов.Скопировать(,"ХозяйственнаяОперация");
	ТЗХозОперации.Свернуть("ХозяйственнаяОперация");
	ОтборХозяйственныеОперации.ЗагрузитьЗначения(ТЗХозОперации.ВыгрузитьКолонку("ХозяйственнаяОперация"));
	
	ТЗХозОперацииИТипыДокументов.Свернуть("ИдентификаторОбъектаМетаданных");
	ОтборТипыДокументов.ЗагрузитьЗначения(ТЗХозОперацииИТипыДокументов.ВыгрузитьКолонку("ИдентификаторОбъектаМетаданных"));
	
КонецПроцедуры

Процедура СформироватьНадписьОтбор(ИнформационнаяНадписьОтбор, ХозяйственныеОперацииИДокументы, ОтборТипыДокументов, ОтборХозяйственныеОперации) Экспорт
	МассивСтрокНадписи = Новый Массив();
	
	ЕстьОтборы = ХозяйственныеОперацииИДокументы.НайтиСтроки(Новый Структура("Отбор",Ложь)).Количество() > 0;
	Если ЕстьОтборы Тогда
		
		ТекстНадписи = НСтр("ru = 'Показаны %КоличествоХозОпераций% по %КоличествоДокументов%'");
		
		КоличествоХозОпераций = СтроковыеФункцииКлиентСервер.ЧислоЦифрамиПредметИсчисленияПрописью(ОтборХозяйственныеОперации.Количество(),НСтр("ru = 'хоз. операция, хоз. операции, хоз. операций'"));
		ТекстНадписи = СтрЗаменить(ТекстНадписи,"%КоличествоХозОпераций%", КоличествоХозОпераций);
		КоличествоТипыДокументов = СтроковыеФункцииКлиентСервер.ЧислоЦифрамиПредметИсчисленияПрописью(ОтборТипыДокументов.Количество(),НСтр("ru = 'документу, документам, документам'"));
		ТекстНадписи = СтрЗаменить(ТекстНадписи,"%КоличествоДокументов%", КоличествоТипыДокументов);
		
		МассивСтрокНадписи.Добавить(ТекстНадписи);
		
		МассивСтрокНадписи.Добавить("  ");
		
		МассивСтрокНадписи.Добавить(Новый ФорматированнаяСтрока(НСтр("ru = 'Настроить'"),,,,"НастроитьОтбор"));
		
	Иначе
		
		МассивСтрокНадписи.Добавить(НСтр("ru = 'Показаны все документы журнала'"));
		МассивСтрокНадписи.Добавить("  ");
		МассивСтрокНадписи.Добавить(Новый ФорматированнаяСтрока(НСтр("ru = 'Настроить'"),,,,"НастроитьОтбор"));
		
	КонецЕсли;
	
	ИнформационнаяНадписьОтбор = Новый ФорматированнаяСтрока(МассивСтрокНадписи);
	
КонецПроцедуры

// Возвращает таблицу с хозяйственными операциями и типами документов доступными по функциональным опциям
// и по правам.
//
// Параметры:
//	ИмяРабочегоМеста - Строка
//
// Возвращаемое значение:
//	ТаблицаЗначений с колонками
//		- ХозяйственнаяОперация
//		- ИдентификаторОбъектаМетаданных
//		- Отбор
//		- ДокументПредставление.
//
Функция ДоступныеХозяйственныеОперацииИДокументы(ТаблицаЗначений, ОтборХозяйственныеОперации, ОтборТипыДокументов, КлючНазначенияИспользования) Экспорт
	
	ТаблицаРезультата = ТаблицаЗначений.СкопироватьКолонки();
	ИмяТаблицы        = "РегистрСведений.РеестрДокументов";
	
	НеДоступныеХозяйственныеОперации = НеДоступныеХозяйственныеОперации(ИмяТаблицы);
	ПроверяемыеХозяйственныеОперации = ТаблицаЗначений.ВыгрузитьКолонку("ХозяйственнаяОперация");
	
	МассивХозяйственныхОпераций = ?(НеДоступныеХозяйственныеОперации.Количество() = 0,
									ПроверяемыеХозяйственныеОперации,
									ОбщегоНазначенияКлиентСервер.РазностьМассивов(ПроверяемыеХозяйственныеОперации,
																				НеДоступныеХозяйственныеОперации));
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции,
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка.ИспользоватьВРеестреДокументов
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.ФункциональныеОпции КАК НастройкиХозяйственныхОперацийФункциональныеОпции
	|ГДЕ
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка.ХозяйственнаяОперация В(&МассивХозяйственныхОпераций)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ХозяйственнаяОперация
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	НастройкиХозяйственныхОперацийДокументы.Ссылка.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	НастройкиХозяйственныхОперацийДокументы.НомерСтроки,
	|	НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных,
	|	НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных.ПолноеИмя КАК ПолноеИмя,
	|	НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных.Синоним КАК Синоним
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.Документы КАК НастройкиХозяйственныхОперацийДокументы
	|ГДЕ
	|	НастройкиХозяйственныхОперацийДокументы.Ссылка.ХозяйственнаяОперация В(&МассивХозяйственныхОпераций)
	|	И НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных <> ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
	|ИТОГИ ПО
	|	ХозяйственнаяОперация";
	
	Запрос.УстановитьПараметр("МассивХозяйственныхОпераций", МассивХозяйственныхОпераций);
	
	РезультатЗапроса = Запрос.ВыполнитьПакет();
	ВыборкаПоФункциональнымОпциям = РезультатЗапроса[0].Выбрать();
	ВыборкаПоДокументам = РезультатЗапроса[1].Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	ИдентификаторыОбъектовМетаданных = РезультатЗапроса[1].Выгрузить().ВыгрузитьКолонку("ИдентификаторОбъектаМетаданных");
	ИдентификаторыОбъектовМетаданных = ОбщегоНазначенияКлиентСервер.СвернутьМассив(ИдентификаторыОбъектовМетаданных);
	
	Если ИдентификаторыОбъектовМетаданных.Количество() = 0 Тогда
		ВызватьИсключение НСтр("ru = 'Нет доступных для отображения хозяйственных операций. Возможно права доступа для пользователя назначены некорректно.'");
	КонецЕсли;
	
	// Удалим пустое значение.
	ИдентификаторыОбъектовМетаданных.Удалить(0);
	ПраваПоИдентификаторам = УправлениеДоступом.ПраваПоИдентификаторам(ИдентификаторыОбъектовМетаданных);
	
	//++ НЕ УТ
	ИспользуетсяУправлениеПроизводством21и22 = ПолучитьФункциональнуюОпцию("ИспользуетсяУправлениеПроизводством21и22");
	//-- НЕ УТ
	
	Пока ВыборкаПоДокументам.Следующий() Цикл
		
		Если ВыборкаПоФункциональнымОпциям.НайтиСледующий(Новый Структура("ИспользоватьВРеестреДокументов", Ложь)) Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Хозяйственная операция ""%1"" не используется журналах документов.'"), ВыборкаПоФункциональнымОпциям.ХозяйственнаяОперация);
		КонецЕсли;
		
		ХозяйственнаяОперацияДоступнаПоФо = Ложь;
		ЕстьФО = Ложь;
		
		Пока ВыборкаПоФункциональнымОпциям.НайтиСледующий(Новый Структура("ХозяйственнаяОперация", ВыборкаПоДокументам.ХозяйственнаяОперация)) Цикл
			
			ЕстьФО = Истина;
			ХозяйственнаяОперацияДоступнаПоФо = ПолучитьФункциональнуюОпцию(ВыборкаПоФункциональнымОпциям.ИмяФункциональнойОпции) 
												Или ХозяйственнаяОперацияДоступнаПоФо;
			
		КонецЦикла;
		ВыборкаПоФункциональнымОпциям.Сбросить();
		Если ЕстьФО И Не ХозяйственнаяОперацияДоступнаПоФо Тогда
			Продолжить;
		КонецЕсли;
		
		Выборка = ВыборкаПоДокументам.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			ПраваИдентификатораОбъектаМетаданных = ПраваПоИдентификаторам.Получить(Выборка.ИдентификаторОбъектаМетаданных);
			Если ПраваИдентификатораОбъектаМетаданных = Неопределено
				Или Не ПраваИдентификатораОбъектаМетаданных.Чтение Тогда
				Продолжить;
			КонецЕсли;
			
			ИмяДокумента = СтрРазделить(Выборка.ПолноеИмя,".")[1];
			ОбъектМетаданных = Метаданные.Документы[ИмяДокумента];
			
			Если ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Тогда
				
				Отбор = Новый Структура("ХозяйственнаяОперация, ПолноеИмяДокумента", Выборка.ХозяйственнаяОперация, Выборка.ПолноеИмя);
				НайденныеСтроки = ТаблицаЗначений.НайтиСтроки(Отбор);
				Для Каждого Строка Из НайденныеСтроки Цикл
					НоваяСтрока = ТаблицаРезультата.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
					НоваяСтрока.ИдентификаторОбъектаМетаданных = Выборка.ИдентификаторОбъектаМетаданных;
					НоваяСтрока.ДокументПредставление = 
						?(НЕ ПустаяСтрока(Строка.ДокументПредставление), Строка.ДокументПредставление, Выборка.Синоним);
					//++ НЕ УТ
					Если ИспользуетсяУправлениеПроизводством21и22 Тогда
						Если Выборка.ПолноеИмя = "Документ.ПередачаМатериаловВПроизводство" 
							ИЛИ Выборка.ПолноеИмя = "Документ.ПеремещениеМатериаловВПроизводстве" 
							ИЛИ Выборка.ПолноеИмя = "Документ.ВозвратМатериаловИзПроизводства" 
							ИЛИ Выборка.ПолноеИмя = "Документ.ВыпускПродукции" Тогда
							НоваяСтрока.ДокументПредставление = НоваяСтрока.ДокументПредставление + " (2.1)";
						ИначеЕсли Выборка.ПолноеИмя = "Документ.ДвижениеПродукцииИМатериалов" Тогда
							НоваяСтрока.ДокументПредставление = НоваяСтрока.ДокументПредставление + " (2.2)";
						КонецЕсли; 
					КонецЕсли;
					//-- НЕ УТ
					НоваяСтрока.ПравоДоступаДобавление = ПраваИдентификатораОбъектаМетаданных.Добавление;
					НоваяСтрока.ПравоДоступаИзменение = ПраваИдентификатораОбъектаМетаданных.Изменение;
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Если ОтборХозяйственныеОперации.Количество() = 0
		И ОтборТипыДокументов.Количество() = 0 Тогда
		Если КлючНазначенияИспользования = "" Тогда
			ТаблицаРезультата.ЗаполнитьЗначения(Истина, "Отбор");
		Иначе
			Для Каждого Строка Из ТаблицаРезультата Цикл
				Если Строка.КлючНазначенияИспользования = КлючНазначенияИспользования Тогда 
					Строка.Отбор = Истина;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Иначе
		Для Каждого Строка Из ТаблицаРезультата Цикл
			Если ОтборХозяйственныеОперации.НайтиПоЗначению(Строка.ХозяйственнаяОперация) <> Неопределено
				И ОтборТипыДокументов.НайтиПоЗначению(Строка.ИдентификаторОбъектаМетаданных) <> Неопределено Тогда
				Строка.Отбор = Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	ЗаполнитьОтборыПоТаблицеХозОперацийИТиповДокументов(ТаблицаРезультата, ОтборХозяйственныеОперации, ОтборТипыДокументов);
	
	Возврат ТаблицаРезультата;
	
КонецФункции

// Массив менеджеров документов, используемых в переданном массиве хозяйственных операций.
//
// Параметры:
//  МассивХозяйственныхОпераций - Массив - 
// 
// Возвращаемое значение:
//   - Массив
//
Функция ИспользуемыеМенеджерыДокументов(ДоступныеХозяйственныеОперацииИДокументы) Экспорт 
	
	ТаблицаОперацииНакладные = ВыделенныеХозяйственныеОперацииИДокументы(ДоступныеХозяйственныеОперацииИДокументы);
	
	МетаданныеДокументов = ТаблицаОперацииНакладные.ВыгрузитьКолонку("ОбъектМетаданныхДокумента");
	
	МассивМенеджеров = Новый Массив();
	
	Для Каждого Строка Из МетаданныеДокументов Цикл
		Имя = Строка.Имя;
		МенеджерДокумента = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(Имя);
		МассивМенеджеров.Добавить(МенеджерДокумента);
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивМенеджеров);
	
	Возврат МассивМенеджеров;
	
КонецФункции

// Массив типов документов, используемых в переданном массиве хозяйственных операций.
//
// Параметры:
//  МассивХозяйственныхОпераций - Массив - 
//  Отбор 						- Структура - Структура отбора по таблице ОписаниеМетаданныхНакладных.
// 
// Возвращаемое значение:
//   - Массив
//
Функция ИспользуемыеПолныеИменаДокументов(ХозяйственныеОперацииИДокументы, Отбор = Неопределено) Экспорт 
	
	ПолныеИменаДокументов = Новый Массив();
	
	ТаблицаОперацииНакладные = ВыделенныеХозяйственныеОперацииИДокументы(ХозяйственныеОперацииИДокументы);
		
	Если Отбор <> Неопределено Тогда
		НайденныеСтроки = ТаблицаОперацииНакладные.НайтиСтроки(Отбор);
		
		Для Каждого Строка Из НайденныеСтроки Цикл
			ПолныеИменаДокументов.Добавить(Строка.ПолноеИмяДокумента);
		КонецЦикла;
	Иначе
		
		ПолныеИменаДокументов = ТаблицаОперацииНакладные.ВыгрузитьКолонку("ПолноеИмяДокумента");
		
	КонецЕсли;
	
	ПолныеИменаДокументов = ОбщегоНазначенияКлиентСервер.СвернутьМассив(ПолныеИменаДокументов);
	
	Возврат ПолныеИменаДокументов;
	
КонецФункции

// Возвращает таблицу с выделенными отборами по хоз. операциям и документам
//
// Параметры:
//  ДоступныеХозяйственныеОперацииИДокументы - ТаблицаЗначений	 - выгрузка таблицы из реквизита формы ХозяйственныеОперацииИДокументы.
// 
// Возвращаемое значение:
//  ТаблицаЗначений
//
Функция ВыделенныеХозяйственныеОперацииИДокументы(ДоступныеХозяйственныеОперацииИДокументы) Экспорт  
	
	ОтобраннаяТаблица = ДоступныеХозяйственныеОперацииИДокументы.СкопироватьКолонки();
	
	Отбор = Новый Структура();
	Отбор.Вставить("Отбор", Истина);
	
	НайденныеСтроки = ДоступныеХозяйственныеОперацииИДокументы.НайтиСтроки(Отбор);
	
	Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
		Строка = ОтобраннаяТаблица.Добавить();
		ЗаполнитьЗначенияСвойств(Строка, НайденнаяСтрока);
	КонецЦикла;
	
	Возврат ОтобраннаяТаблица;
	
КонецФункции

// Выделенные хозяйственные операции
//
// Параметры:
//  ДоступныеХозяйственныеОперации	 - Коллекция	 - Список значений формы с доступными хоз. операциями.
// 
// Возвращаемое значение:
//  Массив - 
//
Функция ВыделенныеХозяйственныеОперации(ХозяйственныеОперацииИДокументы) Экспорт 
	
	МассивХозОпераций = Новый Массив();
	
	МассивВыделенныхСтрок = ХозяйственныеОперацииИДокументы.НайтиСтроки(Новый Структура("Отбор", Истина));	
	
	Для Каждого Строка Из МассивВыделенныхСтрок Цикл
		МассивХозОпераций.Добавить(Строка.ХозяйственнаяОперация);
	КонецЦикла;
	
	// Пустой массив означает отсутствие отбора. Отсутствие отбора равнозначно всем выбранным элементам.
	Если МассивХозОпераций.Количество() = 0 Тогда
		МассивХозОпераций = ХозяйственныеОперацииИДокументы.ВыгрузитьКолонку("ХозяйственнаяОперация");
	КонецЕсли;
	
	Возврат МассивХозОпераций;
	
КонецФункции

// Процедура - Удалить подчиненные элементы элемента формы
//
// Параметры:
//  Форма			 - ФормаКлиентскогоПриложения	- форма, с которой удаляются элементы
//  ЭлементФормы	 - ЭлементФормы	 	- элемент формы, подчиненные элементы которого нужно удалить
//  УдалятьКоманды	 - 				 	- Булево
//  Команды			 - Коллекция	 	- коллекция команд формы, обязательно должен быть заполнен, если УдалятьКоманды = Истина.
//
Процедура УдалитьПодчиненныеЭлементыЭлементаФормы(Форма, ЭлементФормы, УдалятьКоманды = Ложь) Экспорт 
	
	ЭлементыНаУдаление = Новый Массив();
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ЭлементыНаУдаление, ЭлементФормы.ПодчиненныеЭлементы);
	Для ИндексЭлемента = 0 По ЭлементыНаУдаление.Количество() - 1 Цикл
		
		Элемент = ЭлементыНаУдаление[ИндексЭлемента];
		
		Если ТипЗнч(Элемент) = Тип("ГруппаФормы") Тогда
			УдалитьПодчиненныеЭлементыЭлементаФормы(Форма, Элемент, УдалятьКоманды);
		ИначеЕсли ТипЗнч(Элемент) = Тип("КнопкаФормы")
			И УдалятьКоманды Тогда			
			КомандаКУдалению = Форма.Команды.Найти(Элемент.ИмяКоманды);
			Если КомандаКУдалению <> Неопределено Тогда
				Форма.Команды.Удалить(КомандаКУдалению);
			КонецЕсли;
		КонецЕсли;
		
		Форма.Элементы.Удалить(Элемент);
		
	КонецЦикла;
	
КонецПроцедуры

// Добавляет кнопки изменения статусов в группу формы
//
// Параметры:
//  Форма							 - ФормаКлиентскогоПриложения	 - 
//  СписокУстановитьСтатус			 - ЭлементФормы	- Группа формы, куда должны быть помещены кнопки изменения статусов.
//
Процедура УстановитьСписокСтатусов(Форма, СписокУстановитьСтатус) Экспорт
		
	// Очистка элементов в случае переинициализации списка статусов
	УдалитьПодчиненныеЭлементыЭлементаФормы(Форма, СписокУстановитьСтатус);
	
	Форма.СоответствиеКомандСтатусам.Очистить();
	
	СтатусыДокументов = Новый ТаблицаЗначений();
	СтатусыДокументов.Колонки.Добавить("ИмяДокумента", 			Новый ОписаниеТипов("Строка"));
	СтатусыДокументов.Колонки.Добавить("СинонимДокумента", 		Новый ОписаниеТипов("Строка"));
	СтатусыДокументов.Колонки.Добавить("СтатусПредставление", 	Новый ОписаниеТипов("Строка"));
	СтатусыДокументов.Колонки.Добавить("СтатусИмяЗначения", 	Новый ОписаниеТипов("Строка"));
	СтатусыДокументов.Колонки.Добавить("Статус");
	
	СоответствияОпераций = ВыделенныеХозяйственныеОперацииИДокументы(Форма.ХозяйственныеОперацииИДокументы.Выгрузить());
		
	СоответствияОпераций.Свернуть("ПолноеИмяДокумента, ИспользуютсяСтатусы, ПравоДоступаИзменение");
	
	Для Каждого СтрокаСоответствия Из СоответствияОпераций Цикл
		
		Если СтрокаСоответствия.ИспользуютсяСтатусы И СтрокаСоответствия.ПравоДоступаИзменение Тогда
			МенеджерДокумента = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(СтрокаСоответствия.ПолноеИмяДокумента);
			СтатусыДокумента = МенеджерДокумента.СтатусыДокументаИзменяемыеИзСписка();
			МетаданныеОбъекта = МетаданныеОбъектаПоПолномуИмени(СтрокаСоответствия.ПолноеИмяДокумента);
			Для Каждого СтрокаСтатус Из СтатусыДокумента Цикл
				СтрокаСтатусаДокумента = СтатусыДокументов.Добавить();
				СтрокаСтатусаДокумента.ИмяДокумента = МетаданныеОбъекта.Имя;
				СтрокаСтатусаДокумента.СинонимДокумента = МетаданныеОбъекта.Синоним;
				СтрокаСтатусаДокумента.Статус = СтрокаСтатус.Статус;
				СтрокаСтатусаДокумента.СтатусПредставление = СтрокаСтатус.СтатусПредставление;
				СтрокаСтатусаДокумента.СтатусИмяЗначения = ОбщегоНазначения.ИмяЗначенияПеречисления(СтрокаСтатус.Статус);
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	Для Индекс = 0 По СтатусыДокументов.Количество() - 1 Цикл
		
		СтрокаСтатусаДокумента = СтатусыДокументов[Индекс];
		
		УникальноеИмяКнопки = СтрокаСтатусаДокумента.ИмяДокумента + Индекс;
		
		Если Форма.Команды.Найти(УникальноеИмяКнопки) = Неопределено Тогда
			Команда = Форма.Команды.Добавить(УникальноеИмяКнопки);
			Команда.Действие = "Подключаемый_УстановитьСтатус";
		КонецЕсли;
		
		Кнопка = Форма.Элементы.Добавить(УникальноеИмяКнопки, Тип("КнопкаФормы"), СписокУстановитьСтатус);
		Кнопка.Заголовок = СтрокаСтатусаДокумента.СинонимДокумента + ": " + СтрокаСтатусаДокумента.СтатусПредставление;
		Кнопка.ИмяКоманды = УникальноеИмяКнопки;
		
		СтрокаСоответствияКоманд = Форма.СоответствиеКомандСтатусам.Добавить();
		СтрокаСоответствияКоманд.ИмяКоманды = УникальноеИмяКнопки;
		СтрокаСоответствияКоманд.Статус = СтрокаСтатусаДокумента.Статус;
		СтрокаСоответствияКоманд.СтатусПредставление = СтрокаСтатусаДокумента.СтатусПредставление;
		СтрокаСоответствияКоманд.СтатусИмяЗначения = СтрокаСтатусаДокумента.СтатусИмяЗначения;
		СтрокаСоответствияКоманд.ДокументСтрока = СтрокаСтатусаДокумента.ИмяДокумента;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает шаблон таблицы для помещения в нее описаний статусов для журналов документов.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - таблица с колонками:
//		*Статус - ПеречислениеСсылка - ссылка на статус документа
//		*СтатусПредставление - Строка - представление статуса; указывается, если нужно переопределить синоним статуса.
//
Функция ТаблицаСтатусовИзменяемыхИзСписка() Экспорт 
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Статус");
	Таблица.Колонки.Добавить("СтатусПредставление", Новый ОписаниеТипов("Строка"));
	
	Возврат Таблица;
	
КонецФункции

// Добавляет строку в ранее созданную таблицу
//
// Параметры:
//  Таблица				 - ТаблицаЗначений		 - см. ТаблицаСтатусовИзменяемыхИзСписка()
//  Статус				 - ПеречислениеСсылка	 - см. ТаблицаСтатусовИзменяемыхИзСписка()
//  СтатусПредставление	 - Строка				 - см. ТаблицаСтатусовИзменяемыхИзСписка().
//
Процедура ДобавитьСтрокуВТаблицуСтатусовИзменяемыхИзСписка(Таблица, Статус, Знач СтатусПредставление = "") Экспорт
	
	НоваяСтрока = Таблица.Добавить();
	НоваяСтрока.Статус = Статус;
	Если Не ЗначениеЗаполнено(СтатусПредставление) Тогда 
		СтатусПредставление = Строка(Статус);
	КонецЕсли;
	НоваяСтрока.СтатусПредставление = СтатусПредставление;
		
КонецПроцедуры

// Возвращает массив объектов метаданных по таблице ХозяйственныеОперацииИДокументы
//
// Параметры:
//  ХозяйственныеОперацииИДокументы	 - 	ТаблицаЗначений, ДанныеФормыКоллекция - таблица колонками "ПолноеИмяДокумента" и "Отбор"
//  Отбор							 - 	Структура - структура дополнительных отборов, ключи которых должны быть колонками в таблице ХозяйственныеОперацииИДокументы.
// 
// Возвращаемое значение:
//  Массив - массив объектов метаданных.
//
Функция ОбъектыМетаданныхИзХозяйственныхОперацийИДокументов(ХозяйственныеОперацииИДокументы, Отбор = Неопределено) Экспорт
	
	СтруктураОтбора = Новый Структура("Отбор",Истина);
	Если Отбор <> Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(СтруктураОтбора, Отбор);
	КонецЕсли;
	НайденныеСтроки = ХозяйственныеОперацииИДокументы.НайтиСтроки(СтруктураОтбора);
	ОбработанныеИмена = Новый Соответствие;
	ОбъектыМетаданных = Новый Массив;
	Для Каждого Стр Из НайденныеСтроки Цикл
		Если ОбработанныеИмена.Получить(Стр.ПолноеИмяДокумента) = Неопределено Тогда
			ОбработанныеИмена.Вставить(Стр.ПолноеИмяДокумента, Стр.ПолноеИмяДокумента);
			МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(Стр.ПолноеИмяДокумента);
			ОбъектыМетаданных.Добавить(МетаданныеОбъекта);
		КонецЕсли;
	КонецЦикла;
	Возврат ОбъектыМетаданных;
	
КонецФункции

// Возвращает структуру параметров настройки кнопок управления документами со следующими ключами
//		*Форма - ФормаКлиентскогоПриложения - сюда должна быть помещена управляемая форма, в которой происходит настройка кнопок
//		*ИмяТаблицыХозяйственныхОперацийИДокументов - Строка - имя реквизита формы, который является табличной частью и хранит хоз. операции и документы рабочего места
//		*ИмяКнопкиСкопировать - Строка - имя элемента формы (кнопки Скопировать)
//		*ИмяКнопкиИзменить - Строка - имя элемента формы (кнопки Изменить)
//		*ИмяКнопкиПровести - Строка - имя элемента формы (кнопки Провести)
//		*ИмяКнопкиОтменаПроведения - Строка - имя элемента формы (кнопки ОтменитьПроведение)
//		*ИмяКнопкиУстановитьПометкуУдаления - Строка - имя элемента формы (кнопки УстановитьПометкуУдаления)
//		*ИмяГруппыСоздать - Строка - имя элемента формы (группы Создать).
// 
// Возвращаемое значение:
//  Структура
//
Функция СтруктураПараметровНастройкиКнопокУправленияДокументами() Экспорт 
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("Форма");
	СтруктураПараметров.Вставить("ИмяТаблицыХозяйственныхОперацийИДокументов", "ХозяйственныеОперацииИДокументы");
	СтруктураПараметров.Вставить("ИмяКнопкиСкопировать");
	СтруктураПараметров.Вставить("ИмяКнопкиСкопироватьКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяКнопкиИзменить");
	СтруктураПараметров.Вставить("ИмяКнопкиИзменитьКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяКнопкиПровести");
	СтруктураПараметров.Вставить("ИмяКнопкиПровестиКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяКнопкиОтменаПроведения");
	СтруктураПараметров.Вставить("ИмяКнопкиОтменаПроведенияКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяКнопкиУстановитьПометкуУдаления");
	СтруктураПараметров.Вставить("ИмяКнопкиУстановитьПометкуУдаленияКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяГруппыСоздать", "ГруппаСоздатьГенерируемая");
	СтруктураПараметров.Вставить("ИмяГруппыСоздатьКонтекст", "ГруппаСоздатьГенерируемаяКонтекст");
	СтруктураПараметров.Вставить("ПрефиксЭлементов", "");
	
	Возврат СтруктураПараметров;
		
КонецФункции

// Корректирует состав команд управления документами 
//
// Параметры:
//  СтруктураПараметров	 - Структура	 - см. функцию СтруктураПараметровНастройкиКнопокУправленияДокументами().
//
Процедура НастроитьКнопкиУправленияДокументами(СтруктураПараметров) Экспорт
	
	Форма 												= СтруктураПараметров.Форма;
	ИмяТаблицыХозяйственныхОперацийИДокументов 			= СтруктураПараметров.ИмяТаблицыХозяйственныхОперацийИДокументов;
	ИмяКнопкиСкопировать 								= СтруктураПараметров.ИмяКнопкиСкопировать;
	ИмяКнопкиСкопироватьКонтекстноеМеню 				= СтруктураПараметров.ИмяКнопкиСкопироватьКонтекстноеМеню;
	ИмяКнопкиИзменить 									= СтруктураПараметров.ИмяКнопкиИзменить;
	ИмяКнопкиИзменитьКонтекстноеМеню 					= СтруктураПараметров.ИмяКнопкиИзменитьКонтекстноеМеню;
	ИмяКнопкиПровести 									= СтруктураПараметров.ИмяКнопкиПровести;
	ИмяКнопкиПровестиКонтекстноеМеню 					= СтруктураПараметров.ИмяКнопкиПровестиКонтекстноеМеню;
	ИмяКнопкиОтменаПроведения 							= СтруктураПараметров.ИмяКнопкиОтменаПроведения;
	ИмяКнопкиОтменаПроведенияКонтекстноеМеню 			= СтруктураПараметров.ИмяКнопкиОтменаПроведенияКонтекстноеМеню;
	ИмяКнопкиУстановитьПометкуУдаления 					= СтруктураПараметров.ИмяКнопкиУстановитьПометкуУдаления;
	ИмяКнопкиУстановитьПометкуУдаленияКонтекстноеМеню 	= СтруктураПараметров.ИмяКнопкиУстановитьПометкуУдаленияКонтекстноеМеню;
	ИмяГруппыСоздать 									= СтруктураПараметров.ИмяГруппыСоздать;
	ИмяГруппыСоздатьКонтекст							= СтруктураПараметров.ИмяГруппыСоздатьКонтекст;
	ПрефиксЭлементов									= СтруктураПараметров.ПрефиксЭлементов;
	
	ПравоДоступаДобавление = Ложь;
	ПравоДоступаИзменение  = Ложь;
	
	ОтобранныеСтроки = Форма[ИмяТаблицыХозяйственныхОперацийИДокументов].НайтиСтроки(Новый Структура("Отбор", Истина));
	
	Для Каждого Строка Из ОтобранныеСтроки Цикл
		
		Если ПравоДоступаДобавление И ПравоДоступаИзменение Тогда 
			Прервать;
		КонецЕсли;
		
		ПравоДоступаДобавление = ?(Строка.ПравоДоступаДобавление, Истина, ПравоДоступаДобавление);
		ПравоДоступаИзменение  = ?(Строка.ПравоДоступаИзменение, Истина, ПравоДоступаИзменение);
		
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяГруппыСоздать, "Видимость", ПравоДоступаДобавление);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяГруппыСоздатьКонтекст, "Видимость", ПравоДоступаДобавление);
	
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиСкопировать, "Видимость", ПравоДоступаДобавление);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиСкопироватьКонтекстноеМеню, "Видимость", ПравоДоступаДобавление);
	
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиИзменить, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиИзменитьКонтекстноеМеню, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиПровести, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиПровестиКонтекстноеМеню, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиОтменаПроведения, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиОтменаПроведенияКонтекстноеМеню, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиУстановитьПометкуУдаления, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиУстановитьПометкуУдаленияКонтекстноеМеню, "Видимость", ПравоДоступаИзменение);
	
	ВидимостьГруппыСоздать = ОбщегоНазначенияКлиентСервер.ЗначениеСвойстваЭлементаФормы(Форма.Элементы, ИмяГруппыСоздать, "Видимость");
	
	Если ВидимостьГруппыСоздать <> Неопределено И ВидимостьГруппыСоздать Тогда
		СформироватьКомандыСоздания(Форма, ИмяТаблицыХозяйственныхОперацийИДокументов, ИмяГруппыСоздать, ИмяГруппыСоздатьКонтекст, ПрефиксЭлементов);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает параметры рабочего места в зависимости от установленных отборов по операциям и типам документов.
//
// Параметры:
//  ТаблицаХозОперацииИТипыДокументов	 - ТаблицаЗначений - таблица с описанием метаданных, используемых в рабочем месте
//  КлючНазначенияФормыПоУмолчанию	 - Строка - параметр, определяющий раздел рабочего места, например, "ВнутреннееТовародвижение"
//  ЗаголовокФормыПоУмолчанию		 - Строка - заголовок рабочего места по умолчанию, например, "Внутреннее товародвижение".
// 
// Возвращаемое значение:
//  Структура - с полями:
//		*КлючНазначенияИспользования,
//		*ЗаголовокРабочегоМеста.
//
Функция ДанныеРабочегоМеста(ТаблицаХозОперацииИТипыДокументов, КлючНазначенияФормыПоУмолчанию, ЗаголовокФормыПоУмолчанию) Экспорт
	
	ОтобранныеХозОперацииИТипыДокументов = ТаблицаХозОперацииИТипыДокументов.Скопировать(Новый Структура("Отбор",Истина),
		"КлючНазначенияИспользования,ЗаголовокРабочегоМеста");
	ОтобранныеХозОперацииИТипыДокументов.Свернуть("КлючНазначенияИспользования,ЗаголовокРабочегоМеста");
	
	ДанныеРабочегоМеста = Новый Структура("КлючНазначенияИспользования,ЗаголовокРабочегоМеста",
		КлючНазначенияФормыПоУмолчанию, ЗаголовокФормыПоУмолчанию);
		
	Если ОтобранныеХозОперацииИТипыДокументов.Количество() = 1 Тогда
		Если ЗначениеЗаполнено(ОтобранныеХозОперацииИТипыДокументов[0].КлючНазначенияИспользования) Тогда
			ДанныеРабочегоМеста.КлючНазначенияИспользования = ОтобранныеХозОперацииИТипыДокументов[0].КлючНазначенияИспользования;	
		КонецЕсли;
		Если ЗначениеЗаполнено(ОтобранныеХозОперацииИТипыДокументов[0].ЗаголовокРабочегоМеста) Тогда
			ДанныеРабочегоМеста.ЗаголовокРабочегоМеста = ОтобранныеХозОперацииИТипыДокументов[0].ЗаголовокРабочегоМеста;	
		КонецЕсли;			
	КонецЕсли;
	
	Возврат ДанныеРабочегоМеста;
	
КонецФункции

Функция СформироватьГиперссылкуКОформлению(ХозяйственныеОперацииИДокументы, ПараметрыФормирования, Заголовок = "") Экспорт
	
	МассивСтрок = Новый Массив;
	МассивСтрок.Добавить(?(ПустаяСтрока(Заголовок), НСтр("ru = 'К оформлению:'"), Заголовок) + " ");
	
	СтруктураОтбора = Новый Структура("Отбор", Истина);
	МенеджерыРасчетаГиперссылок = ХозяйственныеОперацииИДокументы.Скопировать(СтруктураОтбора, "МенеджерРасчетаГиперссылкиКОформлению");
	
	МенеджерыРасчетаГиперссылок.Свернуть("МенеджерРасчетаГиперссылкиКОформлению");
	МенеджерыРасчетаГиперссылок = МенеджерыРасчетаГиперссылок.ВыгрузитьКолонку("МенеджерРасчетаГиперссылкиКОформлению");
	
	Для Каждого МенеджерРасчетаГиперссылок Из МенеджерыРасчетаГиперссылок Цикл
		Если МенеджерРасчетаГиперссылок = "" Тогда
			Продолжить;
		КонецЕсли;
		
		ПараметрыФормирования.Вставить("ХозяйственныеОперацииИДокументы",ХозяйственныеОперацииИДокументы);
		Гиперссылка = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МенеджерРасчетаГиперссылок).СформироватьГиперссылкуКОформлению(ПараметрыФормирования);
		
		Если ЗначениеЗаполнено(Гиперссылка) Тогда
			Если МассивСтрок.Количество()>1 Тогда
				МассивСтрок.Добавить("; ");
			КонецЕсли;
			МассивСтрок.Добавить(Гиперссылка);
		КонецЕсли;
	КонецЦикла;
	
	Если МассивСтрок.Количество() = 1 Тогда
		Возврат Неопределено
	Иначе
		Возврат Новый ФорматированнаяСтрока(МассивСтрок)
	КонецЕсли;
	
КонецФункции

Функция СформироватьГиперссылкуСмТакжеВРаботе(МассивМенеджеровРасчетаСмТакжеВРаботе, ПараметрыФормирования, Заголовок = "") Экспорт
	
	ЗаглавнаяСтрока = ?(ПустаяСтрока(Заголовок),
		НСтр("ru = 'См. также:'"),
		Заголовок) + " ";
	
	МассивСтрок = Новый Массив;
	МассивСтрок.Добавить(ЗаглавнаяСтрока);
		
	Для Каждого МенеджерРасчетаСмТакжеВРаботе Из МассивМенеджеровРасчетаСмТакжеВРаботе Цикл
		Если МенеджерРасчетаСмТакжеВРаботе = "" Тогда
			Продолжить;
		КонецЕсли;
		
		Гиперссылка = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МенеджерРасчетаСмТакжеВРаботе).СформироватьГиперссылкуСмТакжеВРаботе(ПараметрыФормирования);
		
		Если ЗначениеЗаполнено(Гиперссылка) Тогда
			Если МассивСтрок.Количество()>1 Тогда
				МассивСтрок.Добавить("; ");
			КонецЕсли;
			МассивСтрок.Добавить(Гиперссылка);
		КонецЕсли;
	КонецЦикла;
	
	Если МассивСтрок.Количество() = 1 Тогда
		Возврат Неопределено
	Иначе
		Возврат Новый ФорматированнаяСтрока(МассивСтрок)
	КонецЕсли;
	
КонецФункции

// Функция - Данные по штрих коду печатной формы
//
// Параметры:
//  ХозяйственныеОперацииИДокументы	 - 	ТаблицаЗначений -  таблица с колонкой "ПолноеИмяДокумента".
// 
// Возвращаемое значение:
//  Неопределено, Структура
//
Функция ДанныеПоШтрихКодуПечатнойФормы(Штрихкод, ХозяйственныеОперацииИДокументы) Экспорт 
	
	ТаблицаОперацииНакладные = ОбщегоНазначенияУТ.ВыделенныеХозяйственныеОперацииИДокументы(ХозяйственныеОперацииИДокументы);
	
	ИменаДокументов = ТаблицаОперацииНакладные.ВыгрузитьКолонку("ПолноеИмяДокумента");
	
	МассивПустыхСсылок = Новый Массив();
	
	Для Каждого ИмяДокумента Из ИменаДокументов Цикл
		ПустаяСсылка = ПредопределенноеЗначение(ИмяДокумента+".ПустаяСсылка");
		МассивПустыхСсылок.Добавить(ПустаяСсылка);
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивПустыхСсылок);
	
	Ссылки = ШтрихкодированиеПечатныхФорм.ПолучитьСсылкуПоШтрихкодуТабличногоДокумента(Штрихкод, МассивПустыхСсылок);
	
	ДанныеПоШтрихКоду = Неопределено;
	Если Ссылки.Количество() > 0 Тогда
		
		ДанныеПоШтрихКоду = Новый Структура("Ссылка,КлючЗаписи");
		ДанныеПоШтрихКоду.Ссылка = Ссылки[0];
		
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	РеестрДокументов.ТипСсылки,
		|	РеестрДокументов.Организация,
		|	РеестрДокументов.ХозяйственнаяОперация,
		|	РеестрДокументов.Партнер,
		|	РеестрДокументов.Контрагент,
		|	РеестрДокументов.НаправлениеДеятельности,
		|	РеестрДокументов.ДополнительнаяЗапись,
		|	РеестрДокументов.Подразделение,
		|	РеестрДокументов.МестоХранения,
		|	РеестрДокументов.ДатаДокументаИБ,
		|	РеестрДокументов.Ссылка
		|ИЗ
		|	РегистрСведений.РеестрДокументов КАК РеестрДокументов
		|ГДЕ
		|	РеестрДокументов.Ссылка = &Ссылка";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("Ссылка", Ссылки[0]);
		
		Результат = Запрос.Выполнить();
		Если Не Результат.Пустой() Тогда
			НайденнаяСтрока = Результат.Выгрузить()[0];
			СтруктураКлючевыхПолей = ОбщегоНазначения.СтрокаТаблицыЗначенийВСтруктуру(НайденнаяСтрока);
			ДанныеПоШтрихКоду.КлючЗаписи = РегистрыСведений.РеестрДокументов.СоздатьКлючЗаписи(СтруктураКлючевыхПолей);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ДанныеПоШтрихКоду;
	
КонецФункции


// Возвращает массив хозяйственных операций переданных типов документов,
// которые отражаются в реестре документов и не отключены по ФО.
//
// Параметры:
//  ТипыДокументов	 - Массив - массив типов.
// 
// Возвращаемое значение:
//  Массив - Хозяйственные операции (ПеречислениеСсылка.ХозяйственныеОперации).
//
Функция ХозяйственныеОперацииДокументовОтраженныеВРеестре(ТипыДокументов) Экспорт
	
	МассивИдентификаторов = Новый Массив;
	МассивХозяйственныхОпераций = Новый Массив;
	
	Для Каждого СтрМас Из ТипыДокументов Цикл
		Если ОбщегоНазначения.ЭтоСсылка(СтрМас) Тогда
			ОбъектМетаданных = Метаданные.НайтиПоТипу(СтрМас);
			Если ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Тогда
				МассивИдентификаторов.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных));
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ЕСТЬNULL(НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции, """") КАК ИмяФункциональнойОпции,
	|	НастройкиХозяйственныхОперацийДокументы.Ссылка.ХозяйственнаяОперация КАК ХозяйственнаяОперация
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.Документы КАК НастройкиХозяйственныхОперацийДокументы
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.НастройкиХозяйственныхОпераций.ФункциональныеОпции КАК НастройкиХозяйственныхОперацийФункциональныеОпции
	|		ПО НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка = НастройкиХозяйственныхОперацийДокументы.Ссылка
	|ГДЕ
	|	НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных В(&МассивИдентификаторов)
	|	И НастройкиХозяйственныхОперацийДокументы.Ссылка.ИспользоватьВРеестреДокументов
	|
	|УПОРЯДОЧИТЬ ПО
	|	ХозяйственнаяОперация";
	
	Запрос.УстановитьПараметр("МассивИдентификаторов", МассивИдентификаторов);
	
	ТекущаяХозяйственнаяОперация = Неопределено;
	ХозОперацияДобавлена = Ложь;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если ТекущаяХозяйственнаяОперация <> Выборка.ХозяйственнаяОперация Тогда 
			ХозОперацияДобавлена = Ложь;
			ТекущаяХозяйственнаяОперация = Выборка.ХозяйственнаяОперация; 
		КонецЕсли;
		
		Если Не ХозОперацияДобавлена  
			И (ПустаяСтрока(Выборка.ИмяФункциональнойОпции)
			Или ПолучитьФункциональнуюОпцию(Выборка.ИмяФункциональнойОпции)) Тогда
			
			ХозОперацияДобавлена = Истина;
			МассивХозяйственныхОпераций.Добавить(Выборка.ХозяйственнаяОперация);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат МассивХозяйственныхОпераций; 
	
КонецФункции

// Устанавливает отбор в динамическом списке по измерениям, в которых хранятся ключи реестра документов.
//
// Параметры:
//  Список			 - ДинамическийСписок 
//  ИмяОтбора		 - Строка 
//  ЗначенияОтбора	 - СправочникСсылка, СписокЗначений - значения отбора, которые если необходимо,
//						преобразуются в ключи реестра документов.
//
Процедура УстановитьОтборИзмерениюСКлючами(Список, ИмяОтбора, ЗначенияОтбора) Экспорт
	
	ДляПоискаКлючей = Новый ТаблицаЗначений;
	ДляПоискаКлючей.Колонки.Добавить("Ссылка", Метаданные.Справочники.КлючиРеестраДокументов.Реквизиты.Ключ.Тип);
	
	ЗначенияОтбораДляУстановки = Новый СписокЗначений;
	
	Если ТипЗнч(ЗначенияОтбора) = Тип("СписокЗначений") Тогда
		Для каждого ЭлементСписка Из ЗначенияОтбора Цикл
			Если ЗначениеЗаполнено(ЭлементСписка.Значение) Тогда
				Если ТипЗнч(ЭлементСписка.Значение) = Тип("СправочникСсылка.КлючиРеестраДокументов") Тогда
					ЗначенияОтбораДляУстановки.Добавить(ЭлементСписка.Значение);
				Иначе
					НоваяСтрока = ДляПоискаКлючей.Добавить();
					НоваяСтрока.Ссылка = ЭлементСписка.Значение;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ЗначениеЗаполнено(ЗначенияОтбора) Тогда
		Если ТипЗнч(ЗначенияОтбора) = Тип("СправочникСсылка.КлючиРеестраДокументов") Тогда
			ЗначенияОтбораДляУстановки.Добавить(ЗначенияОтбора);
		Иначе
			НоваяСтрока = ДляПоискаКлючей.Добавить();
			НоваяСтрока.Ссылка = ЗначенияОтбора;
		КонецЕсли;
	КонецЕсли;
	
	Если ДляПоискаКлючей.Количество() > 0  Тогда
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ
		|	Ключи.Ссылка КАК Ссылка
		|ПОМЕСТИТЬ ВТКлючи
		|ИЗ
		|	&Ключи КАК Ключи
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ВТКлючи.Ссылка КАК ЗначениеСсылка,
		|	КлючиРеестраДокументов.Ссылка КАК КлючСсылка
		|ИЗ
		|	ВТКлючи КАК ВТКлючи
		|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.КлючиРеестраДокументов КАК КлючиРеестраДокументов
		|		ПО ВТКлючи.Ссылка = КлючиРеестраДокументов.Ключ";
				
		Запрос.УстановитьПараметр("Ключи", ДляПоискаКлючей);
		
		Выборка = Запрос.Выполнить().Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			Если ЗначениеЗаполнено(Выборка.КлючСсылка) Тогда
				ЗначенияОтбораДляУстановки.Добавить(Выборка.КлючСсылка);
			ИначеЕсли ОбщегоНазначения.ЭтоПодчиненныйУзелРИБ() Тогда
				
				ТекстСообщения = НСтр("ru = 'Для значения ""%Значение%"" не найден ключ реестра документов. Обратитесь к администратору.'");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Значение%", Выборка.ЗначениеСсылка);
				
				ВызватьИсключение ТекстСообщения;
			Иначе
				
				Справочники.КлючиРеестраДокументов.СоздатьОбновитьКлючиРеестра(,Выборка.ЗначениеСсылка);
				
				Запрос = Новый Запрос;
				Запрос.Текст =
				"ВЫБРАТЬ
				|	КлючиРеестраДокументов.Ссылка КАК КлючСсылка
				|ИЗ
				|	Справочник.КлючиРеестраДокументов КАК КлючиРеестраДокументов
				|ГДЕ
				|	КлючиРеестраДокументов.Ключ = &Ключ";
				Запрос.УстановитьПараметр("Ключ", Выборка.ЗначениеСсылка); 
				
				ВыборкаПоОдномуКлючу = Запрос.Выполнить().Выбрать();
				ВыборкаПоОдномуКлючу.Следующий();
				
				ЗначенияОтбораДляУстановки.Добавить(ВыборкаПоОдномуКлючу.КлючСсылка);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	ОбщегоНазначенияКлиентСервер.УстановитьЭлементОтбораДинамическогоСписка(
		Список,
		ИмяОтбора,
		ЗначенияОтбораДляУстановки,
		ВидСравненияКомпоновкиДанных.ВСписке,
		,
		ЗначенияОтбораДляУстановки.Количество() > 0);
	
КонецПроцедуры

Функция НоваяТаблицаХозяйственныеОперацииИДокументы() Экспорт

	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("ХозяйственнаяОперация", Новый ОписаниеТипов("ПеречислениеСсылка.ХозяйственныеОперации"));
	Результат.Колонки.Добавить("ИдентификаторОбъектаМетаданных", Новый ОписаниеТипов("СправочникСсылка.ИдентификаторыОбъектовМетаданных"));
	Результат.Колонки.Добавить("Отбор", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ДокументПредставление", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
	Результат.Колонки.Добавить("ПолноеИмяДокумента", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
	Результат.Колонки.Добавить("ИспользуютсяСтатусы", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("КлючНазначенияИспользования", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
	Результат.Колонки.Добавить("ПравоДоступаДобавление", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ПравоДоступаИзменение", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ЗаголовокРабочегоМеста", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
	Результат.Колонки.Добавить("ИменаЭлементовРабочегоМеста", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
	Результат.Колонки.Добавить("МенеджерРасчетаГиперссылкиКОформлению", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
	Результат.Колонки.Добавить("ДобавитьКнопкуСоздать", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ТипДокумента", Новый ОписаниеТипов("Тип"));
	
	Возврат Результат;
	
КонецФункции

// Обработчик подписки ПодготовитьДанныеДляСинхронизацииКлючейПередЗаписью
//
Процедура ПодготовитьДанныеДляСинхронизацииКлючейПередЗаписью(Объект, Отказ) Экспорт
	
	Если Объект.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	Параметры = Новый Соответствие;
	
	Если ТипЗнч(Объект) = Тип("СправочникОбъект.ФизическиеЛица") Тогда
		Параметры.Вставить("Справочник.КлючиРеестраДокументов", "ПометкаУдаления,Наименование,ИНН");
	Иначе
		ТекстИсключения = НСтр("ru = 'Для объекта %ТипОбъекта% не описаны параметры синхронизации с ключами.'");
		ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ТипОбъекта%", Метаданные.НайтиПоТипу(Объект).ПолноеИмя());
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
	
	ПодготовитьДанныеДляСинхронизацииКлючей(Объект, Параметры);
	
КонецПроцедуры

// Обработчик подписки СинхронизироватьКлючиПриЗаписиСправочника
//
Процедура СинхронизироватьКлючиПриЗаписиСправочника(Объект, Отказ) Экспорт
	
	Если Объект.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	СинхронизироватьКлючи(Объект);
	
КонецПроцедуры

Процедура УстановитьУсловноеОфорлениеПоляСКлючемРеестраДокументов(Форма, ИмяПоля, ПутьКДаннымПоля) Экспорт
	
	//
	ЭлементУсловногоОформления = Форма.УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяПоля);

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКДаннымПоля);
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
	КлючиПустыхСсылок = Новый СписокЗначений;
	КлючиПустыхСсылок.ЗагрузитьЗначения(ОбщегоНазначенияУТПовтИсп.ЗначенияПустыхКлючейРеестраДокументов());
	ОтборЭлемента.ПравоеЗначение = КлючиПустыхСсылок;

	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", "");
	
КонецПроцедуры

// Возвращает значения хозяйственных операций недоступных пользователю по группе доступа для объекта информационной базы.
//
// Параметры:
//	ИмяТаблицы - Строка - полное имя объекта информационной базы, например, "РегистрСведений.РеестрДокументов".
//
// Возвращаемое значение:
//	Массив - элементами, которого являются значения хозяйственных операций.
//
Функция НеДоступныеХозяйственныеОперации(ИмяТаблицы)
	
	ТипЗначения = Тип("ПеречислениеСсылка.ХозяйственныеОперации");
	
	НеДоступныеХозяйственныеОперации = Новый Массив;
	ДоступныеХозяйственныеОперации   = УправлениеДоступом.РазрешенныеЗначенияДляДинамическогоСписка(ИмяТаблицы, ТипЗначения);
	
	Если ДоступныеХозяйственныеОперации <> Неопределено Тогда
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	НастройкиХозяйственныхОпераций.ХозяйственнаяОперация КАК ХозяйственнаяОперация
		|ИЗ
		|	Справочник.НастройкиХозяйственныхОпераций КАК НастройкиХозяйственныхОпераций
		|ГДЕ
		|	НЕ НастройкиХозяйственныхОпераций.ЭтоГруппа
		|	И НЕ НастройкиХозяйственныхОпераций.ПометкаУдаления
		|	И НастройкиХозяйственныхОпераций.ИспользоватьДляОграниченийДоступа
		|	И НЕ НастройкиХозяйственныхОпераций.ХозяйственнаяОперация В(&РазрешенныеХозяйственныеОперации)";
		
		Запрос.УстановитьПараметр("РазрешенныеХозяйственныеОперации", ДоступныеХозяйственныеОперации);
		
		РезультатЗапроса = Запрос.Выполнить();
		НеДоступныеХозяйственныеОперации = РезультатЗапроса.Выгрузить().ВыгрузитьКолонку("ХозяйственнаяОперация");
	КонецЕсли;
	
	Возврат НеДоступныеХозяйственныеОперации;
	
КонецФункции

#КонецОбласти

#Область ДобавлениеУдалениеКнопокСозданияВЖурналахДокументов

Процедура СформироватьКомандыСоздания(Форма, ИмяТаблицыСХозяйственнымиОперациямиИДокументами, ИмяГруппыСоздать, ИмяГруппыСоздатьКонтекст, ПрефиксЭлементов) 
	
	СтруктураИменГрупп = Новый Структура;
	СтруктураИменГрупп.Вставить(ИмяГруппыСоздать, Ложь); // Ложь, т.к. группа не контекстная
	СтруктураИменГрупп.Вставить(ИмяГруппыСоздатьКонтекст, Истина); // Истина, т.к. контекстная группа
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ВЫРАЗИТЬ(Таблица.Порядок КАК ЧИСЛО(10, 0)) КАК Порядок,
	|	ВЫРАЗИТЬ(Таблица.ИдентификаторОбъектаМетаданных КАК Справочник.ИдентификаторыОбъектовМетаданных) КАК ИдентификаторОбъектаМетаданных,
	|	ВЫРАЗИТЬ(Таблица.ХозяйственнаяОперация КАК Перечисление.ХозяйственныеОперации) КАК ХозяйственнаяОперация,
	|	ВЫРАЗИТЬ(Таблица.ДокументПредставление КАК СТРОКА(250)) КАК ДокументПредставление,
	|	ВЫРАЗИТЬ(Таблица.ГруппаКнопок КАК СТРОКА(100)) КАК ГруппаКнопок
	|ПОМЕСТИТЬ Таблица
	|ИЗ
	|	&Таблица КАК Таблица
	|ГДЕ
	|	Таблица.Отбор
	|	И Таблица.ДобавитьКнопкуСоздать
	|	И Таблица.ПравоДоступаДобавление
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.Порядок 								КАК Порядок,
	|	Таблица.ИдентификаторОбъектаМетаданных 			КАК ИдентификаторОбъектаМетаданных,
	|	Таблица.ХозяйственнаяОперация 					КАК ХозяйственнаяОперация,
	|	ПРЕДСТАВЛЕНИЕ(Таблица.ХозяйственнаяОперация) 	КАК ХозОперацияСиноним,
	|	Таблица.ДокументПредставление 					КАК ДокументПредставление,
	|	Таблица.ГруппаКнопок 							КАК ГруппаКнопок
	|ИЗ
	|	Таблица КАК Таблица";
	
	ТаблицаХозОперацийИДокументов = Форма[ИмяТаблицыСХозяйственнымиОперациямиИДокументами].Выгрузить();
	
	Если ТаблицаХозОперацийИДокументов.Колонки.Найти("Порядок") = Неопределено Тогда
		ТаблицаХозОперацийИДокументов.Колонки.Добавить("Порядок",
			Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(10, 0)));
	КонецЕсли;
	Если ТаблицаХозОперацийИДокументов.Колонки.Найти("ГруппаКнопок") = Неопределено Тогда
		ТаблицаХозОперацийИДокументов.Колонки.Добавить("ГруппаКнопок",
			Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(100)));
	КонецЕсли;
	
	Запрос.УстановитьПараметр("Таблица", ТаблицаХозОперацийИДокументов);
	
	ТаблицаДокументов = Запрос.Выполнить().Выгрузить();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВЫРАЗИТЬ(Таблица.ИдентификаторОбъектаМетаданных КАК Справочник.ИдентификаторыОбъектовМетаданных) КАК ИдентификаторОбъектаМетаданных,
	|	ВЫРАЗИТЬ(Таблица.ХозяйственнаяОперация КАК Перечисление.ХозяйственныеОперации) КАК ХозяйственнаяОперация,
	|	ВЫРАЗИТЬ(Таблица.ДокументПредставление КАК СТРОКА(250)) КАК ДокументПредставление,
	|	ВЫРАЗИТЬ(Таблица.ХозОперацияСиноним КАК СТРОКА(500)) КАК ХозОперацияСиноним,
	|	ВЫРАЗИТЬ(Таблица.ГруппаКнопок КАК СТРОКА(100)) КАК ГруппаКнопок,
	|	ВЫРАЗИТЬ(Таблица.Порядок КАК ЧИСЛО(10, 0)) КАК Порядок
	|ПОМЕСТИТЬ Таблица
	|ИЗ
	|	&Таблица КАК Таблица
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(КоличествоДокументов.ИдентификаторОбъектаМетаданных) КАК Количество
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		Таблица.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных
	|	ИЗ
	|		Таблица КАК Таблица) КАК КоличествоДокументов
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(КоличествоХозяйственныхОпераций.ХозяйственнаяОперация) КАК Количество
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		Таблица.ХозяйственнаяОперация КАК ХозяйственнаяОперация
	|	ИЗ
	|		Таблица КАК Таблица) КАК КоличествоХозяйственныхОпераций
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных,
	|	Таблица.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	ВЫБОР 
	|		КОГДА Таблица.ДокументПредставление <> """"
	|			ТОГДА Таблица.ДокументПредставление
	|		ИНАЧЕ Таблица.ИдентификаторОбъектаМетаданных.Синоним
	|	КОНЕЦ КАК Синоним,
	|	Таблица.ИдентификаторОбъектаМетаданных.Имя КАК Имя,
	|	Таблица.ИдентификаторОбъектаМетаданных.ПолноеИмя КАК ПолноеИмяДокумента,
	|	Таблица.ГруппаКнопок КАК ГруппаКнопок
	|ИЗ
	|	Таблица КАК Таблица
	|
	|УПОРЯДОЧИТЬ ПО
	|	Порядок,
	|	Синоним,
	|	ХозОперацияСиноним
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных,
	|	Таблица.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	Таблица.Порядок КАК Порядок,
	|	ВЫБОР 
	|		КОГДА Таблица.ДокументПредставление <> """"
	|			ТОГДА Таблица.ДокументПредставление
	|		ИНАЧЕ Таблица.ИдентификаторОбъектаМетаданных.Синоним
	|	КОНЕЦ КАК Синоним,
	|	Таблица.ИдентификаторОбъектаМетаданных.Имя КАК Имя,
	|	Таблица.ИдентификаторОбъектаМетаданных.ПолноеИмя КАК ПолноеИмяДокумента,
	|	Таблица.ГруппаКнопок КАК ГруппаКнопок
	|ИЗ
	|	Таблица КАК Таблица
	|
	|УПОРЯДОЧИТЬ ПО
	|	Порядок,
	|	Синоним,
	|	ХозОперацияСиноним
	|
	|ИТОГИ 
	|	МАКСИМУМ(Синоним),
	|	МАКСИМУМ(ГруппаКнопок),
	|	МАКСИМУМ(Порядок)
	|ПО
	|	ИдентификаторОбъектаМетаданных";
	
	Запрос.УстановитьПараметр("Таблица", ТаблицаДокументов);
	МассивРезультатов = Запрос.ВыполнитьПакет();
	
	КоличествоДокументов = 0;
	ВыборкаКоличествоДокументов = МассивРезультатов[1].Выбрать();
	Если ВыборкаКоличествоДокументов.Следующий() Тогда 
		КоличествоДокументов = ВыборкаКоличествоДокументов.Количество;
	КонецЕсли;
	
	КоличествоХозОпераций = 0;
	ВыборкаКоличествоХозОпераций = МассивРезультатов[2].Выбрать();
	Если ВыборкаКоличествоХозОпераций.Следующий() Тогда 
		КоличествоХозОпераций = ВыборкаКоличествоХозОпераций.Количество;
	КонецЕсли;
	
	Для Каждого ИмяКонтекстГруппы Из СтруктураИменГрупп Цикл
		
		ИмяГруппыСоздать 			= ИмяКонтекстГруппы.Ключ;
		ДобавлениеВКонтекстноеМеню 	= ИмяКонтекстГруппы.Значение;
		
		Префикс = ПрефиксЭлементов + ?(ДобавлениеВКонтекстноеМеню, "Контекст", "");
		
		ГруппаСоздать = Форма.Элементы[ИмяГруппыСоздать];
	
		УдалитьКомандыСоздания(Форма, ГруппаСоздать, ИмяГруппыСоздать);
		
		СоответствиеГруппКоманды = Новый Соответствие;
		СоответствиеГруппКоманды.Вставить("", ГруппаСоздать);
		
		Если КоличествоДокументов = 1 И КоличествоХозОпераций = 1 Тогда
			
			Выборка = МассивРезультатов[3].Выбрать();
			Если Выборка.Следующий() Тогда   
				МестоРазмещенияКнопки = МестоРазмещенияКнопки("", Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
				ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, НСтр("ru = 'Создать'"), Выборка, Префикс, ГруппаСоздать.ПодчиненныеЭлементы.Количество() = 0);
			КонецЕсли;
					
		ИначеЕсли КоличествоДокументов = 1 И КоличествоХозОпераций > 1 Тогда
			
			Выборка = МассивРезультатов[3].Выбрать();
			Пока Выборка.Следующий() Цикл
				МестоРазмещенияКнопки = МестоРазмещенияКнопки(Выборка.ГруппаКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
				ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, Выборка.ХозяйственнаяОперация, Выборка, Префикс);			
			КонецЦикла;
			
		ИначеЕсли КоличествоДокументов <= 7 И КоличествоХозОпераций = 1 Тогда
			
			Выборка = МассивРезультатов[3].Выбрать();
			Пока Выборка.Следующий() Цикл
				МестоРазмещенияКнопки = МестоРазмещенияКнопки(Выборка.ГруппаКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
				ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, Выборка.Синоним, Выборка, Префикс);
			КонецЦикла;
			
		ИначеЕсли КоличествоДокументов <= 7 И КоличествоХозОпераций > 1 Тогда
			
			Дерево = МассивРезультатов[4].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
			
			Для Каждого СтрокаДокумент Из Дерево.Строки Цикл
				
				Если СтрокаДокумент.Строки.Количество() = 1 Тогда
					МестоРазмещенияКнопки = МестоРазмещенияКнопки(СтрокаДокумент.ГруппаКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
					ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, СтрокаДокумент.Синоним, СтрокаДокумент.Строки[0], Префикс);
				Иначе			
					ГруппаКнопок = ДобавитьГруппуКнопок(Форма, ИмяГруппыСоздать, СтрокаДокумент.Имя, СтрокаДокумент.Синоним, Префикс);
					Для Каждого Строка Из СтрокаДокумент.Строки Цикл
						ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, ГруппаКнопок, Строка.ХозяйственнаяОперация, Строка, Префикс);
					КонецЦикла;
				КонецЕсли;
				
			КонецЦикла;
			
		ИначеЕсли Форма.ОтборТипыДокументов.Количество() > 7 Тогда
			
			ДобавитьКомандуСКнопкойДляОткрытияФормыВыбора(Форма, ИмяГруппыСоздать, Префикс); 
					
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ДобавитьГруппуКнопок(Форма, ИмяГруппыСоздать, ИмяНовойГруппы, ЗаголовокНовойГруппы, Префикс)
	
	Элемент = Форма.Элементы.Добавить(Префикс + "ГруппаСоздать_" + СокрЛП(ИмяНовойГруппы), Тип("ГруппаФормы"), Форма.Элементы[ИмяГруппыСоздать]);
	Элемент.Заголовок = СокрЛП(ЗаголовокНовойГруппы);
	Возврат Элемент;
КонецФункции

Функция ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, Родитель, ЗаголовокКнопки, ТекущаяСтрокаТаблицы, Префикс, ОднаКнопка = Ложь)
	
	МетаданныеХозяйственнойОперации = ТекущаяСтрокаТаблицы.ХозяйственнаяОперация.Метаданные();
	МетаданныеДокумента = Метаданные.НайтиПоПолномуИмени(ТекущаяСтрокаТаблицы.ПолноеИмяДокумента);
	
	ИмяЗначенияПеречисления = XMLСтрока(ТекущаяСтрокаТаблицы.ХозяйственнаяОперация);
	ИмяМетаданныхДокумента = МетаданныеДокумента.Имя;
	
	Если ОднаКнопка Тогда 
		Форма.Элементы[ИмяГруппыСоздать].Вид = ВидГруппыФормы.ГруппаКнопок;
	Иначе
		Форма.Элементы[ИмяГруппыСоздать].Вид = ВидГруппыФормы.Подменю;
		Форма.Элементы[ИмяГруппыСоздать].Картинка = БиблиотекаКартинок.СоздатьЭлементСписка;		
	КонецЕсли;
	
	ИмяКоманды = Префикс + "Создать_" + ИмяЗначенияПеречисления + "_" + ИмяМетаданныхДокумента;
	Команда = Форма.Команды.Добавить(ИмяКоманды);
	Команда.Действие = "Подключаемый_СоздатьДокумент";
	Команда.Заголовок = СокрЛП(ЗаголовокКнопки);
	Если ОднаКнопка Тогда 
		Команда.Отображение = ОтображениеКнопки.КартинкаИТекст;
		Команда.Картинка = БиблиотекаКартинок.СоздатьЭлементСписка;
	КонецЕсли;
	
	Элемент = Форма.Элементы.Добавить(ИмяКоманды, Тип("КнопкаФормы"), Родитель);
	Элемент.ИмяКоманды = ИмяКоманды;

КонецФункции

Функция ДобавитьКомандуСКнопкойДляОткрытияФормыВыбора(Форма, ИмяГруппыСоздать, Префикс)
	 
	Форма.Элементы[ИмяГруппыСоздать].Вид = ВидГруппыФормы.ГруппаКнопок;
	
	ИмяКоманды = Префикс + "Создать_ДокументЧерезФормуВыбора";
	Команда = Форма.Команды.Добавить(ИмяКоманды);
	Команда.Действие = "Подключаемый_СоздатьДокументЧерезФормуВыбора";
	Команда.Заголовок = НСтр("ru = 'Создать...'");	
	Команда.Отображение = ОтображениеКнопки.КартинкаИТекст;
	Команда.Картинка = БиблиотекаКартинок.СоздатьЭлементСписка;
	
	Элемент = Форма.Элементы.Добавить(ИмяКоманды, Тип("КнопкаФормы"), Форма.Элементы[ИмяГруппыСоздать]);
	Элемент.ИмяКоманды = ИмяКоманды;

КонецФункции

Процедура УдалитьКомандыСоздания(Форма, Родитель, ИмяГруппыСоздать)
	
	// Если родитель - не корневая группа и он не создан программно, то удалять ничего не нужно.
	Если Родитель <> Форма.Элементы[ИмяГруппыСоздать] 
		И СтрНайти(Родитель.Имя, "Создать_") = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Родитель) = Тип("ГруппаФормы") Тогда 
		
		Количество = Родитель.ПодчиненныеЭлементы.Количество();
		
		Для Индекс = 1 По Количество Цикл
			УдалитьКомандыСоздания(Форма, Родитель.ПодчиненныеЭлементы.Получить(0), ИмяГруппыСоздать);
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Родитель) = Тип("КнопкаФормы") Тогда 
		Форма.Команды.Удалить(Форма.Команды.Найти(Родитель.Имя));		
	КонецЕсли;
	
	Если СтрНайти(Родитель.Имя, "Создать_") <> 0 Тогда 
		Форма.Элементы.Удалить(Родитель);
	КонецЕсли;
	
КонецПроцедуры

Функция МестоРазмещенияКнопки(ИмяГруппыКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды)

	ГруппаКнопок = СоответствиеГруппКоманды.Получить(СокрЛП(ИмяГруппыКнопок));
	Если ГруппаКнопок = Неопределено Тогда
		ГруппаКнопок = ДобавитьГруппуКнопок(Форма, ИмяГруппыСоздать, ИмяГруппыКнопок, ИмяГруппыСоздать, Префикс);	
		ГруппаКнопок.Вид = ВидГруппыФормы.ГруппаКнопок;
		СоответствиеГруппКоманды.Вставить(СокрЛП(ИмяГруппыКнопок), ГруппаКнопок);
	КонецЕсли; 

	Возврат ГруппаКнопок;
	
КонецФункции

#КонецОбласти

#Область ПоискВТаблице

Функция УпорядочитьПронумерованныеСтроки(Таблица, МассивСтрок)
	
	СтрокиУпорядочены = МассивПронумерованныхСтрокУпорядочен(МассивСтрок);
	
	Если СтрокиУпорядочены Тогда
		
		Результат = МассивСтрок;
		
	Иначе
		
		ТаблицаСортировки = Новый ТаблицаЗначений;
		ТаблицаСортировки.Колонки.Добавить("Строка", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
		ТаблицаСортировки.Колонки.Добавить("ПорядковыйНомер", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
		
		Для Индекс = 0 По МассивСтрок.ВГраница() Цикл
			
			Строка = МассивСтрок[Индекс];
			
			НоваяСтрока = ТаблицаСортировки.Добавить();
			НоваяСтрока.Строка = Строка;
			НоваяСтрока.ПорядковыйНомер = Строка.ПорядковыйНомер;
			
		КонецЦикла;
		
		ТаблицаСортировки.Сортировать("ПорядковыйНомер ВОЗР");
		
		Результат = Новый Массив;
		Для Индекс = 0 По ТаблицаСортировки.Количество()-1 Цикл
			
			Результат.Добавить(ТаблицаСортировки[Индекс].Строка);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция МассивПронумерованныхСтрокУпорядочен(МассивСтрок)
	
	Результат = Истина;
	
	МаксИндекс = МассивСтрок.ВГраница();
	
	ПредыдущаяСтрока = МассивСтрок[МаксИндекс];
	Для Сч = 1 По МаксИндекс Цикл
		
		ТекущаяСтрока = МассивСтрок[МаксИндекс-сч];
		Если ТекущаяСтрока.ПорядковыйНомер > ПредыдущаяСтрока.ПорядковыйНомер Тогда
			Результат = Ложь;
			Прервать;
		КонецЕсли;
		
		ПредыдущаяСтрока = ТекущаяСтрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция УпорядочитьНеПронумерованныеСтроки(Таблица, МассивСтрок)
	
	ТаблицаИндексов = ИндексыНеПронумерованныхСтрок(Таблица, МассивСтрок);
	СтрокиУпорядочены = ТаблицаИндексовУпорядочена(ТаблицаИндексов);
	
	Если СтрокиУпорядочены Тогда
		
		Результат = МассивСтрок;
		
	Иначе
		
		ТаблицаИндексов.Сортировать("ИндексТаблицы ВОЗР");
		
		Результат = Новый Массив;
		Для Индекс = 0 По ТаблицаИндексов.Количество()-1 Цикл
			
			Результат.Добавить(ТаблицаИндексов[Индекс].Строка);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ИндексыНеПронумерованныхСтрок(Таблица, МассивСтрок)
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Строка", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	Результат.Колонки.Добавить("ИндексТаблицы", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	Для Индекс = 0 По МассивСтрок.ВГраница() Цикл
		
		Строка = МассивСтрок[Индекс];
		
		НоваяСтрока = Результат.Добавить();
		НоваяСтрока.Строка = Строка;
		НоваяСтрока.ИндексТаблицы = Таблица.Индекс(Строка);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ТаблицаИндексовУпорядочена(ТаблицаИндексов)
	
	Результат = Истина;
	
	ПредыдущаяСтрока = ТаблицаИндексов[0];
	Для Индекс = 1 По ТаблицаИндексов.Количество()-1 Цикл
		
		ТекущаяСтрока = ТаблицаИндексов[Индекс];
		Если ТекущаяСтрока.ИндексТаблицы < ПредыдущаяСтрока.ИндексТаблицы Тогда
			Результат = Ложь;
			Прервать;
		КонецЕсли;
		
		ПредыдущаяСтрока = ТекущаяСтрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти
#КонецОбласти
